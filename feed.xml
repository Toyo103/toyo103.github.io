<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-10-16T08:23:24+00:00</updated><id>/feed.xml</id><title type="html">Toyo.log</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>Toyo</name></author><entry><title type="html">자바로 배우는 핵심 자료구조와 알고리즘</title><link href="/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html" rel="alternate" type="text/html" title="자바로 배우는 핵심 자료구조와 알고리즘" /><published>2025-09-11T00:00:00+00:00</published><updated>2025-09-11T00:00:00+00:00</updated><id>/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%ED%95%B5%EC%8B%AC%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"><![CDATA[<h2 id="1-인터페이스-프로그래밍">1. 인터페이스 프로그래밍</h2>
<ul>
  <li>java.util.List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List 인터페이스에 정의된 메소드는 ArrayList와 LinkedList 또는 List 인터페이스를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨</li>
  <li>라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨</li>
</ul>

<h2 id="2-빅오-표기법">2. 빅오 표기법</h2>
<ul>
  <li>알고리즘의 성능(시간 혹은 공간 복잡도)을 입력 크기 n에 따라 표현하는 수학적 표기법</li>
  <li>전체 코드 구현 이전에 컴퓨터의 성능에 구애받지 않고 알고리즘의 소요 시간을 정량화하기 위해 입력 크기에 따른 증가율을 비교함</li>
  <li>입력 크기가 커질수록 알고리즘 간 성능 차이가 커지므로, 분석은 대규모 입력에 초점을 맞춰야 함. 빅오 표기법은 이러한 상황에서 알고리즘의 최악의 실행 시간을 표현하여 성능을 평가하는 데 사용</li>
  <li>실행 속도 O(1) &lt; O(log N) &lt; O(N) &lt; O(N log N) &lt; O(N^2) &lt; O(2^N)</li>
</ul>

<h2 id="3-arraylist">3. ArrayList</h2>
<ul>
  <li>java.util.ArrayList 클래스는 java.util.List 인터페이스의 구현 클래스 중 하나. List 인터페이스 문서에 정의된 add, gets, rem, set, indexOf, equals 메소드 규칙을 참고하여 ArrayList 클래스와 유사한 MyArrayList 클래스를 작성해보면 아래와 같음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MyArrayList&lt;T&gt; implements List&lt;T&gt; {
      int size;
      private T[] array;

      @Override
      public boolean add(T element) {
          if (size &gt;= array.length) {
              // 배열의 전체 크기보다 더 많은 값이 삽입되면 크기가 그 2배인 배열을 다시 생성, 기존값 복사
              // 자바에선 타입 파라미터(T)로 배열을 초기화할 수 없으므로 Object 배열 생성 후 형변환
              E[] bigger = (T[]) new Object[array.length * 2];
              System.arraycopy(array, 0, bigger, 0, array.length);
              array = bigger;
          }
          array[size] = element;
          size++;
          return true;
      }

      @Override
      public void add(int index, T element) {
          if (index &lt; 0 || index &gt; size) {
              throw new IndexOutOfBoundsException();
          }
          add(element);

          // shift the elements
          for (int i=size-1; i&gt;index; i--) {
              array[i] = array[i-1];
          }
          // put the new one in the right place
          array[index] = element;
      }

      @Override
      public T get(int index) {
          if (index &lt; 0 || index &gt;= size) {
              throw new IndexOutOfBoundsException();
          }
          return array[index];
      }

      @Override
      public T set(int index, T element) {
          E old = get(index);
          array[index] = element;
          return old;
      }

      @Override
      public int indexOf(Object target) {
          for (int i = 0; i &lt; size; i++) {
              if (equals(target, array[i])) return i;
          }
          return -1;
      }

      private boolean equals(Object target, Object element) {
          if (target == null) {
              return element == null;
          } else {
              //Object 객체의 equals 메소드를 호출하여 실제 객체에서 재정의한 equals 메소드가 호출됨 
              return target.equals(element);
          }
      }

      @Override
      public boolean remove(Object obj) {
          int index = indexOf(obj);
          if (index == -1) {
              return false;
          }
          remove(index);
          return true;
      }

      @Override
      public T remove(int index) {
          E element = get(index);
          for (int i=index; i &lt; size-1; i++) {
              array[i] = array[i+1];
          }
          size--;
          return element;
      }

      ...

</code></pre></div>    </div>
  </li>
  <li>get, set, indexOf, equals, remove 메소드의 시간 복잡도는 각각 상수, 상수, 선형, 상수, 선형임</li>
  <li>add(T element) 메소드의 시간 복잡도를 계산하기 위해 크기가 2인 배열에 n개 요소를 추가할 때의 평균 연산 횟수를 고려하면
    <ul>
      <li>1~2번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장</li>
      <li>3번째 호출 : 기존의 2배 크기(=4)를 가진 배열을 생성하여 기존 요소 2개를 복사하고 요소 저장</li>
      <li>4번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장</li>
      <li>5번째 호출 : 기존의 2배 크기(=8)를 가진 배열을 생성하여 기존 요소 4개를 복사하고 요소 저장</li>
      <li>6~8번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장</li>
      <li>위의 패턴 반복</li>
    </ul>
  </li>
  <li>결과적으로 n번 추가하면 요소 총 n개를 저장하고 총 n-2개를 복사함. 따라서 총 연산 횟수는 2n-2이고, 평균 횟수는 n으로 나누어 2-2/n이 됨</li>
  <li>n이 커질수록 두 번째 항인 2/n는 작아지므로 add(T element) 메소드는 상수 시간으로 간주됨</li>
  <li>일련의 호출에서 평균 시간을 계산하는 알고리즘 분류 방법을 <strong>분할 상환 분석</strong>이라고 함. 핵심 개념은 배열의 크기를 조정할 때마다 배열의 길이가 2배로 늘어나 각 요소를 복사하는 횟수를 제한한다는 것. 매번 고정된 양을 더해서 크기를 늘리는 대신 곱하여 연산 횟수를 더 제한함</li>
  <li>이어서 removeAll 메소드를 구현하면 아래와 같음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  @Override
  public boolean removeAll(Collection&lt;?&gt; collection) {
      boolean flag = true;
      for (Object obj: collection) {
          flag &amp;= remove(obj);
      }
      return flag;
  }
</code></pre></div>    </div>
  </li>
  <li>반복문을 돌리며 선형인 remove 메소드를 호출하고 있지만 collection 크기가 n에 비례하지 않는다면 이차가 아님</li>
</ul>

<h2 id="4-linkedlist">4. LinkedList</h2>
<ul>
  <li>연결 리스트에서 각 노드는 리스트의 다음 노드에 대한 참조를 포함. 연결 구조의 다른 예로는 트리와 그래프가 있음</li>
  <li>java.util.List 인터페이스를 상속받아 MyLinkedList를 직접 구현
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MyLinkedList&lt;E&gt; implements List&lt;E&gt; {

      private class Node {
          public E data;
          public Node next;

          public Node(E data) {
              this.data = data;
              this.next = null;
          }
      }

      private int size;            // 요소 더하거나 제거할 때마다 갱신
      private Node head;           // 리스트의 첫 번째 노드 참조. 빈 리스트이면 null

      public MyLinkedList() {
          head = null;
          size = 0;
      }

      @Override
      public boolean add(E element) {
          if (head == null) {
              head = new Node(element);
          } else {
              Node node = head;
              for ( ; node.next != null; node = node.next) {}
              node.next = new Node(element);
          }
          size++;
          return true;
      }

      @Override
      public void clear() {
          head = null;
          size = 0;
      }
</code></pre></div>    </div>
  </li>
  <li>LinkedList는 ArrayList와 달리 리스트 자체가 파괴되지 않아도 요소를 제거하면 리스트 크기가 줄어들고 사용하지 않는 노드는 즉시 가비지 컬렉션이 될 수 있다는 장점이 있음</li>
  <li>add 메소드는 리스트의 끝까지 이동해야 하므로 선형 증가차수를 가짐</li>
  <li>clear 메소드로 LinkedList의 첫 번째 노드 참조를 제거할 경우에는 순차적으로 연결리스트의 각 노드들에 대한 참조가 사라지게 되어 가비지 컬렉션이 선형이 됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      private boolean equals(Object target, Object element) {
          if (target == null) {
              return element == null;
          } else {
              return target.equals(element);  //Object를 오버라이드 한 target의 실제 equals 메소드 호출
          }
      }

      @Override
      public int indexOf(Object target) {
          Node node = head;
          for (int i=0; i &lt; size; i++){
              if (equals(target, node.data)) {
                  return i;
              }
              node = node.next;
          }
          return -1;
      }

      private Node getNode(int index) {
          if (index &lt; 0 || index &gt;= size) {
              throw new IndexOutOfBoundsException();
          }
          Node node = head;
          for (int i=0; i&lt;index; i++) {
              node = node.next;
          }
          return node;
      }

      @Override
      public E get(int index) {
          Node node = getNode(index);
          return node.data;
      }

      @Override
      public void add(int index, E element) {
          if (index == 0) {
              head = new Node(element, head);
          } else {
              Node node = getNode(index - 1);
              node.next = new Node(element, node.next);
          }
          size++;
      }

      @Override
      public E remove(int index) {
          E element = get(index);
          if (index == 0) {
              head = head.next;
          } else {
              Node node = getNode(index-1);
              node.next = node.next.next;
          }
          size--;
          return element;
      }
</code></pre></div>    </div>
  </li>
  <li>indexOf는 선형, remove와 add(int index, E element)도 index가 0인 특별한 경우를 제외하고 getNode가 선형이므로 선형</li>
  <li>MyArrayList 클래스는 끝에 추가하고 끝에서 제거할 때와 get/set 메서드 연산에 이점이 있으며, MyLinkedList 클래스는 시작에 추가하고 시작에서 제거하는 연산에 이점이 있음. 다른 연산에서는 증가 차수가 같음</li>
  <li>ArrayList 끝에 새로운 요소를 추가하는 실행 시간 측정 테스트
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public static void profileArrayListAddEnd() {
      Timeable timeable = new Timeable() {
          List&lt;String&gt; list;

          // 초기 설정: ArrayList 사용
          public void setup(int n) {
              list = new ArrayList&lt;String&gt;();
          }

          // 테스트 내용: 리스트 맨 앞에 n개의 요소를 추가
          public void timeMe(int n) {
              for (int i = 0; i &lt; n; i++) {
                  list.add("a string");
              }
          }
      };
      int startN = 4000;  // 몇 번 추가할지에 대한 n값
      int endMillis = 1000;   // timingLoop 테스트 실행시간
      runProfiler("ArrayList add first", timeable, startN, endMillis);
  }

  private static void runProfiler(String title, Timeable timeable, int startN, int endMillis) {
      Profiler profiler = new Profiler(title, timeable);
      XYSeries series = profiler.timingLoop(startN, endMillis);
      profiler.plotResults(series);
  }
</code></pre></div>    </div>
    <ul>
      <li>리스트 맨 앞에 n개의 요소를 추가하는 시간 측정 테스트 수행. 테스트에 사용되는 Profiler, Timeable 클래스는 교재의 별도 코드 참고</li>
      <li>테스트 결과 : endMillis 동안 루프를 돌며 2배식 증가되는 startN과, 해당 startN에서 10회 씩 timeMe를 수행한 총 소요 시간 출력
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  4000, 3
  8000, 0
  16000, 1
  32000, 2
  64000, 3
  128000, 6
  256000, 18
  512000, 30
  1024000, 8
  2048000, 185
  4096000, 242
  8192000, 544
  16384000, 1325
</code></pre></div>        </div>
      </li>
      <li>테스트 수행 결과 그래프가 a + bn (직선)이 되는 것 확인 가능. a는 Y 절편, b는 기울기</li>
      <li>plotResults 메소드는 테스트 수행 결과를 그래프로 출력</li>
      <li>측정에 잡음이 많으면 그래프 차이를 확인하기 어려우므로 이차 이상은 log-log 스케일을 적용해 직선 그래프 간의 기울기의 차이를 확인할 수 있음. 기울기가 1에 가까우면 선형, 2에 가까우면 이차로 봐야함</li>
      <li>timeMe 메소드를 ArrayList 맨 앞에 n개의 새로운 요소를 추가하도록 수정하면 전체시간은 이차가 되며, log-log 스케일을 적용했을때 기울기가 2에 가까워짐</li>
      <li>MyLinkedList 클래스를 이용하여 시작과 끝에 n개의 새로운 요소를 추가하도록 수정하면 둘다 1에 가까운 기울기가 출력됨</li>
    </ul>
  </li>
</ul>

<h2 id="5-이중-연결-리스트">5. 이중 연결 리스트</h2>
<ul>
  <li>앞서 구현한 단일 연결 리스트인 MyLinkedList와 달리 java.util.LinkedList 클래스는 이중 연결 리스트로 아래와 같은 특징이 있음
    <ul>
      <li>각 노드는 다음 노드와 이전 노드의 참조를 포함</li>
      <li>LinkedList 객체는 첫번째와 마지막 요소에 대한 참조를 포함</li>
    </ul>
  </li>
  <li>
    <p>ArrayList, 단일 연결 리스트, 이중 연결 리스트 성능 비교</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">구분</th>
          <th style="text-align: center">ArrayList</th>
          <th style="text-align: center">MyLinkedList</th>
          <th style="text-align: center">LinkedList</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">add(끝)</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">add(시작)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">add(일반적으로)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
        <tr>
          <td style="text-align: left">get/set</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
        <tr>
          <td style="text-align: left">indexOf/lastIndexOf</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
        <tr>
          <td style="text-align: left">isEmpty/size</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">remove(끝)</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">remove(시작)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">remove(일반적으로)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>ArrayList 클래스는 get/set 메서드에서 유일하게 연결 리스트보다 나은 성능을 보임</li>
  <li>반대로 실행시간이 시작이나 끝 근처에 요소를 추가하거나 제거하는 연산에 의존한다면 LinkedList 클래스가 좋음</li>
  <li>단, 이러한 연산이 프로그램의 실행시간에 뚜렷한 영향을 미치지 않는다면 List 구현에 대한 선택은 큰 의미가 없음</li>
  <li>또한 리스트가 충분히 크지 않으면 위의 성능표에 있는 성능차이는 해당되지 않으며 공간면에서는 ArrayList가 참조가 차지하는 공간이 적어 연결리스트보다 효율이 높음</li>
</ul>

<h2 id="6-트리-순회">6. 트리 순회</h2>

<h3 id="61-웹-크롤러-구현을-위한-dfs-트리-순회">6.1 웹 크롤러 구현을 위한 DFS 트리 순회</h3>
<ul>
  <li>웹 크롤러가 HTML 페이지를 다운로드하고 파싱해 본문과 링크를 추출하도록 하기 위해 jsoup 라이브러리를 사용</li>
  <li>jsoup은 HTML 문서를 노드 기반 연결 자료구조인 DOM 트리 형태로 표현하며, 이 트리 구조는 깊이 우선 탐색(DFS)을 수행하기에 적합함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class WikiNodeExample {
      public static void main(String[] args) throws IOException {
          String url = "https://en.wikipedia.org/wiki/Java_(programming_language)";
            
          //String 타입의 URL을 인자로 받아 웹 서버에 접속
          Connection conn = Jsoup.connect(url);
          //get 메소드는 HTML 을 다운로드하여 파싱하고 DOM 트리를 나타내는 Document 객체를 반환
          Document doc = conn.get();
            
          Element content = doc.getElementById("mw-content-text");
          Elements paras = content.select("p");
          Element firstPara = paras.get(0);
		
          //재귀적 방법을 사용한 DOM 트리 깊이 우선 탐색
          recursiveDFS(firstPara);
          System.out.println();

          //반복적 방법을 사용한 DOM 트리 깊이 우선 탐색
          iterativeDFS(firstPara);
          System.out.println();
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="62-dfs로-트리를-순회하는-2가지-방법">6.2 DFS로 트리를 순회하는 2가지 방법</h3>

<h4 id="621-재귀적-방법을-사용한-트리-순회">6.2.1 재귀적 방법을 사용한 트리 순회</h4>
<ul>
  <li>자식 노드를 탐색하기에 앞서 각 TextNode의 내용을 출력하는 전위 순회 방식
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  private static void recursiveDFS(Node node) {
      if (node instanceof TextNode) {
          System.out.print(node);
      }
      for (Node child: node.childNodes()) {
          recursiveDFS(child);
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="622-반복적-방법을-사용한-트리-순회--스택-사용">6.2.2 반복적 방법을 사용한 트리 순회 : 스택 사용</h4>
<ul>
  <li>스택 자료구조는 push, pop, peek, isEmpty 등 List의 일부 기능만 제공하지만 단순하여 코드 가독성을 높이고 오류 발생 가능성을 줄임. 또한 API가 적으면 효율적으로 구현하기가 더 쉬워짐</li>
  <li>자바로 스택 구현 시 기존 ArrayList나 LinkedList 클래스를 사용하면 잘못된 위치에 추가하거나 잘못된 순서로 제거하는 실수가 발생할 수 있고, 자바의 Stack 클래스는 오래된 버전이라 최근 JCF와 일치하지 않으므로 ArrayDeque같은 Deque 인터페이스를 구현한 클래스를 사용하는 편이 좋음</li>
  <li>Deque는 양쪽에 끝이 있는 큐로, 자바에서 Deque 인터페이스는 push 와 pop, peek, isEmpty 메서드를 제공하므로 스택으로 구현할 수 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  private static void iterativeDFS(Node root) {
      Deque&lt;Node&gt; stack = new ArrayDeque&lt;Node&gt;();
      stack.push(root);

      while (!stack.isEmpty()) {
          Node node = stack.pop();
          if (node instanceof TextNode) {
              System.out.print(node);
          }

          // 후입선출이므로 역순으로 삽입
          List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(node.childNodes());
          Collections.reverse(nodes);
			
          for (Node child: nodes) {
              stack.push(child);
          }
      }
  }
</code></pre></div>    </div>
  </li>
  <li>반복적 DFS가 재귀적 DFS보다 Iterator 인터페이스(hasNext(), next())로 래핑하기가 용이해 외부에서 순회 제어하기가 더 쉬움</li>
  <li>웹 크롤러를 이용한 철학으로 가는 길 예제 (교재 확인 시 참고용)
    <ul>
      <li>ArrayDeque 스택을 가지고 DOM 트리를 탐색하는 Iterable 구현 클래스 WikiNodeIterable</li>
      <li>jsoup 라이브러리를 활용하여 위키피디아 페이지를 다운로드하는 WikiFetcher 클래스</li>
      <li>WikiNodeIterable을 사용해 페이지의 첫 번째 유효링크를 파싱하는 WikiParser 클래스</li>
      <li>WikiParser와 WikiFetcher을 사용하여 주어진 위키피디아 페이지에서 시작해 첫 번째 링크를 따라가며 목표 페이지에 도달하거나 제한 횟수·사이클·막다른 길에 걸릴 때까지 탐색하는 WikiPhilosophy 클래스</li>
    </ul>
  </li>
</ul>

<h2 id="7-map">7. Map</h2>

<h3 id="71-map-set과-인덱서">7.1 Map, Set과 인덱서</h3>
<ul>
  <li>인덱서는 검색어를 바탕으로 관련 페이지를 찾을 수 있게 하는 자료구조. 검색어가 각 페이지에 몇 번씩 등장하는지를 기록해 가장 관련성이 높은 페이지 식별</li>
  <li>List<Page> 같은 페이지의 컬렉션 형태보다는 키에 해당하는 값을 빠르게 찾을 수 있는 Map이 더 적절함</Page></li>
  <li>검색어와 검색어가 등장하는 페이지의 컬렉션을 매핑하는 Index 라는 클래스, 해당 페이지의 단어 별 등장 횟수를 매핑하는 Termcounter 클래스 구현</li>
  <li>검색어별로 등장하는 페이지를 모아두면, 여러 검색어를 동시에 찾을 때는 교집합 연산으로 공통 페이지를 구해야 함</li>
  <li>Set은 기본적으로 중복 없는 집합 구조로, TermCounter의 equals()와 hashCode() 메소드를 label로 비교하도록 재정의할 경우 페이지 별로 유일하며 교집합 같은 연산을 효율적으로 구현할 수 있는 메소드를 제공해 페이지 별 데이터를 저장하는데 적합함</li>
  <li>Index 클래스는 단어 문자열을 key, TermCounter 객체들의 Set을 value로 가지는 Map을 보유하여 특정 검색어에 대한 페이지별 등장횟수(TermCounter)를 제공
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class Index {
      private Map&lt;String, Set&lt;TermCounter&gt;&gt; index = new HashMap&lt;String, Set&lt;TermCounter&gt;&gt;();
      ...
  }
</code></pre></div>    </div>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class TermCounter {

      private Map&lt;String, Integer&gt; map; //해당 페이지에서 해당 단어가 등장하는 횟수 매핑
      private String label; //페이지의 url

      public TermCounter(String label) {
          this.label = label;
          this.map = new HashMap&lt;String, Integer&gt;();
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>TermCounter는 jsoup 라이브러리의 Element 객체 컬렉션인 Elements 객체를 쪼개 단어별 등장 횟수를 카운트하는 processElement, processTree, processText 메소드 제공. processTree는 Element 객체의 DOM 트리를 탐색하기 위해 앞서 정의된 WikiNodeIterable 클래스를 사용함 (교재 코드 참고)</li>
  <li>자바 Map 인터페이스 구현 클래스로는 HashMap, TreeMap 클래스, Set 인터페이스 구현 클래스로는 HashSet과 TreeSet 클래스가 있음</li>
</ul>

<h3 id="72-map-인터페이스-구현">7.2 Map 인터페이스 구현</h3>
<ul>
  <li>java.util.Map 인터페이스 문서의 메소드 정의를 참고하여 해당 인터페이스를 구현한 MyLinearMap 클래스 작성
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MyLinearMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

      private List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;();

      public class Entry implements Map.Entry&lt;K, V&gt; {
          private K key;
          private V value;

          public Entry(K key, V value) {
              this.key = key;
              this.value = value;
          }
      }

      private Entry findEntry(Object target) {
          for (Entry entry: entries) {
              if (equals(target, entry.getKey())) {
                  return entry;
              }
          }
          return null;
      }

      private boolean equals(Object target, Object obj) {
          if (target == null) {
              return obj == null;
          }
          return target.equals(obj);
      }

      @Override
      public V get(Object key) {
          Entry entry = findEntry(key);
          if (entry == null) return null;
          return entry.getValue();
      }

      @Override
      public V put(K key, V value) {
          Entry entry = findEntry (key)
          if (entry == null){
              entries.add(new Entry(key, value));
          } else {
              V oldValue = entry.getValue();
              entry.setValue(value);
              return oldValue;
          }
      }

      @Override
      public V remove(Object key) {
          Entry entry = findEntry(key);
          if (entry == null) {
              return null;
          } else {
              V value = entry.getValue();
              entries.remove(entry);
              return value;
          }
      }

      @Override
      public void clear() {
          entries.clear();
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>Entry 클래스는 단지 키와 값의 컨테이너로 이 정의는 MyLinearMap 클래스에 중첩되어 있으므로 같은 타입 파라미터인 K와 V를 사용</li>
  <li>equals는 상수시간, findEntry가 선형이므로 put과 get도 선형, remove는 ArrayList 시작이나 중간에서 삭제할경우 요소를 이동해야하지만 2번의 선형 연산이므로 마찬가지로 선형</li>
  <li>해시코드를 사용하면 Map의 증가차수를 더 개선할 수 있음</li>
</ul>

<h3 id="73-hashmap">7.3 HashMap</h3>
<ul>
  <li>Entry 대신 MyLinearMap(Entry List)의 List 컬랙션 사용</li>
  <li>키를 확인하여 어느 내장 Map에 투입할지 결정하기 위해 해시 함수 chooseMap 사용. 이 함수는 0bject 객체를 인자로
받아 해시 코드라는 정수를 반환하는데, 중요한 점은 같은 0bject 객체에 대해서는 항상 같은 해시 코드를 반환해야 함</li>
  <li>자바에서 모든 0bject 객체는 hashCode 라는 메소드를 제공하여 해시 함수를 계산하며, 메서드의 구현은 객체의 종류에 따라 달라짐</li>
  <li>하나의 Map이 여러 MyLinearMap으로 쪼개지는 만큼 탐색해야 하는 각 맵의 엔트리 개수는 더 줄어드므로 FindEntry 메서드와 그것을 호출하는 메서드의 속도가 더 빨라짐
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MyBetterMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

      protected List&lt;MyLinearMap&lt;K, V&gt;&gt; maps;

      public MyBetterMap() {
          makeMaps(2);
      }

      protected void makeMaps(int k) {
          maps = new ArrayList&lt;MyLinearMap&lt;K, V&gt;&gt;(k);
          for (int i=0; i&lt;k; i++) {
              maps.add(new MyLinearMap&lt;K, V&gt;());
          }
      }

      protected MyLinearMap&lt;K, V&gt; chooseMap(Object key) {
          //ath.abs 메서드를 호출하여 절대값을 만들고 %를 사용하여 결과가 0 에서 map.size()-1 사이에 있음을 보장
          int index = key==null ? 0 : Math.abs(key.hashCode()) % maps.size();
          return maps.get(index);
      }

      @Override
      public V get(Object key) {
          MyLinearMap&lt;K, V&gt; map = chooseMap(key);
          return map.get(key);
      }

      @Override
      public V put(K key, V value) {
          MyLinearMap&lt;K, V&gt; map = chooseMap(key);
          return map.put(key, value);
      }

      @Override
      public int size() {
          // add up the sizes of the sub-maps
          int total = 0;
          for (MyLinearMap&lt;K, V&gt; map: maps) {
              total += map.size();
          }
          return total;
      }

      @Override
      public void clear() {
          // clear the sub-maps
          for (int i=0; i&lt;maps.size(); i++) {
              maps.get(i).clear();
          }
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>탐색해야 할 Map 당 Entry가 n/k개로 줄어들지만 chooseMap을 호출하는 get, put 메소드의 성능은 여전히 n에 비례함</li>
  <li>하지만 n과 함께 k를 늘려간다면 n/k의 크기를 제한할 수 있음. 3. ArrayList의 분할상환방식에서 확인한 것처럼 매번 n이 k를 초과할 때 k를 두 배로 늘린다면 put을 상수시간으로 줄일 수 있음. 또한 하위 맵당 엔트리의 개수가 일정하면 단일 하위 맵은 상수 시간으로 검색할 수 있음</li>
  <li>MyBetterMap에서 각 맵의 크기는 ArrayList에 의존하여 자동으로 증가하므로 FACTOR 값만큼 맵 당 최대 엔트리 개수를 제한하고 요소가 새로 추가되면 내장 Map을 새로 생성</li>
  <li>앞서 정의한 MyBetterMap을 상속받아 HashMap 정의
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MyHashMap&lt;K, V&gt; extends MyBetterMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

      protected static final double FACTOR = 1.0; //하위 맵당 최대 엔트리 개수

      @Override
      public V put(K key, V value) {
          V oldValue = super.put(key, value);

          //size() : 엔트리의 전체 개수인 n
          //maps.size() : 내장된 map의 개수인 k
          if (size() &gt; maps.size() * FACTOR) {
              rehash();
          }
          return oldValue;
      }
  }
</code></pre></div>    </div>
  </li>
  <li>put 메소드만 새로 재정의하여 MyBetterMap의 put 메소드를 호출하고 재해시가 필요한지 확인</li>
  <li>n 〉 k * FACTOR면 하위 맵당 엔트리의 개수가 임계치를 초과함을 의미하므로 rehash 메서드를 호출. rehash 메서드가 호출될 때마다 내장된 맵의 개수 k는 두 배가 됨</li>
  <li>맵 당 엔트리 개수가 제한됨으로서 get, containsKey, remove 메소드는 자동으로 상수시간이 됨</li>
  <li>그러나 size 메소드가 여전히 선형이므로 대신 size 인스턴스 변수를 추가하여 put, remove 메소드에서 관리
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ...
  private int size = 0;

  @Override
  public V remove(Object key) {
      MyLinearMap&lt;K, V&gt; map = chooseMap(key);
      size -= map.size();
      V oldValue = map.remove(key);
      size += map.size();
      return oldValue;
  }

  @Override
  public V put(K key, V value) {
      MyLinearMap&lt;K, V› map = chooseMap(key);
      size -= map.size();
      V oldValue = map.put(key, value);
      size += map.size();
      if (size() 〉 maps.size() * FACTOR) {
          size = 0;
          rehash();
      }
      return oldValue;
  }

  @Override
  public int size() {
      return size;
  }

  @Override
  public void clear() {
      super.clear();
      size = 0;
  }
  ...
</code></pre></div>    </div>
  </li>
  <li>size 메소드가 상수시간이 되어 put 메소드도 자동으로 상수시간이 됨</li>
  <li>MyBetterMap에서 clear 메소드는 오히려 선형이 되었지만 자주 사용되지 않는 함수라 감안할 만함</li>
  <li>많은 객체가 동일한 해시 코드를 갖는다면 결국 같은 하위 맵으로 몰리게 되고, k개의 하위 맵으로 인한 성능 향상은 k보다 줄어들게 됨. 따라서 해시 함수는 해시코드를 균등하게 분배해야 함</li>
  <li>해싱을 사용하는 자료구조에서 가변 객체를 키로 사용하는 것은 위험함. 키가 맵에 있는 동안 키 값이 변경되면 해당 값을 찾지 못하게 됨</li>
  <li>equals()가 true인 객체들은 반드시 hashCode() 결과값이 동일해야 해시 기반 컬렉션에서 올바르게 동작함</li>
</ul>

<h3 id="74-treemap">7.4 TreeMap</h3>
<ul>
  <li>HashMap은 널리 사용되지만 상수시간이라도 상수가 상당히 커지거나, 하위 맵에 고르게 키를 분배하는 좋은 해시 함수를 설계하는게 어렵거나, 저장되는 데이터에 순서가 없다는 문제점이 있음</li>
  <li>TreeMap은 해싱을 사용하지 않으며 이진 탐색 트리에 키를 저장하므로 키를 선형 시간으로 순서대로 조회할 수 있음. 또한 핵심 메소드의 실행시간이 log n에 비례하여 쓸만함</li>
  <li>이진 탐색 트리는 아래와 같은 속성이 있음
    <ul>
      <li>노드 왼쪽에 자식이 있다면 왼쪽 하위 트리의 모든 키는 노드에 있는 키보다 작음</li>
      <li>노드 오른쪽에 자식이 있다면 오른쪽 하위 트리의 모든 키는 노드에 있는 키보다 큼</li>
      <li>따라서 검색할 때 트리 전체를 탐색할 필요 없이 트리의 각 수준에서 한개의 자식노드만 찾으면 됨. 이는 트리의 높이인 log n에 비례함
        <ul>
          <li>이진 트리의 높이 별 총 노드 개수는 n = 2^h - 1이므로, log를 씌우면 log n ≈ h</li>
        </ul>
      </li>
      <li>위의 조건들을 만족할 뿐 기본적으로는 균형있는 이진트리를 보장하진 않음</li>
    </ul>
  </li>
  <li>이진 탐색 트리로 Map 인터페이스를 구현하면 아래와 같음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MyTreeMap&lt;K, V&gt; implements Map&lt;K, V&gt; {
      private int size = 0;
      private Node root = null;

      protected class Node {
          public K key;
          public V value;
          public Node left = null;
          public Node right = null;

          public Node(K key, V value) {
              this.key = key;
              this.value = value;
          }
      }

      @Override
      public void clear() {
          size = 0;
          root = null;
      }

      @Override
      public boolean containsKey(Object target) {
          return findNode(target) != null;
      }

      private Node findNode(Object target) {
          if (target == null) {
              throw new IllegalArgumentException();
          }

          // key와 비교하기 위해 Object -&gt; Key 타입으로 형변환
          // Map 인터페이스 규약에 따르면 containsKey의 파라미터 타입은 Object
          @SuppressWarnings("unchecked")
          Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) target;

          Node node = root;
          while (node != null)
          {
              int cmp = k.compareTo(node.key);
              if (cmp &lt; 0)
                  node = node.left;
              else if (cmp &gt; 0)
                  node = node.right;
              else
                  return node;
          }
          return null;
      }

      private boolean equals(Object target, Object obj) {
          if (target == null) {
              return obj == null;
          }
          return target.equals(obj);
      }

      @Override
      public boolean containsValue(Object target) {
          return containsValueHelper(root, target);
      }

      private boolean containsValueHelper(Node node, Object target) {
          if (node == null) {
              return false;
          }
          if (equals(target, node.value)) {
              return true;
          }
          if (containsValueHelper(node.left, target)) {
              return true;
          }
          if (containsValueHelper(node.right, target)) {
              return true;
          }
          return false;
      }

      @Override
      public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {
          throw new UnsupportedOperationException();
      }

      @Override
      public V get(Object key) {
          Node node = findNode(key);
          if (node == null) {
              return null;
          }
          return node.value;
      }

      @Override
      public Set&lt;K&gt; keySet() {
          Set&lt;K&gt; set = new LinkedHashSet&lt;K&gt;();
          addInOrder(root, set);
          return set;
      }

      private void addInOrder(Node node, Set&lt;K&gt; set) {
          if(node == null) return;
          addInOrder(node.left, set);
          set.add(node.key);
          addInOrder(node.right, set);
      }

      @Override
      public V put(K key, V value) {
          if (key == null) {
              throw new NullPointerException();
          }
          if (root == null) {
              root = new Node(key, value);
              size++;
              return null;
          }
          return putHelper(root, key, value);
      }

      private V putHelper(Node node, K key, V value) {
          Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
          int cmp = k.compareTo(node.key);

          //리프 노드를 찾아서 키를 비교하여 크기에 따라 오른쪽/왼쪽 자식 노드로 추가
          if (cmp &lt; 0) {
              if (node.left == null) {
                  node.left = new Node(key, value);
                  size++;
                  return null;
              }
              else {
                  return putHelper(node.left, key, value);
              }
          }
          if (cmp &gt; 0) {
              if (node.right == null) {
                  node.right = new Node(key, value);
                  size++;
                  return null;
              }
              else {
                  return putHelper(node.right, key, value);
              }
          }
          V oldValue = node.value;
          node.value = value;
          return oldValue;
      }

      @Override
      public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
          for (Map.Entry&lt;? extends K, ? extends V&gt; entry: map.entrySet()) {
              put(entry.getKey(), entry.getValue());
          }
      }

      @Override
      public V remove(Object key) {
          if (root == null) throw new UnsupportedOperationException();

          Node deletedNode = new Node(null, null);
          root = removeHelper(root, (Comparable&lt;? super K&gt;) key, deletedNode);
          if (deletedNode.value != null) size--;
            
          return deletedNode.value;
      }

      public Node removeHelper(Node node, Comparable&lt;? super K&gt; key, Node deletedNode) {
          int cmp = key.compareTo(node.key);

          if (cmp &lt; 0) {
              node.left = removeHelper(node.left, key, deletedNode);
          } else if (cmp &gt; 0) {
              node.right = removeHelper(node.right, key, deletedNode);
          } else {
              // 삭제할 노드 찾음
              if(deletedNode != null) deletedNode.value = node.value;

              // (1) 리프 노드
              if (node.left == null &amp;&amp; node.right == null) return null;

              // (2) 자식 하나
              if (node.left == null) return node.right;
              if (node.right == null) return node.left;

              // (3) 자식 둘
              Node successor = findMin(node.right);  // 오른쪽 서브트리에서 가장 작은 값
              node.key = successor.key;
              node.value = successor.value;
              node.right = removeHelper(node.right, (Comparable&lt;? super K&gt;) successor.key, null);
          }
          return node;
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>clear는 root가 null이 될 시 자식 노드들을 수거하므로 선형시간임을 고려해야함</li>
  <li>findNode, put, remove는 key를 사용하기 때문에 트리의 높이에 비례하나 containsValue, keySet은 트리 전체를 검색하므로 n에 비례함</li>
  <li>트리의 모든 노드를 방문하는 방식으로 전위/중위/후위 순회가 있는데 containsValueHelper는 순서 상관없이 value를 확인하므로 전위 순회, addInorder는 오름차순으로 key 값을 정렬해야 하므로 중위 순회를 함</li>
  <li>위 코드에서 put 메소드를 확인해보면 순차적으로 증가하는 값들을 put 할 경우 오른쪽 자식에만 쏠린 불균형 트리가 됨</li>
  <li>불균형 트리를 해결하기 위해서는 Map에 키를 순서대로 넣지 않거나, put을 수정하여 트리가 불균형해질 때 노드를 재배열하는 로직을 추가해야 함(=자가 균형 트리)</li>
  <li>일반적인 자가 균형 트리로는 AVL 트리, 레드 블랙 트리가 있음</li>
  <li>java.util.TreeMap은 내부적으로 레드 블랙 트리로 구현되어 있어 순차적인 데이터가 삽입되어도 균형을 유지함</li>
  <li>remove 메소드는 삭제할 노드가 리프 노드인지, 자식 하나인지, 둘인지에 따라 다르게 동작함. 삭제할 노드의 자식이 둘일 경우 왼쪽 서브트리에서 가장 큰 값 또는 오른쪽 서브트리에서 가장 작은 값을 찾아 대체해야 함. 이는 트리의 균형을 다시 맞추는 작업과 유사한 연산을 거침</li>
</ul>

<h2 id="8-redis">8. Redis</h2>
<ul>
  <li>앞의 7.1에서 두 가지 자료구조를 이용하여 인덱스를 저장했는데, 이러한 자료구조는 실행 중인 자바 프로그램의 메모리에 저장되어 프로그램이 멈추면 모두 사라짐</li>
  <li>데이터를 영속적으로 만들기 위하여 프로그램 종료 전 JSON 포맷으로 파일에 저장하거나 데이터베이스를 활용하는 방법이 있음</li>
  <li>파일에 저장 시 대량의 자료구조를 읽고 쓰면 느려질 수 있고 단일 실행 프로그램 메모리에 다 들어가지 않을 수 있음. 또한 프로그램 비정상 종료 시 변경사항이 소실될 수 있음</li>
  <li>레디스는 자바 자료구조와 유사한 영속적인 자료구조를 제공함. 기본적으로 String 타입의 키와 다양한 데이터 타입 중 하나를 값으로 넣을 수 있는 맵 구조로, 주목할 자료구조는 아래와 같음
    <ul>
      <li>문자열 String</li>
      <li>자바 Set과 유사한 문자열 집합</li>
      <li>자바 List와 유사한 문자열 리스트</li>
      <li>자바 Map 과 유사한 해시
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public static void main(String[] args) throws IOException {

  Jedis jedis = make();

  // String
  jedis.set("mykey", "myvalue");
  String value = jedis.get("mykey");
  System.out.println("Got value: " + value);

  // Set
  jedis.sadd("myset", "element1", "element2", "element3");
  System.out.println("element2 is member: " + jedis.sismember("myset", "element2"));  // Jedis.sismember 메서드는 요소가 ser 에 있는지 검사

  // List
  jedis.rpush("mylist", "element1", "element2", "element3");                  // 리스트의 오른쪽 끝에 요소 추가
  System.out.println("element at index 1: " + jedis.lindex("mylist", 1));     // jedis.lindex는 정수 인덱스를 받아 list의 지정된 요소를 반환

  // Hash
  jedis.hset("myhash", "word1", Integer.toString(2));     // 키와 값은 모두 string이므로 Integer를 저장하려면 hset 메서드를 호출하기 전에 String 타입으로 변환해야 함
  jedis.hincrBy("myhash", "word2", 1);                    // word2 필드의 현재 값(존재하지 않으면 0)을 가져와서 1만큼 증가
  System.out.println("frequency of word1: " + jedis.hget("myhash", "word1"));
  System.out.println("frequency of word2: " + jedis.hget("myhash", "word2"));

  jedis.close();
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>자바 코드에서 Redis와 통신할 수 있게 해주는 클라이언트 라이브러리 Jedis를 만들고 서버에 연결하여 레디스 명령 실행</li>
  <li>Jedis.sismember, jedis.lindex, jedis.hincrBy 모두 상수시간 연산</li>
  <li>jedis.hset에서 첫번째 키는 특정 hash를 식별하고, 두번째 키(=필드)는 hash 안의 값을 식별함</li>
  <li>hash 안의 값의 정수인 경우가 많아 hincrby 같은 특별한 메서드가 제공됨. 이 메서드는 값을 정수로 취급함</li>
</ul>

<h3 id="81-redis로-인덱서-구현">8.1 Redis로 인덱서 구현</h3>
<ul>
  <li>7.1에서 정의한 Index, TermCounter 클래스를 레디스로 이동
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class JedisIndex {

      private Jedis jedis;

      public JedisIndex(Jedis jedis) {
          this.jedis = jedis;
      }

      private String urlSetKey(String term) {
          return "URLSet:" + term;
      }

      private String termCounterKey(String url) {
          return "TermCounter:" + url;
      }

      public void add(String term, TermCounter tc) {
          jedis.sadd(urlSetKey(term), tc.getLabel());
      }

      public boolean isIndexed(String url) {
          String redisKey = termCounterKey(url);
          return jedis.exists(redisKey);
      }

      public Map&lt;String, Integer&gt; getCounts(String term) {
          Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
          Set&lt;String&gt; urls = getURLs(term);
          for (String url : urls) {
              Integer count = getCount(url, term);
              map.put(url, count);
          }
          return map;
      }

      public Set&lt;String&gt; getURLs(String term) {
          Set&lt;String&gt; set = jedis.smembers(urlSetKey(term));
          return set;
      }

      public Integer getCount(String url, String term) {
          String redisKey = termCounterKey(url);
          String count = jedis.hget(redisKey, term);
          return new Integer(count);
      }

      public void indexPage(String url, Elements paragraphs) {
          System.out.println("Indexing " + url);
          // Termcounter 객체를 만들어 단락에 있는 검색어 개수를 셉니다
          TermCounter tc = new TermCounter(url);
          tc.processElements(paragraphs);
          // TermCounter의 내용을 레디스에 푸시합니다
          pushTermCounterToRedis(tc);
      }

      // url 별 term 등장횟수를 담은 TermCounter를 레디스의 Set 형태로 전환
      public List&lt;Object&gt; pushTermCounterToRedis(TermCounter tc) {
          // jedis.multi()는 Jedis 객체의 모든 메서드를 제공하는 Transaction 객체를 반환
          Transaction t = jedis.multi();
          String url = tc.getLabel();
          String hashname = termCounterKey(url); // TermCounter : url
          // 페이지가 이미 인덱싱되어 있다면 기존 해시를 제거합니다
          t.del(hashname);
          // 각 검색어에 대해 TermCounter 에 엔트리와 인덱스의 새 멤버를 추가합니다.
          for (String term: tc.keySet()) {
              Integer count = tc.get(term);
              t.hset(hashname, term, count.toString()); //redis의 hash 자료구조에 추가
              t.sadd(urlSetKey(term), url); //redis의 set 자료구조에 추가 "URLSet: term"
          }
          List&lt;Object&gt; res = t.exec();    // 매번 서버와 통신하면 시간이 더 소요되므로 Transaction 동작을 모아뒀다 한꺼번에 적용
          return res;
      }
        
      private static void loadIndex(JedisIndex index) throws IOException {
          WikiFetcher wf = new WikiFetcher();

          String url = "https://en.wikipedia.org/wiki/Java_(programming_language)";
          Elements paragraphs = wf.readWikipedia(url);
          index.indexPage(url, paragraphs);

          url = "https://en.wikipedia.org/wiki/Programming_language";
          paragraphs = wf.readWikipedia(url);
          index.indexPage(url, paragraphs);
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>레디스 데이터베이스에서 각 객체는 string 형의 유일한 키로만 식별되므로 두 종류 이상의 객체(Index, TermCounter)가 있다면 이 둘을 구분할 수 있는 접두사를 추가해야 함
    <ul>
      <li>Set에 키를 “URLSet : 단어”, 값을 url 주소로 저장 =&gt; 특정 단어에 대한 url들의 Set</li>
      <li>Hash에 첫번째 키를 “TermCounter : url 주소”, 두번째 키를 단어, 값을 단어 등장 횟수로 저장 =&gt; 특정 url 주소 별 각 단어 등장 횟수 Map</li>
      <li>기존 Index 객체에서는 단어 별 TermCounter들의 집합을 인스턴스로 가졌으나 TermCounter는 각 페이지 별 단어들과 단어 등장횟수를 저장하므로 Index 객체에 의존할 필요가 없음</li>
    </ul>
  </li>
  <li>n개의 페이지 인덱싱 후 m개의 고유한 검색어를 검색 할 때 소요되는 시간 (getCounts)
    <ul>
      <li>HashMap을 생성 -&gt; getURL 메소드 호출하여 해당 단어를 포함한 URL 집합을 가져옴 -&gt; 집합에 있는 각 URL에 대해 getCount 메소드 호출하여 HashMap에 엔트리 추가</li>
      <li>getURL 메소드의 jedis.smembers는 Redis의 Set 자료구조에서 모든 요소를 가져오는 메서드로 단어에 해당하는 url들을 모두 순회함</li>
      <li>이후 반복문 안에서 해당 단어가 등장하는 url 개수만큼 getCount를 호출하는데 상수시간 연산이라 전체 복잡도는 최악의 상황에 n이 됨. 하지만 실제로 검색어를 포함한 페이지의 개수는 n보다 작은 경우가 많음</li>
    </ul>
  </li>
  <li>한 페이지를 인덱싱하는데 소요되는 시간 (indexPage)
    <ul>
      <li>페이지의 DOM 트리를 순회하고 모든 TextNode 객체를 찾고 문자열을 검색어로 쪼갬 =&gt; 소요 시간은 페이지의 단어 개수에 비례함</li>
    </ul>
  </li>
</ul>]]></content><author><name>Toyo</name></author><category term="CS" /><category term="java" /><category term="자료구조" /><category term="알고리즘" /><summary type="html"><![CDATA[1. 인터페이스 프로그래밍 java.util.List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List 인터페이스에 정의된 메소드는 ArrayList와 LinkedList 또는 List 인터페이스를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨 라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨]]></summary></entry><entry><title type="html">자바 기초 정리 (자바의 신 vol.1)</title><link href="/cs/2025/07/22/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-(%EC%9E%90%EB%B0%94%EC%9D%98-%EC%8B%A0-vol.1).html" rel="alternate" type="text/html" title="자바 기초 정리 (자바의 신 vol.1)" /><published>2025-07-22T00:00:00+00:00</published><updated>2025-07-22T00:00:00+00:00</updated><id>/cs/2025/07/22/%EC%9E%90%EB%B0%94%20%EA%B8%B0%EC%B4%88%20%EC%A0%95%EB%A6%AC%20(%EC%9E%90%EB%B0%94%EC%9D%98%20%EC%8B%A0%20vol.1)</id><content type="html" xml:base="/cs/2025/07/22/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-(%EC%9E%90%EB%B0%94%EC%9D%98-%EC%8B%A0-vol.1).html"><![CDATA[<h2 id="1-자바-변수와-자료형">1. 자바 변수와 자료형</h2>

<h3 id="11-변수의-종류">1.1 변수의 종류</h3>

<ul>
  <li>자바의 변수는 생명주기에 따라 4가지 종류로 나뉜다.
    <ul>
      <li>지역 변수
        <ul>
          <li>중괄호 내에서 선언된 변수</li>
          <li>생명주기도 해당 중괄호 내에서만 유효함</li>
          <li>자바에선 재선언이 허용되지 않으므로 해당 중괄호 내에서 동일한 이름을 갖는 지역 변수를 선언하면 컴파일 에러가 발생함</li>
        </ul>
      </li>
      <li>매개 변수
        <ul>
          <li>메소드에 넘겨주는 변수</li>
          <li>메소드가 호출될 대 생명이 시작되어 메소드가 끝나면 소멸</li>
        </ul>
      </li>
      <li>인스턴스 변수
        <ul>
          <li>메소드 밖, 클래스 안에 선언된 변수</li>
          <li>객체가 생성될 때 생명이 시작되며, 그 객체를 참조하고 있는 다른 객체가 없으면 소멸됨</li>
        </ul>
      </li>
      <li>클래스 변수
        <ul>
          <li>static 예약어가 붙은 인스턴스 변수</li>
          <li>클래스가 처음 로드될 때 생명이 시작되고, 자바 프로그램이 끝날 때 소멸됨</li>
          <li>클래스는 객체를 처음 생성하거나, 해당 클래스 변수에 접근하거나, 동적으로 로드하거나, 해당 클래스의 자식 클래스가 로드될 때 같이 로드됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="12-자료형의-종류">1.2 자료형의 종류</h3>

<ul>
  <li>기본 자료형
    <ul>
      <li>바로 값을 넣어 초기화가 가능</li>
      <li>자료형의 첫 비트는 부호를 표시하는데 사용되며 음수의 범위가 양수의 범위보다 하나 더 큼. 부호비트가 1이고 나머지 비트가 0일 경우를 해당 타입의 최소값으로 사용하기 때문 (-2^n ~ -2^n-1)</li>
      <li>따라서 어떤 자료형에 최소값을 넣고 1을 빼면 최대값이, 최대값을 넣고 1을 더하면 최소값이 됨 (최소값이 10000000 이면 최대값은 01111111이기 때문)</li>
      <li>소수형 타입은 부동 소수점 연산을 사용하므로 값이 범위를 넘어서면 정확성이 보장되지 않음 -&gt; 대신 java.match.BigDemical이라는 클래스를 사용</li>
      <li>자바의 모든 자료형은 값을 지정하지 않으면 기본값 사용. 기본 자료형은 각자의 기본값을 가지고 참조형은 null. 그러나 지역 변수일 경우는 기본값이 자동 적용되지 않음</li>
      <li>자바는 계산 시 두 피연산자가 정수형일 때 결과 값도 정수형으로 취급하므로 결과가 소수값이어도 소수형으로 결과가 나오진 않음. 소수점 아래까지의 결과를 원하면 두 피연산자를 소수형으로 할 필요가 있음</li>
      <li>종류
        <ul>
          <li>정수형
            <ul>
              <li>byte  (-2^7 ~ 2^7-1)</li>
              <li>short (-2^15 ~ 2^15-1)</li>
              <li>int   (-2^31 ~ 2^31-1)</li>
              <li>long  (-2^63 ~ 2^63-1)
                <ul>
                  <li>long 자료형 초기화 시 L을 붙이지 않고 int 범위를 초과하는 값을 넣으면 에러 발생. 자바에서 기본적으로 숫자를 명시하면 int라고 생각하기 때문에 선언 시 L을 붙여주지 않으면 int로 인식됨</li>
                </ul>
              </li>
              <li>char
                <ul>
                  <li>정수형 중 유일하게 부호가 없음</li>
                  <li>내부적으로 아스키/유니코드에 대응하는 숫자값을 저장하는 정수형 타입이지만 데이터 처리 방식에는 차이가 있음</li>
                  <li>‘a’와 같은 문자를 저장할 수 있으므로 char 같은 정수형인 다른 자료형들도 가능한 범위일 경우 해당 문자 저장 가능</li>
                  <li>‘a’같은 문자와 \u + 4자리의 16진수 값을 넣는 것이 대표적. 해당 값의 유니코드 번호를 지정해도 초기화 가능</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>소수형
            <ul>
              <li>float</li>
              <li>double</li>
            </ul>
          </li>
          <li>boolean</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>참조 자료형
    <ul>
      <li>new 키워드를 사용해서 초기화 가능</li>
      <li>String 만은 예외적으로 new을 사용하지 않고도 초기화 가능</li>
    </ul>
  </li>
</ul>

<h2 id="2-연산자와-형변환">2. 연산자와 형변환</h2>

<h3 id="21-연산자">2.1 연산자</h3>

<ul>
  <li>연산자는 단항연산자   &gt;   *, /, %   &gt;   +, -   순으로 우선순위가 높다</li>
  <li>단항연산자 중 ~(틸드)는 2진수로 되어 있는 비트 값을 전부 거꾸로 바꾸는 데 사용</li>
  <li>등가 비교 연산자 (==, !=)는 같은 종류(정수형과 소수형도 같은 종류)끼리 비교가 가능하며 자바의 모든 기본 자료형과 참조 자료형에서 사용 가능. 참조 자료형은 주소값을 비교함</li>
  <li>자바의 연산자들은 타입별로 사용 가능한 연산자가 정해져 있음. douable, float는 소수형이므로 비트 연산이 불가능함</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;</code>, <code class="language-plaintext highlighter-rouge">|</code>, <code class="language-plaintext highlighter-rouge">^</code>(값이 서로 다르면 true, 같으면 false) 연산자는 숫자에 사용하면 비트 연산을, boolean 타입 사이에 사용하면 논리 연산을 수행</li>
  <li>참조 자료형은 + 이항 연산자만 사용 가능. 사용 시 해당 클래스에 있는 toString() 메소드 결과끼리 더함</li>
</ul>

<h3 id="22-형변환">2.2 형변환</h3>

<ul>
  <li>기본 자료형 중 boolean 타입은 숫자로 변환할 수 없기 때문에 형변환 불가능</li>
  <li>더 범위가 넓은 타입으로 변환할 때는 문제가 없으나, 더 범위가 작은 타입으로 변환할 때는 소괄호 안에 타입을 명시해주어야 하며 예상치 못한 값이 나올수도 있음</li>
</ul>

<h2 id="3-조건문과-반복문">3. 조건문과 반복문</h2>

<h3 id="31-조건문">3.1 조건문</h3>
<ul>
  <li>switch 문
    <ul>
      <li>한번 case 조건을 만족시켜 줬다면 그다음 break가 올때까지 모든 case 통과하여 실행문 실행</li>
      <li>case문으로 이루어진 switch 문의 끝에는 default 문이 올 수 있으며 앞에 있는 조건에 맞지 않는 경우 실행됨. case문에서 한번이라도 걸렸으면 실행안됨</li>
      <li>switch() 괄호 안의 비교 대상 변수는 정수형만 사용 가능 했으나 JDK7부터 String도 사용 가능해짐</li>
    </ul>
  </li>
</ul>

<h3 id="32-반복문">3.2 반복문</h3>
<ul>
  <li>do-while 문 : 한 번은 꼭 실행시키고 싶을 때 사용. 마지막 while의 소괄호 뒤에 반드시 세미콜론을 입력해야 함</li>
  <li>label : 반복문에 이름을 부여하여(라벨명 : 반복문 형태로 정의) 특정 시점에 해당 반복문을 빠져나오거나(break 라벨명) 위로 돌아가도록 (continue 라벨명)할 수 있음</li>
</ul>

<h2 id="4-배열">4. 배열</h2>

<h3 id="41-배열의-선언과-기본값">4.1 배열의 선언과 기본값</h3>
<ul>
  <li>배열 선언 시 대괄호는 타입과 변수 사이에 또는 변수명 뒤에 빈 상태로 위치해야함</li>
  <li>참조 자료형이므로 new 키워드를 사용해 생성하거나, 중괄호를 사용해서 한번에 선언 및 초기화</li>
  <li>지역변수는 원래 기본값이 없으나, 배열에서는 지역 변수라고 해도 배열 크기만 정해주면 초기화 안해도 각 배열의 기본값이 할당됨</li>
  <li>기본 자료형 배열의 기본값은 각 자료형의 기본값과 동일
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  byteArray[0]=0
  shortArray[0]=0
  intArray[0]=0
  longArray[0]=0
  floatArray[0]=0.0
  doubleArray[0]=0.0
  charArray[0]=[ ]    //기본값은 ₩u0000으로 화면에 출력될 때에는 한 칸의 공백으로 보임
  booleanArray[0]=false
</code></pre></div>    </div>
  </li>
  <li>모든 참조자료형은 초기화 하지 않으면 null값을 기본적으로 가짐</li>
  <li>참고 : 초기화한 객체를 출력하면, 객체가 기본으로 가지는 toString() 메소드가 해당 객체의 클래스이름@메모리주소기반으로 생성된 16진수 해시코드를 반환하는 걸 확인할 수 있음
    <ul>
      <li>배열의 경우 [L클래스이름;@해당 배열의 고유번호. L은 해당 배열이 배열이라는 것을, L은 참조 자료형임을 의미</li>
      <li>boolean: Z, byte : b, char : C, double : D, float : F, int : I, long : J, short : S</li>
    </ul>
  </li>
</ul>

<h3 id="42-2차원-배열">4.2 2차원 배열</h3>
<ul>
  <li>아래와 같이 선언 및 초기화
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int [] twoDim[]; 
  int twoDim[][];

  twoDim = new int[2][3];
</code></pre></div>    </div>
  </li>
  <li>크기를 지정할 경우에는 반드시 한번에 설정하던지 1차원만 설정해야 함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  twoDim = new int[2][3];
  twoDim = new int[2][];
</code></pre></div>    </div>
  </li>
  <li>2차원은 1차원 크기 설정 뒤에도 설정가능. 2차원 방 크기는 서로 다를 수 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  twoDim = new int[2][];
  twoDim[0] = new int[3];
  twoDim[1] = new int[2];
</code></pre></div>    </div>
  </li>
  <li>
    <p>중괄호를 사용해서 한번에 선언 및 초기화 가능.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int [][]twoDim = {{1, 2, 3}, {4, 5, 6}};
</code></pre></div>    </div>
  </li>
  <li>2차원 배열에서 .length로 배열 크기를 확인할 때 1차원, 2차원 배열에 각각 .length를 붙여서 알아내야 하며, twoDim[0][0]는 배열 객체가 아닌 값이 들어있는 공간을 나타내기 때문에 실행 시 오류 발생
    <ul>
      <li>점(.)은 참조 자료형에서만 찍을 수 있으며 기본 자료형에서는 사용 불가
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  for(int i=0; i&lt;twoDim.length; i++){
  for(int j=0; j &lt;twoDim[i].length; j++){
      ...
  }
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>다만 위와 같이 .length를 사용하여 for 루프가 수행될 때마다 길이를 얻어오는 건 성능상 좋지 않으므로 아래와 같이 사용
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int iLength = twoDim.length;
  for(int i = 0; i &lt; iLength; i++){
      int jLength = twoDim[i].length;
      for(int j = 0; j &lt; jLength; j++){
          ...
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="43-배열을-위한-for-루프">4.3 배열을 위한 for 루프</h3>
<ul>
  <li>
    <p>자바에서 제공되는 Collection이라는 자료구조를 처리할 때 for 루프를 보다 쉽게 사용 가능. JDK5부터 지원됨</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  for(타입이름 임시 변수명 : 반복대상객체){

  }

  //사용 예시
  int [][]twoDim= {{1, 2, 3}, {4, 5, 6}};
  for(int[] dimArray : twoDim){
      for(int data : dimArray){
          System.out.println(data);
      }
  }
</code></pre></div>    </div>
  </li>
  <li>
    <p>반복대상객체로는 Collection의 일부 클래스 사용 가능. 단, 이 루프 사용시 배열의 현재 인덱스는 따로 계산해야 함</p>
  </li>
</ul>

<h3 id="44-main-메소드의-배열-인자">4.4 main 메소드의 배열 인자</h3>
<ul>
  <li>main 메소드의 배열 인자 String ars[]에 아래와 같이 값을 전달할 수 있음 ([“a”, “b”, “c”, “d”] 배열 전달)
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class ArrayMain {
      public static void main(String args[]){
          ...
      }
  }
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  $ javac ArrayMain.java
  $ java ArrayMain a b c d
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="5-참조-자료형">5. 참조 자료형</h2>

<h3 id="51-this-예약어">5.1 this 예약어</h3>
<ul>
  <li>‘이 객체’를 의미. 생성자와 메소드 안에서 사용 가능.</li>
  <li>객체의 변수와 매개 변수의 이름이 동일할 때 서로 구분하기 위해서 사용</li>
</ul>

<h3 id="52-메소드-overloading">5.2 메소드 overloading</h3>
<ul>
  <li>자바에서는 타입이 다르면 다른 메소드로, 타입이 같고 변수 이름이 같으면 같은 메소드로 인식됨</li>
  <li>메소드의 이름을 같게 하고, 매개 변수만을 다르게 하는것을 overloading이라고 함. 만약 이름, 매개변수가 같은데 리턴 타입이 다르면 컴파일러가 메소드 호출 시 어느 쪽을 호출해야 할지 알 수 없게 되기 때문에 컴파일 오류가 발생</li>
  <li>리턴 타입은 overloading 기준은 아니므로 메소드명만 동일하고 매개변수, 리턴 타입이 달라도 overloading에 해당함</li>
  <li>같은 역할을 하는 메소드는 (매개변수가 달라지더라도) 같은 메소드 이름을 가져야 한다는 모토로 사용하는 것</li>
</ul>

<h3 id="53-static-메소드">5.3 static 메소드</h3>
<ul>
  <li>객체를 생성하지 않아도 호출 가능한 메소드. 단, 해당 메소드 안에서는 클래스(static) 변수만 사용 가능
    <ul>
      <li>단지 static 메소드에서 사용하기 위해 변수를 static으로 선언하는것은 지양해야 함. 인스턴스 변수에 static을 붙이면 해당 클래스의 모든 인스턴스 객체에서 하나의 값을 바라보게 됨</li>
    </ul>
  </li>
</ul>

<h3 id="54-static-블록">5.4 static 블록</h3>
<ul>
  <li>해당 클래스의 인스턴스 객체를 여러개 생성해야하지만, 한번만 호출되어야 하는 코드가 있을 경우 사용</li>
  <li>선언 위치 상관없이 무조건 생성자보다 먼저 실행되며 메소드가 아닌 클래스 내에 선언되어야 함</li>
  <li>static 메소드와 마찬가지로 static 블록 안에서는 static한 것들만 호출 가능</li>
  <li>생성자가 불리지 않아도 해당 클래스에 대한 참조가 발생하자마자 호출되므로 static 인스턴스 변수의 기본값을 덮어 씌움
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class StaticBlock {
      static int data = 1;
      public StaticBlock(){
          ...
      }

      static {
          data = 3;
      }

      static {
          data = 5;
      }

      public static int getData(){
          return data;
      }
  }

  pulic void ddd() {
      // StaticBlock 클래스에 대한 참조 발생
      // data=5 출력됨
      System.out.println("data=" + StaticBlock.getData()); 
      StaticBlock block1 = new StaticBlock();
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="55-pass-by-value-pass-by-reference">5.5 Pass by Value, Pass by Reference</h3>
<ul>
  <li>모든 기본 자료형은 Pass by Value, 참조 자료형은 값이 아닌 참조가 전달되는 Pass by Reference</li>
  <li>String b = “z”와 String b = new String(“z”)는 동일하게 new를 사용하여 객체를 생성한 것과 같기 때문에, 호출하는 함수에 인자로 String 변수를 전달해도 참조가 아닌 객체가 새로 생성(복사)되어 넘어간 것이 됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ...
  String a = "a";
  passByValue(b);
  public void passByValue(String b){
      b = "b";    // 여전히 a 변수의 값은 "a"로 유지됨
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="56-매개변수를-임의의-개수만큼-전달하기">5.6 매개변수를 임의의 개수만큼 전달하기</h3>
<ul>
  <li>함수로 넘길 매개 변수의 수를 정하기 애매한 경우 아래와 같이 사용할 수 있으나 넘길 숫자들을 직접 배열로 만든 후 넘겨줘야 한다는 단점이 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ...
 varargs.calculateNumbersWithArray(new int[]{1, 2, 3, 4, 5});
 public void calculateNumbersWithArray(int []numbers){
     ...
 }
</code></pre></div>    </div>
  </li>
  <li>아래와 같이 “타입…변수명”으로 선언해도 마찬가지로 numbers는 배열로 인식되며, 함수 호출 시 필요한만큼 매개변수를 바로 넘길 수 있어 편리함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ...
  varargs.calculateNumbers(1, 2, 3, 4, 5);
  public void calculateNumbers(int...numbers){
      ...
  }
</code></pre></div>    </div>
    <ul>
      <li>해당 방식은 하나의 메소드에서 한 번만 사용 가능하고, 여러 매개 변수가 있다면 가장 마지막에 선언해야 함
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void arbitrary(String message, int...numbers){   //해당 매개변수 마지막으로
      ...
  }
</code></pre></div>        </div>
      </li>
      <li>System.out.printf() 메소드는 아래와 같이 정의되어 가장 앞에 출력하는 포맷을 선언하고, 뒤에는 Object라는 타입의 args를 임의의 개수만큼 받을 수 있음
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  printf(String format, Object...args)   //format 문자열에 정의한 포맷 수만큼 args로 전달하여 출력할 수 있음
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="6-패키지">6. 패키지</h2>

<h3 id="61-패키지-선언-시-규칙">6.1 패키지 선언 시 규칙</h3>
<ul>
  <li>소스의 가장 첫 줄에 있어야 함</li>
  <li>패키지 선언은 소스 하나에 하나만 있어야 함</li>
  <li>package 선언과 파일 시스템의 디렉토리 구조가 일치해야 컴파일 또는 실행 시 해당 소스 또는 클래스 파일을 찾을 수 있음</li>
  <li>컴파일 시 javac 명령에 package 구조에 맞는 소스 파일 경로를 줘야 함. 따라서 패키지 루트 디렉토리(package com.example로 정의한 경우 com이 패키지 루트 디렉토리)의 디렉토리나 그 상위 디렉토리에선 컴파일 가능하지만 하위 디렉토리에선 안됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # Main.java에 package com.example로 선언 시

  cd src
  javac com/example/Main.java
  # 현재 디렉토리(src)가 패키지 루트
  # 클래스 파일도 com/example 밑에 Main.class로 생성됨

  # 또는
  javac -d out src/com/example/Main.java
  # 패키지 루트 디렉토리의 상위 디렉토리에서 컴파일하지만 package 구조에 맞는 소스 파일 경로를 포함함
  # -d out: out이 클래스파일 기준 패키지 루트. 사용 시 클래스 파일 기준 패키지 루트와 소스 파일 기준 패키지 루트가 달라짐. 소스 파일 경로와 클래스 파일 경로를 다르게 하고 싶을 때 사용
  # out 폴더 밑에 package 선언과 동일하게 디렉토리 구조 생성됨(com/example 폴더 생성)
</code></pre></div>    </div>
  </li>
  <li>클래스 파일 실행 시에는 -cp 옵션으로 클래스 파일 기준 패키지 루트 패키지 디렉토리 지정 가능
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  java -cp out com.example.Main
</code></pre></div>    </div>
  </li>
  <li>패키지를 사용하는 클래스(별도의 package 선언을 한 클래스)를 실행할 때는 항상 패키지명.클래스명 전체를 포함해서 실행해야 함</li>
  <li>패키지 이름은 모두 소문자로 지정해야 하며, 자바의 예약어를 포함할 수 없음</li>
</ul>

<h3 id="62-패키지-import">6.2 패키지 import</h3>
<ul>
  <li>자바에서는 같은 패키지에 있는 클래스들과 java.lang 패키지에 있는 클래스들만 찾을 수 있음. 그외에는 import 패키지명.클래스명을 정의해줘야 함</li>
  <li>import로 불러온 클래스를 따로 컴파일하지 않았어도 해당 클래스를 사용하는 소스 파일을 컴파일하면 (그리고 import한 패키지명과 실제 해당 클래스의 소스 파일이 있는 디렉토리 경로가 일치하면) 해당 클래스를 먼저 컴파일한 후 호출하는 클래스를 컴파일 함</li>
  <li>특정 패키지의 하위 패키지들을 모두 import하고자 할 경우 import c.javapackage.sub.*;사용
    <ul>
      <li>단, 해당 패키지의 바로 하위 패키지만 import 하므로 import c.*를 한다고 해서 c.javapackage의 하위 패키지들까지 import 되진 않음</li>
      <li>폴더 구조상 상위 패키지에 있는 클래스와 하위 패키지에 있는 클래스의 상관관계는 자바 언어 상에는 없으며, 단지 논리적으로 어떤 패키지 하위에 있는지 여부를 따지기 위함임</li>
    </ul>
  </li>
  <li>클래스안에 static 메소드나 변수가 있을 경우 import static을 사용하여 해당 메소드나 변수를 직접 import 할 수 있음
    <ul>
      <li>import static을 사용안 할 경우 해당 클래스를 import하여 클래스명.static_메소드/변수 형태로 사용해야 함</li>
      <li>import 클래스명.*로 해당 static 메소드/변수 import할 때도 마찬가지로 import static 사용</li>
      <li>static 메소드/변수가 직접 import되므로 해당 메소드/변수를 import 한 클래스에 이름이 중복되는 메소드/변수가 있을 수 있는데, 이 경우 자신의 클래스에 있는 변수/메소드가 더 우선됨</li>
    </ul>
  </li>
</ul>

<h3 id="63-자바의-접근-제어자">6.3 자바의 접근 제어자</h3>
<ul>
  <li>public : 누구나 접근 가능</li>
  <li>protected : 같은 패키지 내에 있거나 상속받은 경우에만 접근 가능</li>
  <li>package-private : 아무런 접근 제어자를 적어주지 않은 경우. 같은 패키지 내에 있을 때만 접근 가능</li>
  <li>private : 해당 클래스 내에서만 접근 가능</li>
  <li>구조상으론 public &gt; protected &gt; package-private &gt; private</li>
</ul>

<table>
  <thead>
    <tr>
      <th>지시자</th>
      <th>해당 클래스 안에서</th>
      <th>같은 패키지에서</th>
      <th>상속받은 클래스에서</th>
      <th>import한 클래스 또는 그외에서</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>public</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>protected</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
      <td>X</td>
    </tr>
    <tr>
      <td>package-private</td>
      <td>O</td>
      <td>O</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td>private</td>
      <td>O</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>유의점 : public으로 선언된 클래스가 소스 내에 있다면 그 소스 파일의 이름은 public과 동일해야 함
    <ul>
      <li>소스 파일명과 일치하는 클래스가 있어야 하는 건 아님</li>
    </ul>
  </li>
</ul>

<h2 id="7-상속">7. 상속</h2>

<h3 id="71-상속-예약어와-동작">7.1 상속 예약어와 동작</h3>
<ul>
  <li>extends는 클래스를 상속 받기 위해 사용하는 자바 예약어. 자바에선 하나의 클래스만 상속 가능</li>
  <li>자식 클래스에서는 부모 클래스에 있는 public, protected로 선언된 모든 인스턴스 및 클래스 변수와 메소드 사용 가능. package-private는 패키지가 같을 경우 사용 가능</li>
  <li>상속이란 분류. A는 B의 한 종류이다 (=is kind of)</li>
  <li>자식 클래스 생성자에서 super(매개변수)를 명시적으로 지정하지 않으면 컴파일 시 자동으로 부모클래스의 기본생성자를 호출하는 super()가 추가됨. 따라서 부모 클래스에 기본 생성자가 없으면 에러 발생할 수 있음</li>
  <li>super()는 반드시 자식 클래스의 생성자에서 가장 첫줄에 선언되어야 함</li>
</ul>

<h3 id="72-메소드-오버라이딩">7.2 메소드 오버라이딩</h3>
<ul>
  <li>부모 클래스 메소드와 동일한 시그니처(메소드 이름, 매개변수 타입 및 개수)를 갖는 자식 클래스의 메소드가 존재할 때 성립됨 (다르면 오버로딩)</li>
  <li>부모 클래스의 메소드와 이름이 같으면서 리턴 타입이 다른 메소드는 자식클래스에서 정의할 수 없음
    <ul>
      <li>변수 이름은 같을 수 있으나 권장하지 않음</li>
    </ul>
  </li>
  <li>접근제어자는 부모 클래스 메소드와 다르게 할 수 있으나, 확대되는 것만 가능하고 축소되는 것은 안됨 (public &gt; protected &gt; package-private &gt; private)</li>
</ul>

<h3 id="73-참조-자료형의-형변환">7.3 참조 자료형의 형변환</h3>
<ul>
  <li>기본 자료형에서 데이터 범위가 더 확장되는 경우(int -&gt; long)와 마찬가지로 참조 자료형에서도 자식 클래스 타입을 부모 클래스 타입으로 형 변환시 명시적인 형 변환이 필요 없음 (데이터의 범위가 넓어지는 거지 사용 가능한 변수나 메소드가 많아진다는 걸 의미하진 않음)</li>
  <li>부모 타입 객체를 자식 타입으로 형 변환 시에는 명시적인 타입 지정 필요. 이때, 변환하더라도 실제 들어있는 객체가 자식 타입이 아니면 사용 불가능</li>
  <li>개발 편의상 부모 타입 배열 등에 여러가지 자식 타입의 값을 담아야 하는 경우가 있음</li>
  <li>instanceof 예약어를 사용하면 객체의 실제 타입을 확인할 수 있는데, 부모 타입으로 체크해도 true가 반환됨</li>
  <li>다형성 : 부모 타입 변수에 자식 타입 객체가 들어있어도 실제 호출되는 것은 원래 객체(자식 타입 객체)에 있는 메소드임</li>
</ul>

<h2 id="8-자바-api">8. 자바 API</h2>

<h3 id="81-api">8.1 API</h3>
<ul>
  <li>JDK에는 매우 많은 클래스와 메소드를이 포함되어 있으며, JDK에 포함된 클래스들 외에도 엄청나게 많은 클래스들이 존재함. 이러한 클래스들을 설명하는 API 문서는 HTML로 구성됨</li>
  <li>API 문서는 클래스 및 메소드에 API에 명시되도록 하기 위한 주석을 달고 jdk/bin 디렉터리에 있는 javadoc 명령어만 실행하면 자동으로 생성됨</li>
</ul>

<h3 id="82-api-문서-상세-정보화면">8.2 API 문서 상세 정보화면</h3>
<ul>
  <li>패키지와 클래스 / 인터페이스 이름</li>
  <li>클래스 상속 관계 다이어그램
    <ul>
      <li>해당 클래스가 어떤 클래스들의 상속을 받았는지 간단한 계단식으로 표시</li>
    </ul>
  </li>
  <li>직속 자식 클래스
    <ul>
      <li>현재 보고 있는 클래스를 확장한 클래스들의 목록</li>
    </ul>
  </li>
  <li>알려진 모든 하위 인터페이스 목록
    <ul>
      <li>인터페이스에 대한 문서일 경우 해당 인터페이스 상속받은 인터페이스 목록</li>
    </ul>
  </li>
  <li>알려진 모든 구현한 클래스 목록
    <ul>
      <li>해당 인터페이스를 구현한 클래스들의 목록</li>
    </ul>
  </li>
  <li>구현한 모든 인터페이스 목록
    <ul>
      <li>클래스에서 구현한 모든 인터페이스 목록</li>
    </ul>
  </li>
  <li>클래스 / 인터페이스의 선언 상태
    <ul>
      <li>클래스가 어떤 접근 제어자를 사용했는지, final 클래스인지 등을 확인</li>
    </ul>
  </li>
  <li>클래스 / 인터페이스의 설명
    <ul>
      <li>클래스의 용도, 사용법, 사용 예시 등</li>
      <li>Since : 해당 클래스가 JDK 몇 버전부터 추가되었는지 명시. 클래스만이 아닌 클래스에 선언된 상수 필드나 메소드에도 Since 표시되어 있는 경우가 있음</li>
      <li>See also : 해당 클래스와 관련되어 있는 모든 클래스나 인터페이스, 메소드 등의 링크 제공</li>
    </ul>
  </li>
  <li>내부 클래스 종합
    <ul>
      <li>클래스 안에 내부 클래스가 public하게 선언된 경우 그에 대한 내용 제공</li>
    </ul>
  </li>
  <li>상수 필드 종합
    <ul>
      <li>public static으로 선언한 상수 필드</li>
    </ul>
  </li>
  <li>생성자 종합</li>
  <li>메소드 종합
    <ul>
      <li>클래스에 선언되어 있는 모든 public 및 protected 메소드에 대한 종합 정보</li>
      <li>각 메소드의 리턴 타입, 매개 변수, static 여부, 접근제어자</li>
      <li>javadoc 설명에 따르면 API 문서 생성 시 private도 보이도록 할 수 있음</li>
    </ul>
  </li>
  <li>부모 클래스로부터 상속받은 메소드 들</li>
  <li>상수 필드 상세 설명
    <ul>
      <li>선언된 상수 필드가 어떤 내용을 제공하는지에 대한 상세설명</li>
      <li>Since, See Also가 제공되기도 함</li>
    </ul>
  </li>
  <li>생성자 상세 설명
    <ul>
      <li>해당 생성자를 어떻게 사용하고, 매개 변수, 리턴 값 정보와 이 생성자에서 던지는 예외는 언제 발생하는지 등</li>
      <li>Since, See Also가 제공되기도 함</li>
    </ul>
  </li>
  <li>메소드 상세 설명
    <ul>
      <li>Since, See Also가 제공되기도 함</li>
    </ul>
  </li>
</ul>

<h3 id="83-api-문서-header--footer에-있는-링크">8.3 API 문서 Header / Footer에 있는 링크</h3>
<ul>
  <li>OVERVIEW
    <ul>
      <li>전체 패키지에 대한 설명 화면. Java SE 모듈과 JDK 모듈과 그 외 모듈로 분하여 정리됨</li>
    </ul>
  </li>
  <li>MODULE
    <ul>
      <li>패키지 묶음 설명화면. Java SE 모듈과 JDK 모듈과 그 외 모듈 등</li>
    </ul>
  </li>
  <li>PACKAGE
    <ul>
      <li>현재 보고 있는 클래스가 속한 패키지의 모든 인터페이스, 클래스, 예외 등 간단한 설명</li>
    </ul>
  </li>
  <li>CLASS
    <ul>
      <li>USE 페이지에서 클래스 상세 설명으로 넘어가는 링크 클릭하여 이동</li>
    </ul>
  </li>
  <li>USE
    <ul>
      <li>현재 보고 있는 패키지, 클래스, 인터페이스 등을 사용(매개변수나 멤버 변수 및 기타 등등)하는 모든 목록 나열</li>
      <li>처음 보는 클래스가 어디 사용되는지 확인하기 좋음</li>
    </ul>
  </li>
  <li>TREE
    <ul>
      <li>클래스가 속한 패키지에 있는 모든 클래스들의 상속 관계를 Tree 형태로 제공</li>
    </ul>
  </li>
  <li>DEPRECATED
    <ul>
      <li>JDK에 포함된 클래스/메소드 중 deprecated 클래스나 메소드 목록</li>
    </ul>
  </li>
  <li>INDEX
    <ul>
      <li>A부터 Z까지의 알파벳 클릭하여 각 알파벳에 해당하는 클래스, 인터페이스, 메소드, static 변수 등의 색인을 오름차순으로 제공</li>
    </ul>
  </li>
  <li>HELP
    <ul>
      <li>API 문서에 대한 간단 설명</li>
    </ul>
  </li>
</ul>

<h2 id="9-javalangobject">9. java.lang.Object</h2>

<h3 id="91-object-클래스의-메소드">9.1 Object 클래스의 메소드</h3>
<ul>
  <li>자바에서는 기본적으로 아무런 상속을 받지 않을 경우 java.lang.Object 클래스를 확장함. 따라서 Object 클래스의 메소드는 모든 클래스에서 사용가능</li>
  <li>주요 메소드
    <ul>
      <li>toString()
        <ul>
          <li>객체가 System.out.println() 메소드에 매개 변수로 들어가거나 객체에 대하여 더하기 연산 할때 자동 호출됨</li>
          <li>String을 제외한 참조 자료형에 더하기 연산을 수행하면 자동으로 toString() 메소드가 호출되어 그 리턴 값이 더해지게 됨</li>
        </ul>
      </li>
      <li>equals()
        <ul>
          <li>== 연산자는 참조 자료형의 경우 단순 주소값을 비교하므로 equals() 메소드를 오버라이딩 하여 사용. 오버라이딩 하지 않으면 equals() 메소드에서는 hashCode() 메소드 리턴 값인 주소값으로 비교함</li>
          <li>만약 어떤 두 개의 객체가 서로 동일하다면 hashCode() 값 역시 무조건 동일해야 하므로 equals() 메소드를 오버라이딩 시 hashCode()도 같이 해야함</li>
        </ul>
      </li>
      <li>hashcode()
        <ul>
          <li>기본적으로 객체의 메모리 주소를 16진수로 반환</li>
          <li>자바 API 문서에는 equals(), hashcode() 오버라이딩 시 지켜야 할 규칙을 명시하고 있는데, 이러한 제약들 때문에 해당 메소드들을 직접 작성하는건 권장하지 않으며 개발 툴에서 자동 생성해주는 기능을 사용하는 것이 좋음</li>
        </ul>
      </li>
      <li>wait(), notify(), notifyAll()
        <ul>
          <li>스레드 처리 시 사용</li>
        </ul>
      </li>
      <li>그 밖에 객체의 복사본을 반환하는 clone(), 더 이상 쓸모없어진 객체를 정리하기 위해 GC가 호출하는 finalize(), 객체가 어떤 클래스의 인스턴스인지에 대한 메타데이터 객체를 반환하는 getClass() 등</li>
    </ul>
  </li>
</ul>

<h2 id="10-인터페이스와-추상클래스-enum">10. 인터페이스와 추상클래스, enum</h2>

<h3 id="101-인터페이스">10.1 인터페이스</h3>
<ul>
  <li>개발 절차의 설계 단계에서 인터페이스를 만들어두면 개발 단계에서 메소드의 이름, 매개변수에 대해 일일이 고민하지 않을 수 있음. 실제 코드는 만들지 않더라도 어떤 메소드들이 있어야 하는지 정의할 때 사용</li>
  <li>implements 라는 예약어 사용. 끝에 s가 붙는 것은 클래스 자체가 3인칭 단수이기 때문</li>
  <li>implements 뒤에는 여러 인터페이스가 올 수 있음</li>
  <li>abstract 클래스가 아닌 인터페이스를 구현하는 클래스에서는 반드시 인터페이스에 정의된 메소드들을 구현해야 함</li>
</ul>

<h3 id="102-추상클래스">10.2 추상클래스</h3>
<ul>
  <li>abstract 클래스는 abstract 클래스를 구현해 놓은 클래스를 통해 초기화 및 실행 가능</li>
  <li>abstract로 선언한 메소드는 반드시 abstract 클래스 안에 있어야 함</li>
  <li>인터페이스와 달리 구현되어 있는 메소드가 있을 수 있으며 static이나 final 메소드도 가능</li>
  <li>abstract 클래스는 상속과 동일하게 extends 예약어로 구현. 인터페이스와 유사하게 구현하는 클래스에서는 상속받은 abstract 메소드를 반드시 구현해야 함</li>
  <li>
    <p>설계 단계에서 인터페이스 선언 시 어떤 메소드는 미리 만들어 놓아도 문제가 없는 경우 사용</p>

    <table>
      <thead>
        <tr>
          <th>구분</th>
          <th>인터페이스</th>
          <th>abstract 클래스</th>
          <th>클래스</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>선언 시 사용하는 예약어</td>
          <td>interface</td>
          <td>abstract class</td>
          <td>class</td>
        </tr>
        <tr>
          <td>구현 안 된 메소드 포함 가능 여부</td>
          <td>가능(필수)</td>
          <td>가능</td>
          <td>불가</td>
        </tr>
        <tr>
          <td>구현된 메소드 포함 가능 여부</td>
          <td>불가</td>
          <td>가능</td>
          <td>가능(필수)</td>
        </tr>
        <tr>
          <td>static 메소드 선언 가능 여부</td>
          <td>불가</td>
          <td>가능</td>
          <td>가능</td>
        </tr>
        <tr>
          <td>final 메소드 선언 가능 여부</td>
          <td>불가</td>
          <td>가능</td>
          <td>가능</td>
        </tr>
        <tr>
          <td>상속 가능</td>
          <td>불가</td>
          <td>가능</td>
          <td>가능</td>
        </tr>
        <tr>
          <td>구현 가능</td>
          <td>가능</td>
          <td>불가</td>
          <td>불가</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="103-final">10.3 final</h3>
<ul>
  <li>클래스에 선언할 경우 해당 클래스 상속 불가</li>
  <li>메소드에 선언할 경우 해당 메소드 오버라이딩 불가</li>
  <li>변수에 선언할 경우 더 이상 값을 바꿀 수 없음. 따라서 인스턴스 변수나 static 변수, 참조 자료형의 경우 여러곳에서 사용될 수 있으므로 선언과 함께 값을 지정해야 함</li>
  <li>매개 변수나 지역 변수가 final일 경우는 반드시 선언할 때 초기화할 필요는 없음</li>
  <li>참조 자료형 클래스가 final이라고 해서 그 안에 있는 인스턴스 변수나 static 변수가 final이 되진 않음. 따라서 해당 값들은 변경 가능</li>
</ul>

<h3 id="104-enum">10.4 enum</h3>
<ul>
  <li>상수의 집합으로, 타입이자 클래스의 일종</li>
  <li>enum 클래스에 있는 상수들은 별도로 타입이나 값을 지정할 필요가 없음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public enum OverTimeValues {
      THREE_HOUR,
      FIVE_HOUR,
      WEEKEND_FOUR_HOUR,
      WEEKEND_EIGHT_HOUR;

      // 컴파일러가 기본 생성자 자동 생성
      private OverTimeValues() { }
  }

  public class OverTimeManager {
      public getOverTimeAmount(OverTimeValues value){
          int amount = 0;
          Sytstem.out.println(value);
          switch(value){
              case THREE_HOUR:
                  amount = 18000;
                  break;
              case FIVE_HOUR:
                  amount = 30000;
                  break;
              case WEEKEND_FOUR_HOUR:
                  amount = 40000;
                  break;
              case WEEKEND_EIGHT_HOUR:
                  amount = 60000;
                  break;
          }
          return amount;
      }
  }

  public class OverTimeManager {
      public static void main(String args[]){
          OverTimeManager manager = new OverTimeManager();
          int myAmount = manager.getOverTimeAmount(OverTimeValues.THREE_HOUR); // enum 클래스이름.상수이름 지정만으로 객체 생성 완료
          System.out.println(value2.getAmount);
      }
  }

  // 출력 결과
    
  // THREE_HOUR
  // 18000
</code></pre></div>    </div>
  </li>
  <li>필요할 경우 enum 상수 값을 처음부터 지정할 수 있음</li>
  <li>enum 클래스의 각 상수는 해당 클래스의 인스턴스 변수가 아닌, 인스턴스 자체로 간주하면 됨. 따라서 해당 클래스에 상수가 아닌 인스턴스 변수가 늘어나면 각 상수가 가지는 값의 개수도 늘어남</li>
  <li>enum 클래스는 생성자는 package-private나 private로 만들 수 있으나 package-private로 선언해도 사실상 private로 동작함. 또한 생성자를 통해 객체를 생성할 수는 없으며, enum 클래스 내부에서 각 상수의 값을 선언할 때에만 이 생성자를 사용할 수 있음</li>
  <li>메소드는 보통 클래스와 동일하게 정의하여 사용할 수 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public enum OverTimeValues2 {
      THREE_HOUR(18000),
      FIVE_HOUR(30000),
      WEEKEND_FOUR_HOUR(40000),
      WEEKEND_EIGHT_HOUR(60000);

      private final int amount;

      OverTimeValues2(int mount){
          this.amount = amount;
      }
      public int getAmount(){
          return amount;
      }
  }

  public class OverTimeManager2 {
      public static void main(String args[]){
          OverTimeValues2 value2 = OverTimeValues2.FIVE_HOUR;
          System.out.println(value2);
          System.out.println(value2.getAmount);
      }
  }

  // 출력결과

  // FIVE_HOUR
  // 30000
</code></pre></div>    </div>
  </li>
  <li>
    <p>enum 클래스는 무조건 java.lang.Enum 클래스의 상속을 받음</p>

    <table>
      <thead>
        <tr>
          <th>접근 제어자</th>
          <th>메소드</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>protected</td>
          <td>Enum(String name, int ordinal)</td>
          <td>컴파일러에서 자동 호출되도록 해둔 생성자</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>name은 enum 상수의 이름이며 ordinal은 상수가 선언된 순서대로 0부터 증가</li>
  <li>Enum 클래스의 부모 클래스는 Object 클래스이나, Enum 클래스에서 Object 클래스 중 4개의 메소드(clone(), finalize(), hashCode(), equals())를 오버라이딩하지 못하도록 막아 toString()만 오버라이딩 가능. toString()은 기본적으로 상수 이름을 출력해줌</li>
  <li>Enum 클래스에서 선언되어 있는 메소드 중에서는 compareTo(E e)가 있는데, enum 타입과 순서 차이(ordinal)를 반환함. 같은 상수라면 0을 반환</li>
  <li>그 외에 API 문서에 없는 특수한 메소드로 values()라는 static 메소드가 있는데, enum 클래스에 선언되어 있는 모든 상수를 배열로 반환. enum 객체에 어떤 상수가 어떤 순서로 선언되었는지 확인하기 좋음</li>
</ul>

<h2 id="11-예외">11. 예외</h2>

<h3 id="111-try-catch-문">11.1 try-catch 문</h3>
<ul>
  <li>try 블록 내에서 선언한 변수는 catch에서 인식되지 않음. try 앞에 미리 선언해놔야 함</li>
  <li>finally 블록은 try-catch 블록 이후, 예외 발생 여부와 상관 없이 항상 실행됨</li>
  <li>catch 블록을 여러개 정의하여 서로 다른 타입의 예외를 캐치하려할 경우 앞 catch 블록에서 캐치된 경우 뒤로는 전달이 되지 않음. 따라서 catch문의 예외는 체크해야 할 순서대로 나열해야 함</li>
  <li>모든 예외 클래스의 부모 클래스는 java.lang.Exception으로, Exception 클래스는 모든 예외를 캐치하므로 맨 밑에 사용해 예외들이 빠져나가지 못하도록 묶어두는 역할을 하는게 좋음. 캐치되지 않아 예외가 발생할 경우 해당 스레드는 끝남</li>
</ul>

<h3 id="112-예외의-종류-3가지">11.2 예외의 종류 3가지</h3>
<p><img src="/assets/images/자바예외.jpeg" alt="예외 클래스 상관 관계도" /></p>
<ul>
  <li>error
    <ul>
      <li>자바 프로그램 밖에서 발생한 예외 (서버 디스크 고장, 메인보드 고장 등으로 자바 프로그램이 동작 못하는 경우)</li>
      <li>프로세스에 영향을 준다는 점에서 스레드에 영향을 주는 Exception과 구분됨</li>
    </ul>
  </li>
  <li>checked exception (Other Exception)
    <ul>
      <li>Exception을 확장한 예외들</li>
      <li>NullPointerException, NumberFormatException, ClassCastException.. 및 기타 등등</li>
    </ul>
  </li>
  <li>runtime exception
    <ul>
      <li>RuntimeException을 확장한 예외들</li>
      <li>컴파일 시점이 아닌 실행 시점에 발생 가능. 따라서 try-catch로 묶지 않아도 컴파일시에 예외가 발생하지는 않으나 묶어두는 편이 좋음</li>
      <li>IOException, SQLException.. 및 기타 등등</li>
    </ul>
  </li>
</ul>

<h3 id="113-javalangthrowable">11.3 java.lang.Throwable</h3>
<ul>
  <li>Throwable의 생성자
    <ul>
      <li>Throwable()</li>
      <li>Throwable(String Message)</li>
      <li>Throwable(String Message, Throwable casue)</li>
      <li>Throwable(Throwable casue)</li>
    </ul>
  </li>
  <li>Throwable 클래스에 선언되어 있고 Exception 클래스에서 오버라이딩 한 주요 메소드
    <ul>
      <li>getMessage()
        <ul>
          <li>예외 메시지를 String 형태로 제공받음. 어떤 예외가 발생했는지에 대한 예외 메시지를 활용하여 사용자에게 별도의 예외 메시지를 보여주기 위해 오버라이딩 가능</li>
        </ul>
      </li>
      <li>toString()
        <ul>
          <li>getMessage()와 비슷하나 약간 더 자세하게, 예외 클래스 이름도 같이 제공받음</li>
        </ul>
      </li>
      <li>printStackTrace()
        <ul>
          <li>첫 줄에 예외 메시지를, 두 번째 줄부터는 예외가 발생하게 된 메소드들의 스택 트레이스 출력</li>
          <li>printStackTrace &gt; toString &gt; getMessage 순으로 자세함</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="114-throw-throws">11.4 throw, throws</h3>
<ul>
  <li>예외를 직접 던지려면 throw 예외객체; 실행. catch문에 해당 예외를 잡아줄 객체나 부모 객체가 정의되어있지 않을 경우 해당 예외가 발생한 메소드 밖으로 던져짐</li>
  <li>이때 예외를 던지는 메소드 선언 옆에는 throws + 예외 클래스가 붙어야 함. 해당 메소드를 호출한 메소드로 예외 처리를 위임한다는 의미. 해당 메소드에선 try-catch문이 없어도 되며 해당 메소드를 호출한 메소드에서 호출문을 try-catch문으로 감싸주거나 예외를 다시 그 밖으로 위임할 수 있음</li>
  <li>Exception을 던질 가능성이 있는 코드가 try-catch나 throws가 강제되는 건 checked exception에 한정됨</li>
  <li>가장 좋은 방법은 throws하는 메소드를 호출하는 메소드에서 try-catch로 처리하는 것. 예외가 시작된 메소드에서는 어떻게 처리해야할지 알 수 없는 경우가 있으니 책임이 있는 곳(메소드)에서 처리해야 함</li>
  <li>implements 처럼 throws 뒤에도 여러 예외 클래스가 올 수 있음</li>
</ul>

<h3 id="115-사용자-정의-exception">11.5 사용자 정의 Exception</h3>
<ul>
  <li>Throwable이나 그 자식 클래스의 상속을 받아야 함</li>
  <li>try-catch로 묶어줄 필요가 있을 경우에만 Exception클래스 확장, 실행 시 예외를 처리할 수 있는 경우에는 RuntimeException 클래스 확장</li>
</ul>

<h2 id="12-string">12. String</h2>

<h3 id="121-string-클래스-선언">12.1 String 클래스 선언</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final calss String extends Object
     implements Serializable, Comparable&lt;String&gt;, CharSequence
</code></pre></div></div>
<ul>
  <li>Serializable 인터페이스 : 구현해야 하는 메소드가 하나도 없음. 구현 시 해당 객체를 파일로 저장하거나 다른 서버에 전송 가능한 상태가 됨</li>
  <li>Comparable 인터페이스 : compareTo() 메소드를 상속받아 구현함. 매개변수로 받은 객체를 비교하여 같으면 0, 알파벳 순으로(정확히는 유니코드 값에 따라) 앞이면 -1, 뒤이면 1 반환. 알파벳 순서만큼 그 숫자값이 커짐</li>
  <li>CharSequence 인터페이스 : 해당 클래스가 문자열을 다루기 위한 클래스라는 것을 명시적으로 나타내는데 사용</li>
</ul>

<h3 id="122-string---바이트-배열-변환">12.2 String &lt;-&gt; 바이트 배열 변환</h3>
<ul>
  <li>String 클래스에는 다양한 생성자가 있지만 아래 2개가 가장 많이 사용됨
    <ul>
      <li>String(byte[] bytes) : 현재 JVM이 실행되는 환경의 기본 문자 인코딩 방식의 캐릭터 셋을 사용하여 제공된 byte 배열을 디코딩한 String 객체를 생성</li>
      <li>String(byte[] bytes, String charsetName) : 지정된 캐릭터 셋을 사용하여 제공된 byte 배열을 디코딩한 String 객체를 생성</li>
      <li>생성자의 매개 변수로 받는 byte 배열은 String 클래스의 아래의 메소드로 생성됨
        <ul>
          <li>byte[] getBytes() : 기본 캐릭터 셋의 바이트 배열 생성</li>
          <li>byte[] getBytes(Charset charset) : 지정한 캐릭터 셋으로 바이트 배열 생성</li>
          <li>byte[] getBytes(String charsetName) : 지정한 캐릭터 셋 이름으로 바이트 배열 생성</li>
        </ul>
      </li>
      <li>java.nio.Charset 클래스 API에는 표준 캐릭터 셋이 정해져 있음.
        <ul>
          <li>UTF-8, UTF-16, EUC-KR 및 기타 등등</li>
          <li>한글을 처리하기 위해 자바에서 많이 사용하는 캐릭터 셋은 UTF-16</li>
        </ul>
      </li>
      <li>문자가 깨지는 것을 방지하려면 문자열 &lt;-&gt; 바이트 배열 전환 시 동일한 캐릭터 셋을 사용해야 함</li>
      <li>한글을 byte 배열로 만들 때 어떤 캐릭터 셋을 쓰느냐에 따라서 배열의 크기가 달라짐. EUC-KR은 두글자에 4바이트, UTF-16은 6바이트</li>
      <li>String 타입의 캐릭터 셋을 매개변수로 받는 아래의 두 생성자/메소드는 UnsupportedEncodingException 체크 예외를 발생시킬 수 있음. 따라서 반드시 try-catch로 감싸줘야 함
        <ul>
          <li>String(byte[] bytes, String charsetName)</li>
          <li>byte[] getBytes(String charsetName)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="123-string의-다양한-메소드">12.3 String의 다양한 메소드</h3>

<h4 id="1231-문자열의-길이를-확인하는-메소드">12.3.1 문자열의 길이를 확인하는 메소드</h4>
<ul>
  <li>length() : 배열의 크기를 확인하는 .length와 달리 괄호가 붙음. 배열은 객체이나 메소드는 없는 특수한 객체</li>
</ul>

<h4 id="1232-문자열이-같은지-비교하는-메소드">12.3.2 문자열이 같은지 비교하는 메소드</h4>
<ul>
  <li>메소드
    <ul>
      <li>boolean equals(Object anObject)</li>
      <li>boolean equalsIgnoreCase(String anotherStr)</li>
      <li>int compareTo(String anotherStr)</li>
      <li>int compareToIgnoreCase(String str)</li>
      <li>boolean contentEquals(CharSequence cs)</li>
      <li>boolean contentEquals(StringBuffer sb)</li>
    </ul>
  </li>
  <li>모두 매개변수로 넘어온 값과 String 객체가 같은지를 비교하는 메소드로 IgnoreCase가 붙은 메소드들은 대소문자 구분을 할지 안할지 여부만 다름</li>
  <li>String 클래스의 equals() 메소드는 오버라이딩 되어 주소값이 아닌 value를 비교함</li>
  <li>자바에는 객체들을 재사용하기 위해 Constant Pool이라는 것이 만들어져 있는데, String의 경우 동일한 값을 갖는 객체가 있으면 이미 만든 객체를 재사용함. 따라서 아래의 text와 text2는 동일한 객체가 됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String text = "Check value";
  String text2 = "Check value";
  if(text == text2){
      ...
  }
  if(text.equals("Check value")){
      ...
  }
  //두 if문 모두 true가 됨
</code></pre></div>    </div>
  </li>
  <li>같은 문자열 값이어도 Constant Pool 활용하지 않고 별도의 객체를 생성하고 싶으면
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String text = "Check value";
  String text2 = new String("Check value");
</code></pre></div>    </div>
  </li>
  <li>comepareTo() 메소드 설명은 앞의 12.1참고, contentEquals는 2권에서</li>
</ul>

<h4 id="1233-특정-조건에-맞는-문자열이-있는지를-확인하는-메소드">12.3.3 특정 조건에 맞는 문자열이 있는지를 확인하는 메소드</h4>
<ul>
  <li>boolean startsWith(String prefix)</li>
  <li>boolean startsWith(String prefix, int toffset)</li>
  <li>boolean endsWith(String suffix)</li>
  <li>boolean contains(CharSequence s)</li>
  <li>boolean matches(String regex) : contains()와 유사하나 매개변수가 정규표현식이어야 함</li>
  <li>boolean regionMatches(int toffset, String other, int ooffset, int len)</li>
  <li>boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)
    <ul>
      <li>ignoreCase : true일 경우 대소문자 구분없이 비교</li>
      <li>toffset : 비교 대상 문자열의 확인 시작 위치 지정</li>
      <li>other : 존재하는지를 확인할 문자열</li>
      <li>ooffset : other 객체의 확인 시작 위치 지정</li>
      <li>len : 비교할 char의 개수 지정 (비교 대상 문자열의 확인 시작 위치, other 객체의 확인 시작 위치로부터 몇개 문자가 일치하는지 확인할지)</li>
      <li>매개 변수의 값이 잘못된 경우 무조건 false 반환됨</li>
    </ul>
  </li>
</ul>

<h4 id="1234-string-내에서-위치를-찾는-메소드">12.3.4 String 내에서 위치를 찾는 메소드</h4>
<ul>
  <li>메소드
    <ul>
      <li>int indexOf(int ch)</li>
      <li>int indexOf(int ch, int fromIndex)</li>
      <li>int indexOf(String str)</li>
      <li>int indexOf(String str, int fromIndex)</li>
      <li>int lastIndexOf(int ch)</li>
      <li>int lastIndexOf(int ch, int fromIndex)</li>
      <li>int lastIndexOf(String str)</li>
      <li>int lastIndexOf(String str, int fromIndex)</li>
    </ul>
  </li>
  <li>indexOf()는 가장 앞에서부터, lastIndexOf()는 뒤에서부터 문자열이나 char을 찾음</li>
  <li>int ch는 char을 의미함. char은 정수형이기 때문에 매개변수로 char 넘기면 자동으로 int로 형변환 됨</li>
  <li>fromIndex는 문자열의 가장 왼쪽 기준 몇번째 자리부터 값을 확인할지에 대한 값. IndexOf()에서는 해당 위치로부터 오른쪽으로, lastIndexOf()에서는 왼쪽으로 탐색함</li>
  <li>해당 char이나 문자열이 없으면 -1 반환</li>
</ul>

<h4 id="1235-string-값의-일부를-추출하기-위한-메소드">12.3.5 String 값의 일부를 추출하기 위한 메소드</h4>
<ul>
  <li>java 8까지 String 클래스에선 String 문자열의 값을 char 배열로 저장해왔으나, 성능과 메모리 활용성을 고려하여 java 9부터는 byte 배열로 내부적으로 저장</li>
  <li>char 단위의 값을 추출하거나 char 배열 &lt;-&gt; String 변환 메소드
    <ul>
      <li>char charAt(int index) : 특정 위치의 char 값을 반환</li>
      <li>static String copyValueOf(char[] data) : char 배열 -&gt; 문자열</li>
      <li>char[] toCharArray() : 문자열 -&gt; char 배열</li>
    </ul>
  </li>
  <li>문자열의 일부 값을 잘라내는 메소드
    <ul>
      <li>String substring(int beginIndex) : beginIndex부터 끝까지 문자열 잘라 반환</li>
      <li>String substring(int beginIndex, int endIndex) : beginIndex부터 endIndex까지 문자열 잘라 반환</li>
      <li>CharSequence subSequence(int beginIndex, int endIndex) : beginIndex부터 endIndex까지 문자열을 잘라 반환</li>
    </ul>
  </li>
  <li>문자열을 여러 개의 String 배열로 나누는 split 메소드
    <ul>
      <li>메소드
        <ul>
          <li>String[] split(String regex) : 정규 표현식에 맞춰 문자열을 잘라 String 배열로 반환</li>
          <li>String[] split(String regex, int limit) : 위와 유사하나 반환하는 String 배열 크기에 대한 limit가 있음</li>
        </ul>
      </li>
      <li>정규표현식이나 특정 알파벳, 기호 하나로 문자열을 나눌경우 split()를, 특정 String으로 문자열을 나눌경우 StringTokenizer 클래스를 이용하는 편이 용이함</li>
    </ul>
  </li>
</ul>

<h4 id="1236-string값을-바꾸는-메소드">12.3.6 String값을 바꾸는 메소드</h4>
<ul>
  <li>문자열을 합치거나 공백을 제거하는 메소드
    <ul>
      <li>String concat(String str) : 자바에선 +로 문자열을 더할 수 있어 잘 사용 안됨</li>
      <li>String trim() : 문자열의 맨앞과 맨뒤에 있는 공백들을 제거. 문자열에 공백을 제외한 char값이 하나 이상 있는지 확인하는데 사용할 수 있음
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String text = " a ";
  if(text!=null &amp;&amp; text.trim().length() &gt; 0){
      System.out.println("OK");
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>내용을 교체하는 메소드
    <ul>
      <li>String replace(char oldChar, char newChar) : 문자열에서 oldChar 문자를 newChar 문자로 모두 치환</li>
      <li>String replace(CharSequence target, CharSequence replacement) : 문자열에서 target 문자열을 replacement 문자열로 모두 치환</li>
      <li>String replaceAll(String regex, String replacement) : 정규 표현식에 매칭되는 모든 부분을 replacement로 치환</li>
      <li>String replaceFirst(String regex, String replacement) : 정규 표현식에 매칭되는 첫번째 내용을 replacement로 치환</li>
    </ul>
  </li>
  <li>특정 형식에 맞춰 값을 치환하는 메소드
    <ul>
      <li>메소드
        <ul>
          <li>static String format(String format, Object… args)</li>
          <li>static String format(Locale 1, String format, Object… args) : 지정한 Locale 지역 규칙에 따라 포맷팅</li>
        </ul>
      </li>
      <li>%s는 String, %d는 정수형, %f는 소수점이 있는 숫자, %%는 % 의미
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String name = "민형";
  int age = 25;

  String result = String.format("이름: %s, 나이: %d", name, age);
  System.out.println(result);
  // 출력: 이름: 민형, 나이: 25
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>대소문자를 바꾸는 메소드
    <ul>
      <li>toLowerCase()</li>
      <li>toLowerCase(Locale locale)</li>
      <li>toUpperCase()</li>
      <li>toUpperCase(Locale locale)</li>
    </ul>
  </li>
  <li>기본 자료형을 문자열로 변환하는 메소드
    <ul>
      <li>메소드
        <ul>
          <li>static String valueOf(boolean b) : boolean 값을 “true” 또는 “false” 문자열로 변환</li>
          <li>static String valueOf(char c)</li>
          <li>static String valueOf(char[] data)</li>
          <li>static String valueOf(char[] data, int offset, int count)</li>
          <li>static String valueOf(double d)</li>
          <li>static String valueOf(float f)</li>
          <li>static String valueOf(int i)</li>
          <li>static String valueOf(long l)</li>
          <li>static String valueOf(Object obj) : obj 객체의 toString() 결과를 반환. obj 값이 null인 경우에는 NullPointeraexcerption 없이 null을 반환함</li>
        </ul>
      </li>
      <li>별도의 문자열과 합치는 경우에는 valueOf() 사용할 필요없이 자동으로 문자열로 변환됨
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  byte b = 1;
  String byte1 = String.valueOf(b);
  String byte2 = b + ""
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="1237-사용해서는-안되는-메소드">12.3.7 사용해서는 안되는 메소드</h4>
<ul>
  <li>
    <p>String 클래스에서 관리하는 문자열 풀에 있는 값을 재사용하므로 text, text2는 동일한 객체가 되고, text3은 새로운 객체를 생성</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String text = "Check value";
  String text2 = "Check value";
  String text3 = new String("Check value");
</code></pre></div>    </div>
  </li>
  <li>String 클래스에는 자바가 아닌 C로 구현된 intern()이라는 메소드가 있음.</li>
  <li>intern()을 사용하면 new String(String)으로 생성한 문자열 객체라도 풀에 해당 값이 있으면 풀에 있는 값을 참조하는 객체 반환. 만약 동일한 문자열이 존재하지 않으면 풀에 해당 값을 추가. 따라서 아래를 수행한 뒤의 문자열은 equals()가 아닌 == 으로 값이 동일한지 비교할 수 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  text3 = text3.intern();
</code></pre></div>    </div>
  </li>
  <li>문제는 새로운 문자열을 쉴새없이 만드는 프로그램에서 intern() 메소드를 사용하여 억지로 문자열 풀에 값을 할당하게 하면 저장영역의 한계로 별도의 메모리 청소 단계를 거치게 되어 전체 자바 시스템 성능에 악영향을 줌
    <ul>
      <li>리터럴만 풀에 저장되기 때문에 아래의 경우 힙 영역에만 객체가 새로 생성되지만
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  for (int i = 0; i &lt; 1000000; i++) {
      String s = "Num" + i;   //i가 변수이므로 해당값은 힙에 저장됨
  }
</code></pre></div>        </div>
      </li>
      <li>아래의 경우에는 강제로 풀에 쌓이게 되어 GC의 부담이 커짐
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  for (int i = 0; i &lt; 1000000; i++) {
      String s = ("Num" + i).intern();
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="124-stringbuffer와-stringbuilder">12.4 StringBuffer와 StringBuilder</h3>
<ul>
  <li>String은 immutable(불변의) 객체이므로 한 번 만들어지면 더이상 값을 바꿀수 없음. 문자열을 더하면 새로운 문자열 객체가 생성되고 기존의 객체는 GC의 대상이 됨</li>
  <li>이러한 쓰레기를 계속 만드는 단점을 보안하기 위해 StringBuffer와 StringBuilder 클래스 제공</li>
  <li>StringBuffer와 StringBuilder는 +가 아닌 append() 메소드로 문자열을 더함. 이 때 새로운 객체를 생성하지 않으므로 여러 String을 더하는 연산이 있을 경우 해당 클래스를 적절하게 선택하여 사용하는 것이 좋음</li>
  <li>append()는 매개변수로 모든 기본 자료형과 참조 자료형을 포함하므로 어떤 값이라도 매개변수로 넣을 수 있음. append()의 반환 타입은 StringBuffer/StringBuilder이므로 연달아 사용 가능</li>
  <li>두 클래스의 메소드는 동일하나 StringBuffer는 Thread safe하고 StringBuilder는 그렇지 않음. 대신 StringBuilder가 속도는 더 빠름</li>
  <li>JDK 5 이상에서는 String 더하기 연산을 할 경우 컴파일 시 자동으로 해당 연산을 StringBuilder로 변환하나, for 루프와 같이 반복 연산을 할 경우에는 자동으로 변환을 해주지 않으므로 수동으로 해야함</li>
  <li>String, StringBuilder, StringBuffer 클래스는 모두 CharSequence 인터페이스를 구현하므로 이 셋 중 하나의 클래스를 사용하여 매개 변수로 받는 작업을 할 때 String이나 StringBuilder 타입으로 받기보다 CharSequence 타입으로 받는 편이 좋음</li>
  <li>하나의 메소드 내에서 문자열을 생성하여 더할 경우 StringBuilder를 사용해도 문제없으나, 어떤 클래스에 문자열을 생성하여 더하기 위한 인스턴스 변수가 선언되었고 여러 스레드에서 이 변수를 동시에 접근하는 일이 있다면 반드시 StringBuffer를 사용해야 함</li>
</ul>

<h2 id="13-내부-클래스">13. 내부 클래스</h2>

<h3 id="131-내부-클래스-종류">13.1 내부 클래스 종류</h3>
<ul>
  <li>static 여부에 따라 Static nested 클래스와 내부 클래스로 구분됨</li>
  <li>내부 클래스는 다시 (로컬) 내부 클래스와 익명 클래스로 나뉨</li>
  <li>내부 클래스의 용도
    <ul>
      <li>한 곳에서만 사용되는 클래스를 논리적으로 묶어서 처리해야 할 때</li>
      <li>캡슐화가 필요할 때 (내부 구현 은닉)</li>
      <li>소스의 가독성과 유지보성 향상</li>
    </ul>
  </li>
</ul>

<h3 id="132-static-nested-클래스">13.2 Static nested 클래스</h3>
<ul>
  <li>일반 내부 클래스와 달리 감싸고 있는 클래스의 static 변수만 참조할 수 있음</li>
  <li>반대로 감싸고 있는 클래스에서 내부 클래스의 인스턴스 변수에 접근하려면 static 여부 상관없이 내부 클래스의 객체를 생성해서
그 객체를 통해서만 가능
    <ul>
      <li>outer를 만든다고 해서 자동으로 inner가 생성되지는 않으며, outer.new Inner()라고 명시적으로 생성해야 Inner 객체가 생성됨. 따라서 Inner 클래스는 문법적으로 내부에 포함되어 있을뿐, 객체 레벨에선 독립적임</li>
    </ul>
  </li>
  <li>Static nested 클래스를 초기화하려면
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class OuterOfStatic {
      static class StaticNested { //Static nested 클래스
          int value = 200;
            
          public int setValue(int value){
              this.value = value;
          }
      }
  }

  public class NestedSample {
      public static void main(String[] args){
          NestedSample sample = new NestedSample();
          sample.makeStaticNestedObject();
      }
      public void makeStaticNestedObject(){
          OuterOfStatic.StaticNested staticNested = new OuterOfStatic.StaticNested();
          staticNested.setValue(3);
      }
  }
</code></pre></div>    </div>
  </li>
  <li>Outer 클래스와 논리적으로 묶여 있지만, 인스턴스에 종속될 필요는 없는 클래스가 필요할 때 사용. Outer 객체 없이도 생성 가능함</li>
  <li>School, University 클래스가 있을 때 Student 클래스를 독립적으로 생성하는 대신 각 클래스 안에 static으로 생성하면 어느쪽의 Student인지 용도가 보다 명확해짐</li>
</ul>

<h3 id="133-내부클래스와-익명클래스">13.3 내부클래스와 익명클래스</h3>
<ul>
  <li>static 하지 않은 일반 내부클래스는 outer 객체 생성이 먼저 필요함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class InnerSample {
      public static void main(String[] args) {
          // Outer 객체 먼저 생성
          InnerSample outer = new InnerSample();

          // Inner 객체 생성 (Outer 인스턴스를 통해)
          Inner inner = outer.new Inner();
          inner.setValue(5);
          inner.printValue();
      }
  }
</code></pre></div>    </div>
  </li>
  <li>하나의 클래스에서 어떤 공통적인 작업을 수행하는 클래스가 필요한데 다른 클래스에서는 그 클래스가 전혀 필요 없을 때 사용</li>
  <li>GUI(사용자 화면용 애플리케이션) 관련 프로그램 개발 시 가장 많이 사용. Swing, Applet, SWT, GWT, 안드로이드 등</li>
  <li>GUI에서 내부클래스들은 리스너를 처리할 때(어떤 버튼이 눌렸을 때) 해야 하는 작업을 정의할 때 많이 쓰임. 버튼마다 작업이 보통 상이하므로 별도로 클래스를 만드는 대신 내부클래스를 만들며, 일회성일 경우 더 간단하게 익명클래스를 사용함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MagicButton {
      private EventListener listener;

      public void setListener(EventListener listener) {
          this.listener = listener;
      }
      public void onClickProcess(){
          if(listener != null){
              listener.onClick();
          }
      }
  }

  MagicButton button = new MagicButton();
  button.setListener(new EventListener() {   //익명클래스
      public void onClick(View v) {
          System.out.println("Clicked!");
      }
  });
</code></pre></div>    </div>
  </li>
  <li>객체 생성처럼 보이나, outer 클래스 내부에서 새로운 클래스의 몸통을 정의했으므로 내부클래스에 속함</li>
  <li>클래스를 만들고 호출하면 그 정보는 메모리에 올라가므로 많이 생성될수록 메모리 사용량이 늘어나고 애플리케이션 시작 속도가 느려짐. (로컬)내부클래스와 달리 익명클래스를 사용하면 Outer 클래스의 인스턴스 변수 등을 참조하지 않는 이상 Outer 객체와 불필요하게 오래 연결되지 않아 GC의 Outer 객체 회수가 더 용이해짐</li>
</ul>

<h2 id="14-어노테이션">14. 어노테이션</h2>

<h3 id="141-정의">14.1 정의</h3>
<ul>
  <li>클래스나 메소드 등의 선언시에 @를 사용하는 것. JDK 5부터 등장함</li>
  <li>컴파일에게 정보를 알려주거나, 컴파일할 때와 설치 시의 작업을 지정하거나, 실행할 때 별도의 처리가 필요할 때 사용함</li>
</ul>

<h3 id="142-자바-기본-어노테이션-3개">14.2 자바 기본 어노테이션 3개</h3>
<ul>
  <li>@Override
    <ul>
      <li>해당 메소드가 Override 된 것이니 잘못 코딩 시 컴파일러가 알려주도록 하기위해 사용</li>
    </ul>
  </li>
  <li>@Deprecated
    <ul>
      <li>컴파일러에게 더 이상 사용하지 않는 클래스/메소드이며 다른이가 사용시 경고하도록 요청하기 위해 사용</li>
      <li>여러 사람들과 작업할 경우 @Deprecated로 사용하지 않을것이라는 알림을 제공하여 계도 기간을 거친 후 삭제하는 것이 바람직함</li>
    </ul>
  </li>
  <li>@SupressWarings
    <ul>
      <li>컴파일 시 경고 메시지가 나타날 때 내 의도대로 코딩한 것이니 경고를 해줄 필요가 없다고 컴파일러에게 알리는 용도</li>
      <li>속성값을 지정할 수 있음 -&gt; @SupressWarings(“deprecation”)</li>
    </ul>
  </li>
</ul>

<h3 id="143-메타-어노테이션">14.3 메타 어노테이션</h3>
<ul>
  <li>어노테이션을 직접 선언할 때 사용</li>
  <li>@Target
    <ul>
      <li>어노테이션을 어떤 것에 적용할지 선언</li>
      <li>@Target(ElementType.METHOD)와 같이 괄호 안에 적용대상 지정
        <ul>
          <li>적용 대상
            <ul>
              <li>CONSTRUCTOR</li>
              <li>FIELD</li>
              <li>LOCAL_VALIABLE</li>
              <li>METHOD</li>
              <li>PACKAGE</li>
              <li>PARARMETER</li>
              <li>TYPE : 클래스, 인터페이스, enum 등</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>@Retention
    <ul>
      <li>얼마나 오래 어노테이션 정보가 유지되는지 선언</li>
      <li>@RETENTION(RetentionPolicy.RUNTIME)
        <ul>
          <li>적용대상
            <ul>
              <li>SOURCE</li>
              <li>CLASS</li>
              <li>RUNTIME</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>@Documented
    <ul>
      <li>해당 어노테이션에 대한 정보가 Javadocs(API) 문서에 포함된다는 것 선언</li>
    </ul>
  </li>
  <li>@Inherited
    <ul>
      <li>모든 자식 클래스에서 부모 클래스의 어노테이션을 사용 가능하다는 것 선언</li>
    </ul>
  </li>
  <li>@interface
    <ul>
      <li>어노테이션을 선언 시 함게 사용</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.lang.annotation.*;

//적용 대상 지정 (클래스, 메서드 등)
@Target({ElementType.TYPE, ElementType.METHOD})

//유지 정책 지정 (런타임)
@Retention(RetentionPolicy.RUNTIME)

//어노테이션 정의
public @interface UserAnnotation {
    public int number();  // 속성 정의
    public String text() default "This is first annotation" // 기본값 있는 속성
}

@UserAnnotation(number = 1, text = "클래스에 적용")
public class UserService {

    @UserAnnotation(number = 2) // text는 기본값 사용. 기본값 지정되어 있지 않은 number는 반드시 값 지정 필요
    public void createUser() {
        ...
    }
}
</code></pre></div></div>

<ul>
  <li>어노테이션 속성은 메타데이터일 뿐 실제 필드가 아니며, 값을 읽어오려면 자바 리플렉션이라는 API에서 제공하는 클래스들을 사용해야 함</li>
  <li>lombok : 개발자가 필요한 작업을 어노테이션 선언만으로도 편하게 처리할 수 있게 도와줌</li>
</ul>]]></content><author><name>Toyo</name></author><category term="CS" /><category term="java" /><summary type="html"><![CDATA[1. 자바 변수와 자료형]]></summary></entry><entry><title type="html">뉴욕주민의 진짜 미국식 주식투자 : 내용 정리</title><link href="/investments/2025/06/07/%EB%89%B4%EC%9A%95%EC%A3%BC%EB%AF%BC%EC%9D%98-%EC%A7%84%EC%A7%9C-%EB%AF%B8%EA%B5%AD%EC%8B%9D-%EC%A3%BC%EC%8B%9D%ED%88%AC%EC%9E%90.html" rel="alternate" type="text/html" title="뉴욕주민의 진짜 미국식 주식투자 : 내용 정리" /><published>2025-06-07T00:00:00+00:00</published><updated>2025-06-07T00:00:00+00:00</updated><id>/investments/2025/06/07/%EB%89%B4%EC%9A%95%EC%A3%BC%EB%AF%BC%EC%9D%98%20%EC%A7%84%EC%A7%9C%20%EB%AF%B8%EA%B5%AD%EC%8B%9D%20%EC%A3%BC%EC%8B%9D%ED%88%AC%EC%9E%90</id><content type="html" xml:base="/investments/2025/06/07/%EB%89%B4%EC%9A%95%EC%A3%BC%EB%AF%BC%EC%9D%98-%EC%A7%84%EC%A7%9C-%EB%AF%B8%EA%B5%AD%EC%8B%9D-%EC%A3%BC%EC%8B%9D%ED%88%AC%EC%9E%90.html"><![CDATA[<h2 id="1-미국-주식시장-구조">1. 미국 주식시장 구조</h2>
<ul>
  <li>미국 주식시장은 3개의 시장 플레이어로 구성됨.
    <ul>
      <li>미국증권거래위원회(SEC) : 매매 관리 감독, 규제.</li>
      <li>셀사이드 : 유가 증권을 유통하는 증권사. 미국에서는 투자은행IB가 담당. 매매 중개자이자 딜러에 속함.</li>
      <li>바이사이드 : 투자 대상을 선별해 자산을 투자하는 운용 주체. 개인 또는 외부 투자자의 자금을 운영하는 펀드회사. 헤지펀드, 사모펀드, 자산운용자, 보험사 등</li>
    </ul>
  </li>
  <li>을의 입장인 셀사이드는 갑인 바이사이드에게 매매 수수료를 받는 대신 기본 매매 업무뿐 아니라 기업 연계 서비스도 제공</li>
  <li>셀사이드 애널리스트 : 증권사, 투자은행 등에서 일하며 기업 분석 리포트를 작성하고 기관/개인에게 투자 의견을 제공. 투자자의 셀사이드 리서치 의존도가 예전에 비해 낮아지자 증권사 측에서는 셀사이드 애널리스트를 줄이는 추세</li>
  <li>바이사이드 애널리스트 : 연기금, 자산운용사, 보험사, 헤지펀드 등에서 내부 투자 판단을 위한 분석을 수행하는 전문가. 외부에 분석 결과를 공개하지 않음</li>
  <li>공시 자료를 정확히 이해하고 미래 손익을 추정하는 작업이 어려운 이유는 기업이 보고한 숫자를 그대로 받아들여서는 안되기 때문. 기업이 특정 비용을 예외로 간주해 누락한 이유가 무엇인지, 의도적으로 제외한 요소는 없는지, 경영진이 말하는 계속사업이익은 정말 지속가능한지, 재무상태표에 숨은 부채나 자산은 없는지 등 합리적인 의심 요소는 수없이 많음</li>
  <li>특별손익(Extraorinary Gains,/Losses), 일회성 비용(One-time Expenses; Non-recurring Charges) 같은 용어가 보이면 그 항목의 자금흐름을 정확히 이해할 필요가 있음. 회계기준을 위반하지 않으면서 경영진이 보여주고 싶은 부분만 보여주고 특정 비용을 잘 포장해 재무제표상의 숫자를 크게 왜곡할 수 있음</li>
</ul>

<h2 id="2-미국의-기업-공시">2. 미국의 기업 공시</h2>

<h3 id="21-ipo-공모주--회사가-처음으로-주식을-일반-투자자들에게-공개해서-파는-것">2.1 IPO 공모주 : 회사가 처음으로 주식을 일반 투자자들에게 공개해서 파는 것</h3>
<ul>
  <li>IPO를 진행 시 해당 기업이 SEC에 제출하는 S-1 등록서류에는 최근 3년간의 연결 재무제표와 함께 기업의 사업 개요, 리스크 요인, 경영진 정보, 공모 조건 등이 포함됨</li>
  <li>SEC에 제출하는 증권신고서에는 오퍼링(규정상의 사업설명서)/트레이딩 레지스트레이션(장외시장에 거래하는 증권 등록 공시자료. 사업설명서 없음)이 있음</li>
  <li>S-1 : 일반 기업의 오퍼링 레지스트레이션
    <ul>
      <li>확인할 내용
        <ul>
          <li>IPO 개괄(The Offering)과 조달 자금의 사용 목적과 용도(Use of Proceeds), 배당 정책(Dividend Policy), IPO 전후를 비교하는 기업의 캡 테이블(Cap Table, IPO 같은 투자, 자금조달에 따른 기업의 자본금 변화와 지분 관계를 나타내는 표. Capitalization 탭 참고), 주가 희석(Dilution) 내용 정도는 확인하는게 좋음</li>
          <li>회사 재무 상황과 사업 실적에 관한 경영진 의견과 분석(MD&amp;A)에 있는 리스크 요인(risk factors)을 집중해서 볼 것.</li>
          <li>연결재무제표. 최근 몇년 간의 재무제표를 통해 과거 실적들의 행간을 읽는 재무 분석 필요.</li>
          <li>기업의 비즈니스 모델을 확인해야 함. 기업이 매출을 어떻게 올리고 비용구조는 어떻게 되는지.
            <ul>
              <li>기업이 수익을 내는 핵심 요소(드라이버)를 반영한 가치 평가 지표 및 타 경쟁사와 비교 가능한 운영지표는 변동 시 주가가 크게 움직이므로 파악해두는게 좋음</li>
              <li>Key Performance Metrics 참고</li>
            </ul>
          </li>
          <li>회사의 IR 사이트나 SEC의 EDGAR 공시 시스템에서 확인 가능.</li>
        </ul>
      </li>
      <li>변경사항을 확인할 수 있는 보충문서
        <ul>
          <li>Form 424B1(기존 공시 및 사업 보고서에 나와 있지 않은 새로운 정보가 있으면 공시)</li>
          <li>Form 424B2(새 증권 발행 시 해당 증권의 발행 가격 및 방법에 대한 정보 공시 보고서)</li>
          <li>Form 424B3(기존 공시 및 사업 보고서에 나온 내용에 유의미한 변화가 있을 때 정정 보고서)</li>
          <li>Form 424B4(최종적인 증권 발행의 가격 및 투자금 배분, 조달. S-1과 함께 공시)</li>
        </ul>
      </li>
      <li>공시 문서를 읽고 해당 기업이 속한 산업의 성장 동력, 해당 기업의 차별화된 비즈니스 모델에 대한 산업 규제 리스크 등 앞으로 주가에 영향을 미칠 것들에 대해 고려해야 함
        <ul>
          <li>Adjusted EBITDA는 이자, 세금, 감가상각 외에 일회성 비용, 주식보상비, 소송 비용 등으로 쓰인 금액을 제외한 핵심 영업활동 수익성만 확인하는 것. 해당 항목에서 비즈니스 모델의 리스크에 해당하는 금액을 확인 할 수 있음. 영업외비용으로 분류된 법무 비용이 진정 일회성 비용이 아니라면 리스크가 될 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="22-10-k--sec-제출용-연간-보고서">2.2 10-K : SEC 제출용 연간 보고서</h3>
<ul>
  <li>1부 : 사업 개요, 리스크, 법적 사항 (Business, Risk Factors)</li>
  <li>2부 : 회사 재무 상황과 사업 실적에 관한 경영진 의견과 분석(MD&amp;A)
    <ul>
      <li>기업의 지배구조, 조직구조</li>
      <li>기업의 연결재무제표</li>
      <li>기업의 실적 목표, 과거 경영진의 기대치와 실제 수치</li>
      <li>주요 사업 개요, 사업 환경, 시장 동향</li>
      <li>경영진이 인지하는 사업 리스크와 불확실성</li>
      <li>사업의 리스크 설명</li>
      <li>재무제표와 부속명세서 : 지난 2년간의 재무상태표, 지난 3년간의 손익셰산서와 현금 흐름표, 자본변동표</li>
    </ul>
  </li>
  <li>3부 : 경영진 및 이사회 구성과 기업의 지배구조, 임원의 보수 정보, 기업 내부자의 주식 보유 현황, 지분 관계가 있는 외부 주체 등</li>
  <li>4부 : 요약 재무 실적, 부록</li>
  <li>회계연도가 끝나면 90일 이내에 제출하는 공시자료이므로 해당 보고서 내용은 적어도 2~3개월 이상 지난 기업 현황임. Recent Events, Recent Deve-lopments 키워드로 최근 사건 검색 필요</li>
</ul>

<h3 id="23-10-q">2.3 10-Q</h3>
<ul>
  <li>분기가 끝나면 45일내로 공시하는 분기 실적 보고서. 10-K와 달리 공시한 재무제표에 감사가 들어가지 않았으며 덜 상세함</li>
  <li>추가로 분기별로 확인할 수 있는 자료로 주요 실적 발표 보고서 (Earnings Release), 해당 분기 사업 내용에 대한 투자자 설명서(Investor Presentation), 영업 실적의 보충 재무 현황을 담은 재무 보조 설명서(Financial Supplement), 어닝 콜 자료가 있음. 어닝 콜(경영진이 실적을 발표하고 다음 실적 목표를 공표한 이후 증권가 애널리스트와 Q&amp;A 세션을 여는 것) 내용은 대부분 웹캐스트나 오디오 파일 형태로 공유</li>
  <li>기업에 따라 기업이 예상하는 실적 지표 전망치를 담은 가이던스 메뉴를 따로 제공하기도 함. 보통은 주요 실적 발표 보고서 (Earnings Release), 해당 분기 사업 내용에 대한 투자자 설명서(Investor Presentation)에서 찾아봐야 함</li>
  <li>분기별 어닝 시즌은 주가가 가장 민감하게 움직이는 시기</li>
</ul>

<h3 id="24-애널리스트">2.4 애널리스트</h3>
<ul>
  <li>흔히 주식 애널리스트라 하면 셀사이드 애널리스트로, 증권사나 투자은행에서 일하면서 분기마다 담당 기업의 적정 주가 모델을 업데이트하고 기업 실적과 섹터 트렌드를 전망하는 보고서를 작성함</li>
  <li>어닝 시즌에 기업이 발표한 실제 실적이 월가에서 모아진 애널리스트들의 평균 예상치보다 높게 나오는지, 한참 미치지 못하는지에 따라 주가 등락이 결정됨. 실적이 예상치에 미칠지 미치지 못할 지를 예상하고 실적발표보다 먼저 움직일 필요가 있음.</li>
  <li>예상치는 Yahoo Finance &gt; Analysis 또는 Investing.com에서 무료로 확인 가능</li>
  <li>실적 발표 전에 이미 현재 주가에 기대심리가 반영되어 있을수도 있음</li>
</ul>

<h3 id="25-8-k">2.5 8-K</h3>
<ul>
  <li>10-Q, 10-K 제출 기간이 아닐 때 기업의 영업/재무 상황에 대하여 중요 변경 사항이 생길경우 공시. 파산, 구조조정, M&amp;A 관련소식 및 기타 등등</li>
  <li>파산에는 챕터 11인 파산 보호 신청과 챕터 7인 기업 청산이 있음. 파산 보호 신청 시 파산 보호법 상 기업은 빠르게 보유 자산을 청산하고 파산보호 상황에서 벗어나야 하는데, 파산 시 상환 우선순위에서 보통주 투자자는 가장 마지막이므로 대부분의 경우 주식 가치는 0이 됨</li>
  <li>유상증자 증권 신고서는 S-3으로 공시하며 투자자는 Form 424B에서 확인 가능. 신규 증권 발행 시 해당 증권 가격과 발행 주식 수 및 투자자가 알아야 할 리스크, 기대수익, 손실을 설명함
    <ul>
      <li>유상증자 시 주식 수가 늘어나며 주주 가치가 희석되지만 주가가 올라 부채비율을 낮추기 위함이거나 신사업 개발에 쓰이는 경우라면 기업 성장을 위함이므로 결과적으로 주가가 상승함. 반대로 재무 상황이 악화되었을 때 유상증자를 하면 공시가 뜨자마자 주가가 하락함</li>
    </ul>
  </li>
</ul>

<h3 id="26-def-14a">2.6 DEF-14A</h3>
<ul>
  <li>정기 주주 총회 전 제출해야 하는 공시. 프록시라고도 함.</li>
  <li>의결권이 있는 주주들이 회사 주요 사항, 지배구조에 투표하는 프로세스와 관련 정보 제공</li>
  <li>수록 내용
    <ul>
      <li>기업의 지배구조 : 이사회 역할과 구성</li>
      <li>이사회 : 이사회 멤버 약력과 당해 연도 보수, 선출 후보들의 프로필</li>
      <li>경영진/임원 : 경영진 약력과 지난 3년간 보수, 인센티브 금액, 보수 산정 체계, 경영권 해지/변동에 따른 페이아웃 제도
        <ul>
          <li>Compensation Discussion &amp; Analysis 부분에서 경영진의 기본 연봉, 성과급 기준, 현금 보너스, 스톡옵션 등 주식 보상을 포함해 지난 몇 년간의 보수 지급 현황/지급 사유 내역을 찾아볼 수 있음</li>
          <li>기업의 사업 실적에 비해 경영진/이사회 지급 보상 수준이 적절한지 확인 가능</li>
          <li>인수합병(M&amp;A) 등의 이유로 기업 경영권 주체가 변경될 경우 기존 경영진에게 주는 보상 내용도 있을 수 있음</li>
        </ul>
      </li>
      <li>주주총회 안건</li>
    </ul>
  </li>
  <li>일반적으로 경영진의 인센티브 상충에 문제가 잇거나 지배구조에 문제가 있는 기업의 경우 헤지펀드의 타깃이 되기 쉬움. 헤지펀드는 해당 기업들을 노려 지분을 5% 정도 매입한 후 기업구조를 주가가 오르는 방향으로 바꾸도록 영향력을 행사하고(구조조정, 자사주 매입 등), 주가가 오르면 차익을 실현하고 빠지는 식.</li>
</ul>

<h3 id="27-schedule-13d-13g">2.7 Schedule 13D, 13G</h3>
<ul>
  <li>미국 증권거래법 상 상장기업 지분을 5% 이상 보유하게 된 주체는 지분 거래 기준일로부터 10일 이내에 반드시 SEC에 신고해야 하며 Schedule 13D를 공시해야 함</li>
  <li>해당 공시는 공시자가 지분을 보유한 기업의 이름/티커의 13G, 13D로 검색 가능</li>
  <li>5% 이상 지분 보유자의 주식 매입 의도(Purpose of the Transaction, 테이크오버를 위함인지, M&amp;A를 위함인지 등)를 확인하기 위함</li>
  <li>해당 지분 소유자가 이미 13D를 공시한 상태에서 지분율을 1% 이상 변경한 경우에도 관련해서 다시 13D를 제출해야 함</li>
  <li>Schedule 13G는 13D에 비해 훨씬 더 간소한 보고서로, 13D 대신 제출할 경우 보유 지분으로 회사에 영향력을 행사할 의도가 없음을 증명하고 그 외에 SEC가 규정하는 일정 자격 요건을 갖춰야 함. 특정 기관에게만 허락된 형태의 보고서</li>
  <li>해당 공시를 통해 전문성 있는 큰 기관의 자금 흐름을 알 수 있지만, 개인 투자자가 그에 따라 해당 종목을 추격 매수/매도하는 건 권장되지 않음.
    <ul>
      <li>개인과 기관은 유동자금과 기회비용, 대체 전략 면에서 차이가 크기 때문에 설명 저평가 된 기업에 대한 투자라 할지라도 개인은 오랜 기간 유지되는 손실구간을 버티기 힘들 수 있으며, 행동주의 헤지펀드의 적대적 매수일 경우 경영권 주체가 정해지기 전까지 주가 변동성만 높아져 수익을 실현하기 어려울 수 있음</li>
    </ul>
  </li>
</ul>

<h3 id="28-schedule-13f">2.8 Schedule 13F</h3>
<ul>
  <li>자산 규모가 1억 달러 이상인 기관은 SEC에 해당 보유 지분 현황 보고서를 공시해야함. 헤지펀드를 비롯한 주식관련 대부분의 기관이 이에 해당됨.</li>
  <li>이 경우에도 지분을 보유한 기업의 이름/티커의 13F로 공시하는 것</li>
  <li>따라서 어떤 기업의 주요 주주명부를 확인하는 가장 빠르고 정확한 방법은 해당 기업의 13D, 13G, 13F 공시를 찾아보는 것임. 주주 중 기관투자자와 헤지펀드에 주목</li>
  <li>관심 있는 기관 플레이어들이 어디에 집중 베팅하는지 등 어떻게 움직이는지 확인할 수 있지만 분기 말 이후 45일 이내에만 공시하면 되므로 실제 매매가 이뤄진 타이밍보다 한참 뒤 지분 매입, 매각, 변경사항을 알 수 있다는 단점이 있음</li>
  <li>비교 분석하려면 이전 버전과 비교해 보아야 하며, 가독성이 떨어져 투자자를 위해 대형 기관이나 유명 헤지펀드에서 정리해 정보를 공유하는 사이트도 있음. 단, 실시간 제공이 아니며 다소 오류가 있을 수 있음</li>
  <li>포트폴리오를 방어하는 숏 포지션(공매도, 주가 하락에 배팅)이나 헤지는 롱 포지션(주식 직접 매수, 주가 상승에 배팅)과 달리 공시조차 하지 않음. 개인 투자자가 헤지펀드의 포지션을 따라하는 것은 앞서 말한 이유로 권장되지 않으므로 참고용으로만 활용할 것</li>
  <li>여기서 파악한 주주 명부로 해당 기관들의 13F</li>
  <li>용어
    <ul>
      <li>COM : 보통주 매입</li>
      <li>NOTE : 채권 투자자</li>
    </ul>
  </li>
</ul>

<h3 id="29-form-3-4-5">2.9 Form 3, 4, 5</h3>
<ul>
  <li>주요 미공개 정보를 보유한 사람들이 내부자 위치를 이용해 비파생/파생증권 매매 이득을 취하는 행위를 차단하기 위한 공시</li>
  <li>Form 3 : 인사이더가 처음 지분 획득 시 공개하는 지분율 최초 공시.
    <ul>
      <li>대상 : 기업 임원들, 기업 이사회 전원, 발행주식 총수의 10% 이상 보유한 실질 소유자, 기업의 주요관계자(기업 홍보자, 주식 발행 주관사, 기업의 전략 자문회사 등 내부자 정보를 아는 주체)</li>
      <li>대상자는 설령 지분이 없더라도 인사이더로 등재하는 순간 10일 이내 공시해야 함</li>
    </ul>
  </li>
  <li>Form 4 : 이후 주식 보유 현황에 변화가 있을 때 공시. 주식 매매일 기준 2거래일 이내 제출해야 하며, 그렇지 않을 경우 민형사상 처벌 대상.</li>
  <li>Form 5 : 해당 연도 보유 지분의 변경 사항과 최종 지분 상황을 정리한 것. 회계연도가 끝나고 45일 이내에 공시. Form 4 공시를 특정 사유로 지연 또는 면제 받은 사람은 Form 5를 제출하며 그간 공개안한 지분 변경 사항까지 공시해야 함</li>
  <li>내부자의 주식 추가 매수는 좋고 매도는 나쁘다고 단순하게 생각하기보단 그 의도가 더 중요함. 단지 스톡옵션을 일부 생사하기 위한 매도 일 수 있으며, 의도를 파악하려면 기업의 전체 상황과 공시 자료의 행간을 읽어내야 함</li>
  <li>용어
    <ul>
      <li>non-derivative securities (비파생 증권. 주식 등)</li>
      <li>derivative securities (파생 증권. 스톡옵션은 주식의 가치에 따라 가격이 결정되는 파생 증권)</li>
      <li>스톡옵션 : 회사 임직원에게 주는, 정해진 기간 동안 정해진 가격으로 주식을 살 수 있는 권리</li>
    </ul>
  </li>
</ul>

<h3 id="210-defm-14a">2.10 DEFM-14A</h3>
<ul>
  <li>공시 항목
    <ul>
      <li>해당 인수합병의 개요 (제안하는 인수대금 구성이 나옴)</li>
      <li>M&amp;A 타당성</li>
      <li>인수합병 딜의 구조</li>
      <li>딜 성사 조건과 클로징 예상일</li>
      <li>시너지</li>
    </ul>
  </li>
  <li>개인투자자가 흐름을 미리 읽고 인수합병을 예측하는데는 한계가 있으나, M&amp;A 발표 이후에도 투자 기회가 있음. 규제 장벽도 있고 다른 인수 제의가 들어오는 등 변수가 많기 때문. 이에 따라 주가도 낙폭이 커짐</li>
  <li>언론이 내보내는 기사는 공시자료를 추린 것으로 정보전달에 한계가 있으므로 직접 살펴보는 게 좋음</li>
  <li>일반 투자자 입장에서 관심대상은 주가가 급등하는 피인수 기업인데, M&amp;A에 필요한 자금조달 과정에서 인수 대금을 어떻게 구성하느냐에 따라 피인수 기업 주주가 얼마를 받을지가 결정됨</li>
  <li>인수합병은 일반적으로 피인수 기업의 보통주를 기존 주주들로부터 전부 사들이는 것</li>
  <li>보통 현금보유량이 많지 않으므로 100% 현금보다는 주식과 부채를 섞어 최대한 저렴하게 자금을 조달하려 함</li>
  <li>주식 교환비율은 “피인수 기업의 주주가 보유 주식 1주당 인수 기업의 주식을 몇 주 받는가”를 나타냄</li>
  <li>인수대금 구성 중 인수기업의 주식이 있을 경우 인수기업의 주가가 오를수록 이득. 대규모 유상증자로 인해 주가가 희석되니 인수 시너지가 얼마나 인수 기업의 주가를 상승시킬지가 중요</li>
  <li>인수합병(M&amp;A) 발표가 나면, 피인수 기업의 주가는 인수 기업이 제시한 인수가격 이상으로는 잘 오르지 않는 반면 인수 기업 주가는 딜 이후에도 업사이드가 있음. M&amp;A 뉴스로 거래량이 오르거나 다른 인수자가 인수 경합을 벌일 가능성이 있을 경우 기대 심리로 인해 피인수 기업의 주가가 더 오를수는 있음</li>
  <li>딜이 성사되지 않을 가능성이 높아질수록 인수 대상 주가는 하락함. 무산 원인으로는 반독점법 정부규제, 이사회에서의 승인 여부, 협상 결렬 등이 있음</li>
  <li>딜이 성사될거란 가정 하에 작지만 비교적 확실한 인수 가격과 현재 시장 가격과의 차이에서 오는 단기 수익 실현 -&gt; 피인수 기업 주식 구매</li>
  <li>딜의 시너지와 미래 성장성을 믿고 장기투자 -&gt; 인수 기업 주식 구매</li>
</ul>

<h3 id="211-s-4">2.11 S-4</h3>
<ul>
  <li>M&amp;A 관련주의 가장 상세하고 딜의 모든 내용을 포함하는 방대한 공시 자료.</li>
  <li>주요 항목
    <ul>
      <li>M&amp;A 승인을 위한 주주총회 위임 권유서</li>
      <li>주주들을 위한 Q&amp;A</li>
      <li>인수 기업, 피인수 기업 개요</li>
      <li>M&amp;A 딜 개요</li>
      <li>인수 기업 이사회가 해당 M&amp;A 건을 승인, 지지하는 이유</li>
      <li>인수 기업 재무 자문사(투자은행) 의견</li>
      <li>피인수 기업 이사회가 해당 M&amp;A 건을 승인, 지지하는 이유</li>
      <li>피인수 기업 재무 자문사(투자은행) 의견</li>
      <li>M&amp;A 인수합병 계약서 전문 : 재무분석, 합병 이후 추정 재무제표, 벨류에이션, 자금 조달 계획 등</li>
      <li>M&amp;A 자금조달 관련 사항</li>
      <li>인수 기업, 피인수 기업 주주의 권리 관련 사항</li>
      <li>M&amp;A가 인수/피인수 기업에 미치는 영향</li>
      <li>인수 대금 구성</li>
      <li>인수 기업과 피인수 기업 주주의 지분율 변화</li>
      <li>경영진의 황금낙하산</li>
      <li>딜의 성사 조건</li>
      <li>딜이 무산되었을 경우</li>
    </ul>
  </li>
  <li>위의 주요 항목 중 인수 기업의 밸류에이션 부분에서는, 인수/피인수 기업을 각각 자문해주는 투자은행이 제 3자 입장에 서는 다른 투자은행을 고용하여 해당 M&amp;A가 주주의 이익을 잘 대변하는 딜인지 평가하는 공정성 보증 의견의 일부 내용을 공개함</li>
  <li>공정성 보증 의견에는 각각의 시나리오에 따라 어떤 배수를 적용했는지, 어떤 할인 가격을 적용했는지 들의 방법론 설명. 밸류에이션에 관심이 있다른 중요한 참고자료</li>
  <li>딜 발표날짜 이후 언제까지 딜이 성사되지 않으면 시간이 흐를수록 위약 수수료(인수기업 -&gt; 피인수 기업)가 어떻게 되는지도 명시됨. 상황 상 인수가 미뤄지고 있어 방대한 수수료가 발생함에도 딜에 대한 재검토 의견이 없다면 그만큼 딜에 강한 확신과 자금력이 있다는 걸 유추할 수 있음</li>
  <li>인수합병에서 보통주는 단순히 현재 주가에 사들이는게 아닌, 인수자가 제시하는 “인수가격”에 따라 사들이는 구조. 피인수 기업 주주들에게 지분을 넘기도록 유인해야 하기 때문에 보통 <strong>현재 주가보다 높은 가격(프리미엄)</strong>을 제시</li>
</ul>

<h3 id="212-form-10">2.12 Form 10</h3>
<ul>
  <li>스핀오프로 설립한 새로운 회사가 주체인 공시 자료</li>
  <li>스핀오프는 기업의 성장 잠재력이 큰 부문을 독립시켜 자율성과 효율성을 높이는 구조로, 스핀아웃과 달리 기존 기업과의 자본관계가 유지되고 기존 주주가 신설 법인의 주식도 배분받기 때문에 주주가치가 증대됨. 이러한 구조는 장기적인 성장성과 수익성 향상에 대한 신호로 받아들여져 주가 상승으로 이어짐
    <ul>
      <li>리츠 회사에 대한 법인세 면제 조항이 무효화 되며 부동산 관련 부문을 독립시키는 리츠 스핀오프 열풍은 사그러들었지만 여전히 미국 스핀오프 시장은 활발하며, 스핀오프에 대한 예비 주주들의 관심도도 높음</li>
    </ul>
  </li>
  <li>Form 10을 검색하려면 새로 분사하는 기업명/티커를 알아야하는데, 기존 기업의 IR 측이 발표하는 뉴스를 확인하는 수밖에 없음. Form 10이 공시되면 기존 기업의 IR 사이트에 해당 내용을 발표함</li>
  <li>주요 항목
    <ul>
      <li>스핀오프를 하게 된 배경과 프로세스</li>
      <li>배당금 관련 사항</li>
      <li>분사 기업의 추정 연결재무제표</li>
      <li>회사 재무 상황과 사업 실적에 관한 경영진 의견과 분석</li>
      <li>분사 후 각 기업의 새로운 경영진 소개</li>
    </ul>
  </li>
  <li>추정 재무재표에는 독립되는 회사가 처음부터 모기업으로부터 독립한 별개 사업 주체였다면 과거 재무 상황이 어땠을지 계산한 내용이 나옴</li>
  <li>분사한 회사를 어떻게 운영하고 얼마만큼 새로운 가치를 실현하여 주식에 반영될지에 대한 상세 분석이 있으나, 경영진 입장에서의 설명이므로 주관적임을 감안해야 함</li>
  <li>주가의 향후 방향성에 대한 확실한 자료는 공시뿐이므로 공시를 읽고 이해한 다음 이를 투자에 적용하는 훈련이 필요함</li>
</ul>

<h2 id="3-섹터별-재무제표-읽기">3. 섹터별 재무제표 읽기</h2>

<h3 id="31-재무제표를-본다는-것">3.1 재무제표를 본다는 것</h3>
<ul>
  <li>기업 공시에 나타난 재무적 성과 지표를 제대로 본다는 것은 뛰어난 기업을 골라낸다기 보다는, 투자하기 좋지 않은 기업을 가려낼 가능성을 높이는 것
    <ul>
      <li>부실한 재무 상태를 숨기고 있는지, 경영진이 제시하는 기업 전략과 성장 예상치가 현재의 재무/영업 상황 대비 얼마나 현실적인지 등</li>
    </ul>
  </li>
</ul>

<h3 id="32-싼-주식과-비싼-주식">3.2 싼 주식과 비싼 주식</h3>
<ul>
  <li>‘싸게 사서 비싸게 팔아라’는 말은 차트를 보며 저점 타이밍에 매수해 고점으로 보이는 변곡점에 매도하는 기술적 매매가 아닌, 가치와 가격의 관계를 이해하고 그 균형이 기울어지는 순간 매수 매도 결정을 내리는 것</li>
  <li>단기간에 나타나는 필연적인 가격과 가치의 갭이 곧 수익실현의 기회
    <ul>
      <li>가격 &lt; 가치 : 싼 주식</li>
      <li>가격 &gt; 가치 : 비싼 주식</li>
    </ul>
  </li>
  <li>비싸다는 것은, 본인이 상품 가치를 충분히 인정하고 소비욕구가 있는 상태에서 본인이 인정하는 가치 대비 지불해야 하는 가격이 높은 것
    <ul>
      <li>현재 주가에 이미 미래 가치가 반영된 상태라면 그 가치를 실현해도 그 수준에 머물고 실현 못할 시 오히려 하락하므로 비싼 주식임</li>
    </ul>
  </li>
  <li>주식이 싸다면 시장이 기업 가치를 알아보지 못하고 있거나 기업 가치에 도달하는 것을 방해하는 기업 자체 문제 혹은 외부요인이 있다는 것</li>
  <li>가격이 실제로 확인 가능한 절대적인 숫자인 반면에 가치는 그 기준이 획일적이지 않아서 중점을 두기 쉽지 않으나, 자신만의 적정 가치를 정립해야 내가 싸게 사는지 비싸게 사는지에 대한 기준이 정해짐</li>
  <li>해당 주식이 같은 섹터 내 경쟁 기업 주식 대비 싸거나 비싼지 확인해보는 방법도 있음
    <ul>
      <li>현재 주가를 반영한 기업 가치(EV=시총+순부채=회사인수금액)를 향후 12개월 후의 실적을 추정한 EBITDA로 나누면 EBITDA 배수(=트레이딩 멀티플) 산정 가능
        <ul>
          <li>시총 : 주식의 현재 가격에 발행 주식 수를 곱하여 계산되는 시가총액</li>
          <li>EBIT : 이자, 세금 차감 전 이익. 감가상각비, 무형자산상각비가 반영되어 있어 설비투자비용이 크게 소요되는 섹터의 기업들의 수익지표로 적합</li>
          <li>EBITDA : EBIT와 달리 감가상각비, 무형자산상각비를 차감하지 않은 영업이익. 기업의 실제 수익 창출 능력을 평가하는 지표로 사용</li>
          <li>영업이익(Operating Income) : 매출에서 제품원가와 일반 판매비용과 관리비용을 차감한 금액. 본업에서 발생한 이익만 계산하며 영업외수익/비용은 포함하지 않음</li>
          <li>트레이딩 멀티플은 적정가치를 평가한 결과값이 아닌 실제 시장 가격을 기반으로 한 각 기업의 주가 배수. 투자 사이트나 증권사 컨센서스에서 흔히 보는 주가 배수임</li>
          <li>밸류에이션 멀티플은 가치 평가 대상인 기업과 유사한 기업들의 트레이딩 멀티플 평균값에다 애널리스트 재량에 따라 대상 기업의 성장성, 경쟁 우위 등을 반영해 적용하는 가치 배수</li>
          <li>실제 매출을 기준으로 계산하면 트레이딩 멀티플, 미래 EBITDA에 배수를 곱해 가치 추정할 때는 밸류에이션 멀티플
            <ul>
              <li>추정 EPSx12x = 추정 주당 가치. EPS는 주당순이익의 약자로, 기업의 연간 순이익을 발행주식수로 나눈 값</li>
              <li>추정 EBITDAx8x = 추정 기업 가치</li>
              <li>위에서 12x, 8x가 가치 배수임</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>주가배수 대비 가격에 대한 명칭
        <ul>
          <li>업계 평균 대비 낮은 배수에서 거래하는 주식 : Trading below market, Trading below sector average, Trading at a discount</li>
          <li>업계 평균 대비 높은 주가 배수인 주식 : Trading above market, Trading above industry average, Trading at a premium</li>
        </ul>
      </li>
      <li>트레이딩 멀티플은 비교 그룹 내 상대평가 잣대가 될 수 있지만 이는 실제 시장 가격을 기반으로 한 수치일 뿐 해당 배수가 상대적으로 낮거나 높은데에는 여러 요인이 있을 수 있으므로 큰 그림을 봐야 함
        <ul>
          <li>유사 기업과 비슷한 자본구조, 비슷한 규모의 기업 가치인데 미래 EBITDA 기대 성장률이 너무 높아 배수가 낮은 것이라면 싼 주식이라 할 수 있음
            <ul>
              <li>자본구조 : 필요한 자산을 어떻게 조달했는지. 자기자본과 부채의 비율</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>PER(주가수익배수) = P/E
    <ul>
      <li>주가 ÷ 주당순이익(EPS) = 주식투자자들이 손익분기점에 도달하는 기간</li>
      <li>주당순이익은 해당 기업이 매년 달성하는 예상 순이익 금액</li>
      <li>화폐의 시간가치나 기업의 성장 등 다른 요소를 고려하지 않은 단순 가정으로, P/E 배수는 상대적으로 봐야만 의미가 있음. 단, 비교를 하더라도 나머지 가치 요인들이 있으므로 그것만으로 더 싼 주식인지 판단하기는 힘듦</li>
      <li>이를 위해 기업마다 각각 다른 성장성을 표준화한 주가 배수가 PEG(주가수익성장률). 기대 성장률 차이를 P/E에 적정 수준으로 반영하고 있는지 판단하기 위해 사용됨
        <ul>
          <li>PEG = P/E ÷ (EPS 성장률 x 100)</li>
          <li>여기서 성장률은 향후 3~5년 연평균 기대 성장률을 말함</li>
          <li>이는 P/E가 높은 성장주에 유리한 지표</li>
          <li>이론적으로 PEG가 1.0 이하인 기업은 투자 적격 대상, 0.5 이하인 주식은 적극 매수라고 함</li>
          <li>그러나 EPS 기대 성장률이 높고 현재 주가수익률(EPS ÷ 주가 = P/E의 역수)이 낮다면 낮은 PEG만 보고 주식을 구매하는 건 현실적으로 지속되기 힘든 예상 고성장률만 믿고 손해를 보는 것과 다를바 없음</li>
          <li>또한 EPS 성장률이 중요한 자본 지표 중 하나인 기업의 잉여현금흐름(EBIT 같은 회계상의 영업이익에서 세금과 투자비용을 뺀 실제 손에 쥐는 현금) 창출 능력을 대변하지 못한다는 문제점이 있음
            <ul>
              <li>EPS 산출에 사용되는 순이익은 모든 비용을 다 뺀 회계상의 최종 이익으로, 실제로 기업이 쓸 수 있는 현금과는 차이가 있을 수 있음. 예를 들어 순이익에는 감가상각비가 반영되지만, 실제로는 투자할 때 한꺼번에 현금이 빠져나감</li>
              <li>PEG가 낮아도 잉여현금흐름 비율이 너무 낮으면 저평가된 주식이라 보기 어려움</li>
              <li>결국 기업의 종합적 요소를 고려하기 위해 재무제표와 기업 공시를 참고해야 함</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="33-소비유통주">3.3 소비유통주</h3>
<ul>
  <li>경제위기에 상대적으로 영향을 덜 받고 방어주 역할도 하면서 필수소비재로 취급받는 섹터</li>
  <li>식품 리테일
    <ul>
      <li>오래전 성숙기에 접어들어 경쟁이 심하며 보통 GDP 성장률을 따르지만 코로나19발 경기침체 때는 GDP 성장률과 반대로 급성장</li>
      <li>가장 주목해야 할 수익성 지료는 동일 매장 매출, 동일 매장 매출 성장률, 매출총이익, 매출총이익률</li>
      <li>동일 매장 매출 : 유통업에서 빈번한 매장 인수합병, 리모델링, 폐점, 신규개장 등의 변동성을 제외한 동일 매장 기준 매출 성장률을 추산할 때 사용. 실질적 실적 지표로 공시에서 총매출 성장률보다 주목해야 함</li>
      <li>매출총이익 : 유통 업계에서는 총매출에서 상품 유통비용을 차감한 금액. 유통비용에는 공급자에게 상품을 받는 원가, 상품을 자사 물류센터나 최종 리테일 지점까지 운반하는 비용, 재고 물량, 가격 할인과 프로모션, 기타 수입 비용 등이 있음</li>
      <li>해당 섹터 내 주요 주식은 앨버트슨, 크로거, 월마트, 타깃 코퍼레이션, 코스트코 등</li>
      <li>같은 섹터 내에서도 사업 모델이 다를 수 있음. 코스트코는 회원제로 대량 판매한다는 면에서 월마트의 샘스클럽과 유사해보이나, 주식을 볼때 가격대와 매장 규모 면에서 월마트, 타깃과 유사해 같은 비교 대상군으로 분류하는 편</li>
      <li>사업 보고서를 볼 때 수치뿐만 아니라 경영진이 설명하는 내용, 주석을 함게 참고해야 함
        <ul>
          <li>예를 들어 월마트는 경쟁사와 비교해 매출총이익률이 떨어지지만 어닝 콜 등 공시 들을 보면 가격 경쟁력을 위한 투자(Price Investment)로 인한 것임을 알 수 있음. 점유율을 높임으로서 보다 더 저렴한 가격 제공을 위한 것으로 기업 재무를 볼 때는 숫자만 보고 판단하는 단편적 비교는 지양해야 함</li>
          <li>반대로 재고관리 실패나 매출원가 증가에 대처하지 못해 이익률이 감소했거나 경쟁사 대비 줄어들었다면 실적발표나 주가에 부정적 영향을 미침</li>
        </ul>
      </li>
      <li>앨버트슨과 크로거는 규모, 수익모델, 가격/상품전략, 배송 서비스 등 여러면에서 가장 유사한 기업으로, 영업과 전략 부문에서 유사한 기업의 주식을 비교할 때는 재무적 성과에 집중하는 게 좋음. 매출 성장과 매출 총이익 성장률, 자본지출 규모, 이자보상배율, 잉여현금흐름 등
        <ul>
          <li>자본지출 : 미래의 이윤 창출을 위해 지출하는 비용. 대체로 장비, 토지, 건물 등의 고정자산이나 설비에 관한 지출</li>
        </ul>
      </li>
      <li>해당 섹터는 저마진 영업이라는 구조적 한계 상 마진 감소에 따른 경영 악화와 EPS 성장 침체가 가장 큰 리스크
        <ul>
          <li>투자를 위한 지출이 지속적 영업마진 악화로 이어지진 않는지 확인</li>
          <li>대부분 노동조합이 있어서 고용비용, 의료복지, 연금 비용 지출이 큼 -&gt; 기업 손익계산서상의 판매 및 일반관리비와 재무상태표 상의 연금부채 관련 항목 주시</li>
          <li>아마존 같은 전국적이고 효율성 높은 배급망으로 식품 유통시장에 진입하는 이커머스 업체로 인한 경쟁 심화도 리스크</li>
        </ul>
      </li>
      <li>자본지출 규모에 따른 투자자본수익률과 잉여현금흐름의 상태를 이해해야함</li>
    </ul>
  </li>
  <li>주주 주성 확인
    <ul>
      <li>IPO한지 얼마 안된 기업일수록 주주 구성을 살피는게 매우 중요. 특정 대주주가 기업 지분을 다량 보유해 일반 주주가 보유한 주식 가치를 희석할 가능성이 있음</li>
      <li>IPO 이후 내부자가 일정기간 동안 자사주를 매각할 수 없는 IPO 록업 기간은 90~180일 사이로, 이 기간이 지난 뒤 주식을 대량 매각하는 경우가 있음
        <ul>
          <li>IPO 이전에 자금조달을 위해 사모펀드 등 스폰서 기업들에 다량의 주식을 매각할 수 있으며 대량 매도 물량이 시장에 한꺼번에 풀릴 경우 얼마 안되는 나머지 주식 가격은 쉽게 무너짐</li>
          <li>스폰서 기관이 보유 지분을 계속 유지하는 경우에도, 주식 대부분이 스폰서 지분으로 묶여있으면 공개시장에서 유통되는 주식 비율이 너무 낮아 유동성 문제가 생김</li>
          <li>유동성이 낮으면 매수·매도 주문이 조금만 들어와도 주가가 크게 출렁이며 시장가 주문 시 원하는 가격에 체결이 어려운 문제 등이 있음</li>
        </ul>
      </li>
      <li>IPO 이후 변화는 분기 실적 리포트 10-Q, 연간 사업 보고서로 확인하고 공시 전 현재 시장에서 거래되는 주식의 유동성을 확인하려면 주식사이트에서 시장지표 확인
        <ul>
          <li>Shares Float, Free Float : 회사가 발행한 총 주식 수</li>
          <li>Shares Outstanding : 시장에서 실제로 매매 가능한 주식 수</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="34-성장형-우량주">3.4 성장형 우량주</h3>
<ul>
  <li>S&amp;P 500 지수 비중은 각 기업의 시가총액 크기에 따라 정해지는데, 2010년대 이후 애플, 마이크로소프트, 아마존, 구글 등이 기술 혁신과 수익성 개선으로 시총이 기하급수적으로 증가하며 지수 전체에서 20~30% 이상을 차지하게 됨 -&gt; 미국 주식시장을 대변하지 못하고 사실상 “빅테크 지수”에 가깝게 됨</li>
  <li>펀더멘털과 밸류에이션이 역으로 시장을 쫓는 주객전도 경향이 강한 섹터</li>
  <li>IT 버블기인 1999~2000년에 테크 스타트업은 연속 순손실을 기록하고 초기 사업 모델 콘셉만 있어도 애플에 견줄 시총을 달성 했음
    <ul>
      <li>밸류에이션을 산정하려면 ‘기준’이 필요함. 이익도 없고, 비즈니스 모델도 안정되지 않은 기업은 PER, PBR, EV/EBITDA 같은 밸류에이션 기준이 적용 자체가 불가능하거나 의미가 없음</li>
      <li>이때 펀더멘털(실적, 매출 같은 기업의 본질적인 가치)은 주가와 아무런 상관이 없어짐. 도박과 다를바 없음</li>
      <li>최근 기술주 밸류에이션 급상승은 이를 뒷받침하는 성숙기에 접어든 비즈니스 모델과 영업실적이 있으므로 버블이라 보긴 힘듦</li>
    </ul>
  </li>
  <li>단일한 수익 채널에 의존하던 과거와 달리, 최근의 대표 기술주들은 규모의 경제를 이루고 수익 채널을 다각화한 플랫폼 기반 사업 모델로 전환해 수익구조를 안정화함
    <ul>
      <li>구글은 유튜브내에서도 광고 수익, 프리미엄 구독 수입, 유튜브 TV 등으로 다양한 수익 채널을 만들어 옴. 클라우드 컴퓨팅과 자율주행 기술에도 공격적으로 투자중</li>
      <li>마이크로소프트는 소프트웨어 메인사업에 머물지않고 클라우드 사업에 적극 진출하여 수익 모델 업그레이드</li>
      <li>아마존 역시 주력인 이커머스 사업 외에 오프라인 매장, 광고 사업, 구독 사업, 아마존 웹 서비스 AWS 등으로 다수의 수익 채널 확장</li>
      <li>다각화된 수익 채널이 특정 사업 부문에 대한 하락세를 방어해주기 때문에 주가 안정성이 확보됨</li>
    </ul>
  </li>
  <li>수익채널 다각화에 따라 사업 부문별로 개별실적을 발표하며 부문별 수익구조에 따라 실적/가치 평가 방법이 다름
    <ul>
      <li>10-K나 연간 보고서에서도 부문별로 나뉜 공시를 확인할 수 있지만 Financial Supplement 공시에서 사업을 더 세분화하여 실적을 보여주기에 투자자가 사업 성장성과 수익 모델을 이해하기에 더 좋음</li>
      <li>해외 매출 비중이 큰 사업은 달러 환율의 영향을 많이 받으므로 전분기와 당기 실적 비교 시 환율 변동 효과를 제거한 수치를 봐야함 : Constant Currency, F/X Adjusted, Comparable, Excluding F/X 등의 조정 수치 참고</li>
    </ul>
  </li>
  <li>사업 부문별 성장 요인과 가치 창출 요인이 상이할 경우 각 부문을 개별 평가한 후 통합하는 SOTP 방식이 주로 활용됨
    <ul>
      <li>부문별 평가가치 총합 - 전사적 비용 = 기업 가치</li>
      <li>기업 가치 - 순부채 = 주주 가치</li>
      <li>주주 가치 ÷ 발행주식 총수 = 적정 주가</li>
    </ul>
  </li>
  <li>개인 투자자 입장에서, 시장 참여자(증권사 애널리스트 등)가 평균적으로 예상하는 수치인 컨센서스 수치를 기준으로 미래 실적을 예측하고 밸류에이션을 하는 것이 현실적</li>
  <li>컨센서스를 바탕으로 사업 모델을 이해하며, 적정 주가(가치)를 계산하고 시나리오 별로 바뀌는 주가를 예측
    <ol>
      <li>비즈니스 모델의 이해
        <ul>
          <li>구글이 공시 목적으로 구분하는 사업모델 3가지
            <ul>
              <li>구글 서비스 : 광고 수익을 창출하는 채널로 구글서치, 유튜브, 구글 네트워크로 구분</li>
              <li>구글 클라우드</li>
              <li>기타 사업 : 아직 R&amp;D 단계이거나 상품을 상용화하지 않은 시장 초입 단계인 외부사업에 구글이 투자하고 수익을 얻는 사업</li>
            </ul>
          </li>
          <li>각 사업 모델과 수익구조가 전혀 다르므로 매출 성장세 ,영업마진, 투자이익률도 구분해서 이해</li>
          <li>단순 연결재무제표상의 손익계산서는 매출이 하나의 수치로 통합되어 나오므로 제무제표상의 각 항목을 세부적으로 구분하고 설명해주는 10-K의 MD&amp;A 섹션 참고. 10-Q에도 사업 부문별 손익 업데이트 있음</li>
        </ul>
      </li>
      <li>사업 부문별 매출, 영업이익 추정
        <ul>
          <li>구글 기업 공시에서 가장 세분화한 구분인 6개 사업 부문별로 각각 다른 성장률을 적용하여 향후 1년 매출과 EBITDA 추정
            <ul>
              <li>이때 필요한 매출총이익, 영업비용, 영업마진(매출 중 얼마가 이익으로 남았는지 = 영업이익 ÷ 매출) 등은 가이던스나 어닝 콜에서 경영진이 꽤 자세히 설명해주므로 대략적인 추정치를 알 수 있음</li>
              <li>EBITDA = 영업이익 + 감가상각비</li>
              <li>영업이익 = 매출총이익 - 영업비용 또는 영업마진 × 매출</li>
              <li>매출총이익 = 매출 − 매출원가(소모된 재료비, 인건비 등)</li>
              <li>감가상각비는 10-K, 10-Q 등의 공시자료에서 확인. 보통 매출 대비 감가상각비 비율이 일정한 편</li>
            </ul>
          </li>
          <li>추정한 EBITDA 값에 밸류에이션 멀티플 적용. 밸류에이션 멀티플은 사업 모델이 비슷한 유사 기업, 동종 및 타 업계 경쟁사들의 현재 트레이딩 멀티플 참고. 비교군의 평균이나 주관대로 정함</li>
          <li>구글 서치, 네트워크, 구글 플레이 같은 사업은 이미 안정화되었고 수익(영업이익, EBITDA) 변동도 크지 않기 때문에 미래의 현금흐름을 비교적 예측하기 쉬움. 따라서 EBITDA와 기업 가치(밸류에이션 멀티플) 적용해서 사업 부문별 가치 계산 가능</li>
          <li>유튜브는 성장률이 훨씬 더 높고 수익 모델 자체가 계속 진화하여 EBITDA 추정하기 어려움. 이 경우 많은 테크 스타트업 처럼 추정 매출과 매출 배수만 적용하여 사업 가치 계산
            <ul>
              <li>EBITDA 추정하려면 EBITDA 배수, 마진 등이 필요한데 해당 수치들이 변동성이 높으면 불확실성만 높아짐</li>
              <li>여기서 EBITDA 배수, 매출 배수 등 밸류에이션 멀티플은 1년 예상 수익같은게 아니라 해당 기업/사업의 가치를 반영해 더 점수를 매기기 위해 적용하는 배수</li>
              <li>유튜브는 보는 사람마다 가치평가의 차이가 큼. 현재 애널리스트들은 9x에서 12.5x까지도 적용</li>
            </ul>
          </li>
          <li>구글 클라우드 사업 역시 성장하는 단계이므로 매출과 매출 배수만 적용하여 사업 가치 계산</li>
          <li>기타 사업들 중 대표적으로 웨이모는 당해 투자금액에 유사한 기업인 GM 크루즈의 밸류에이션 배수 적용, 나머지는 경영진이 가끔 컨퍼런스 콜 등에서 언급한 금액 참고</li>
        </ul>
      </li>
      <li>기업 전사적 비용 추정 및 기업 가치 선정
        <ul>
          <li>세일즈와 마케팅 비용, G&amp;A, R&amp;D, 기타 인건비나 장비 구입 비용 등 사업 부문별 마진을 통해 반영된 금액 외의 현금성 비용이 존재함</li>
          <li>Unallocated Costs, Unallocated Corporate Expenses라고 표현되며 공시에 반드시 따로 기재됨</li>
          <li>애널리스트들은 이런 비용 추정 시 경영진에서의 콘퍼런스 콜(어닝 콜에서 자주 등장하는 질문)에서 물어보거나, 경영진이 제시한 비용에서 추가로 감안하거나, 전체 매출에서 비율로 책정. 확실하게 추가로 지출될 것으로 보이는 법무비용 등이 생기면 반영해서 조정</li>
          <li>추정한 전사적 비용에 EBITDA 배수 등을 참고하여 밸류에이션 멀티플 적용, 사업 부문별 평가가치를 총 합산한 값에서 차감하여 기업 가치 선정</li>
        </ul>
      </li>
      <li>재무상태표에서 부채와 현금 계산
        <ul>
          <li>주주 가치는 총 기업 가치에서 순부채를 차감한 수치. 순부채 계산을 위해 기업의 총부채 금액, 현금 및 현금성자산 금액을 알아야 함</li>
          <li>올해 회계연도 말 예상 총부채와 현금성자산 금액을 계산해줘야 함
            <ul>
              <li>10-K 또는 10-Q 공시에서 현재 재무상태표상 현금(Cash and Cash Equivalents)에서 예상하는 현금흐름을 고려하여 연말 기준 현금보유 수준 추정
                <ul>
                  <li>우선 올해 남은 기간동안 창출 가능한 순이익 합계에 각종 비현금 비용(감가상각비, 스톡옵션 지급 비용 등 현금 아닌 회계상 비용)을 더하고 운전자본 변화로 생긴 추가 현금성비용(빌린 돈)과 지출을 반영하여 연말까지의 영업현금흐름 구함</li>
                  <li>자본지출 규모(올해 매출의 n% 투자 예정)를 확인하고 올해 남은 기간까지의 자본 지출 규모 추정. 그외 부채 상환 비용(Debt securities and maturity schedule, 분기별로 투명하게 공개됨), 자사주 매입 비용 등을 앞서 구한 영업현금흐름에서 차감</li>
                  <li>마지막으로 유가증권(Marketable Securities) 보유액 합산</li>
                  <li>총 부채를 나타내는 Long-term Dept 확인</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>주주가치와 적정 주가 계산
        <ul>
          <li>(기업 가치 - 총 부채 + 현금성 자산) ÷ 총 주식발행 수 = 적정 주가</li>
          <li>미국 애널리스트 리포트나 뉴스 기사에 등장하는 Implied Equity Value, Intrinsic Share Price가 이런식으로 산정한 적정 주가를 말함</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>5분 만에 추정하는 적정 주가
    <ul>
      <li>관심 기업의 티커를 미국 주식 사이트에 검색 -&gt; Analysis 탭으로 이동 -&gt; 애널리스트들이 평균적으로 추정한 주당 가치 (EPS)를 확인. 가치평가를 하려면 연 단위 EPS를 확인해야 함</li>
      <li>다음으로 티커와 함께 ‘PE multiple’ 혹은 ‘PE Ratio’를 포털 사이트에서 검색하여 P/E 배수 그래프로 추이 확인</li>
      <li>내년 해당 기업 컨센서스 EPS x 해당 기업 평균 주가 배수(P/E) = 적정 목표 주가. 주가 배수는 시기를 고려하여 가감하여 적용</li>
      <li>나의 기대수익률을 기준으로 내가 생각한 수익률이 얼마나 현실적인지 점검하는 법
        <ul>
          <li>기대수익률이 적용된 목표 주가를 현재의 추정 EPS(내년 EPS) 기준으로 주가 배수 역산(=Implied Multiple).</li>
          <li>그리고 그 목표 주가를 주식사이트에서 확인한 애널리스트 추정 EPS의 최댓값, 최솟값을 기준으로 주가 배수 역산. 내 기대 주가배수가 최댓값, 최솟값 사이에 있다면 내가 생각한 기대수익률과 목표 주가가 어느정도는 타당하는 것을 확인할 수 있음</li>
        </ul>
      </li>
      <li>많은 가정과 변수가 생략된 단편적인 방법이라 허점이 많으며, 도출해낸 값보다 그것을 해석하는 것이 훨씬 더 중요함</li>
    </ul>
  </li>
  <li>컨센서스와 밸류에이션은 시장 또는 개별 기업의 상황에 따라 얼마든지 바뀔수 있으며, 시장에서 항상 가격이 가치에 수렴하진 않음. 적정가치를 숫자 하나로 보는 것보다, 그 숫자가 나오게 된 배경(시장·기업에 대한 분석)을 스스로 파악하고 주가가 어떻게 움직일지 판단하는 훈련이 필요
    <ul>
      <li>컨센서스(여러 애널리스트들이 추정한 수치들의 평균값)를 형성하는 주요 변수들 : 시장과 기업 성장에 관한 가정, 수익 모델, 경영진이 가이던스에서 제시한 대로 기업을 이끌어가는 실행력, 가치 산정에 쓰인 유사기업 주식의 밸류에이션과 시장 프리미엄 등 시간에 따라 변화하는 여러 변수들</li>
    </ul>
  </li>
</ul>

<h3 id="35-호텔주">3.5 호텔주</h3>
<ul>
  <li>미국 호텔 산업은 호텔 건물이라는 유형자산이 아닌 호텔 브랜드(프랜차이즈)라는 무형자산을 운영하는 사업 모델, 호텔을 직접 소유한 주체는 호텔 리츠라는 부동산 회사 형태로 따로 분류해 상장되어 있음</li>
  <li>가장 중요한 사업 지표 : 객실당 매출(RevPAR, 객실 점유율 + 객실 단가). 해당 지표의 연도별 추이, 경쟁사 대비 상대적 성장률에 주목</li>
  <li>글로벌 단위의 프랜차이즈 운영을 하고 있어 ‘system-wide’(전사적 수치), ‘comparable’(리모델링/재개발 등으로 연중에 운영 못한 호텔/객실 수를 제외한 전기와 당기 간 비교 가능 수치) 표기가 들어간 실적 지표를 봐야 기업의 전체 운영 실적을 알 수 있음
    <ul>
      <li>ex : System-wide Revenue, System-wide EBITDA, Comparable Revenue..</li>
    </ul>
  </li>
  <li>호황기 때는 수혜를 많이 받지만 불황기에는 직격탄을 맞는 섹터</li>
  <li>chainscale(호텔 브랜드 등급)에 따라서도 타격과 회복 속도에 큰 차이가 남. 고가 브랜드(Luxury, Upper Upscale) 호텔이 경기에 가장 민감하고, 중저가 브랜드(Economy, Midscale) 호텔은 상대적으로 충격이 덜하며 회복 속도도 빠름
    <ul>
      <li>투자 시 대상 기업이 어떤 chainscale에 속하는 호텔브랜드를 각각 어느 비중으로 운영하는지 살피는 것이 중요</li>
    </ul>
  </li>
  <li>호텔 브랜드 기업의 성장 모델은 프랜차이즈 수익 확대에 있음. 가맹 호텔 개수 증가율 지표는 NUG(Net Unit Growth)</li>
  <li>미국 호텔 기업은 전체 포트폴리오를 Owned &amp; Leased 부문(호텔 자산 소유/임대하는 사업)과 Managed &amp; Franchised 부문(운영 및 프랜차이즈 사업)으로 분리해 공시. 각기 다른 매출, EBITDA, 영업마진 등을 각각의 수익 모델과 상황에 맞게 이해하고 분석해야 함
    <ul>
      <li>Revenues(수익) : Franchise and Licensing Fees, Owned and Leased Hotels..</li>
      <li>Expenses(비용) : Owned and Leased Hotels(운영 하는 호텔의 지출비용. 개별 호텔 직원 고용비, 식음료비, 청소비, 물품비, 건물관리비), General and administrative(그룹 차원에서 쓰는 마케팅, 호텔 경영진 월급, 호텔 프랜차이즈 플랫폼 운영비, IT 비용 등)</li>
    </ul>
  </li>
  <li>기업이 고정비와 변동비를 어떻게 구성하느냐에 따라 영업 레버리지가 달라짐. 고정비 비중이 큰 사업을 영업 레버리지가 높다고 표현하며 호황이면 영업이익률 증가가 매출 성장률보다 크고 반대로 불황으로 매출이 떨어질때는 영업이익 감소폭이 더 큼
    <ul>
      <li>영업 레버리지 : 매출 변화에 따라 영업이익이 얼마나 민감하게 반응하는지</li>
      <li>고정비 : Managed &amp; Franchised 부문에서 이미 구축한 IT 시스템, 본사 사무실 운영비. Owned &amp; Leased 부문에서 호텔 건물에 대한 호텔 자산 개발비, 자본투자비, 부동산 유지 관리비 등</li>
      <li>변동비 : Managed &amp; Franchised 부문에서 마케팅, 세일즈 비용. Owned &amp; Leased 부문에서 이용고객 증가에 따른 식음료비, 청소비, 객실관리비, 전기세, 호텔스태프 인건비, 물품비 등</li>
    </ul>
  </li>
  <li>호텔 사업의 경우 프랜차이즈보다 호텔을 직접 소유 운영하는 사업의 영업 레버리지가 훨씬 큼. 따라서 투자자는 호텔의 전체 사업에서 영업 레버리지가 높은 직접 운영 사업 비중이 얼마나 큰지, 프랜차이즈 사업 규모와 성장률이 그를 상쇄할 만한지 등을 따져봐야 함
    <ul>
      <li>경기불황에 버틸 수 있는 사업구조인지, 경기 회복 시점에 어떤 기업이 더 빠르게 반등 가능한지 등</li>
    </ul>
  </li>
  <li>호텔 리츠의 경우 지역별 호텔 자산(건물) 분포를 파악하는게 중요. 자산 입지 별로 수익 편차가 큼. 호텔 수요가 집중된 미국 대도시가 경기침체기에 특히 더 취약함</li>
</ul>

<h3 id="36-리츠주">3.6 리츠주</h3>
<ul>
  <li>모기지 리츠, 주식 리츠(임대 사업을 하는 부동산 회사 주식)</li>
  <li>채권과 유사한 경향을 보임. 기업 가치 성장은 다른 섹터 보다 낮은 편으로, 리츠 기업을 볼때 중요한 것은 사업을 지속하게 하는 부동산의 순자산가치와 배당 가능한 안정적인 현금흐름</li>
  <li>미국 리츠협회가 정의하는 리츠의 자격 요건은 기업이 소유한 자산의 75% 이상이 부동산이고 총수입의 75% 부동산 임대수익, 모기지나 부동산 매매로 구성되어야 함. 또한, 과세소득의 90% 이상을 주주에게 배당해야 함</li>
  <li>리츠 기업은 법인세를 내지 않으나 리츠주 배당금은 일반소득으로 구분되어 주주들은 본인 소득구간에 맞는 소득세를 냄</li>
  <li>리츠가 배당금을 정하는 기준은 당기순이익이 아닌 조정 운영수익이라는 수익지표
    <ul>
      <li>리츠의 운영수익(FFO) = 당기순이익 + 감가상각비 - 자산 매각으로 얻는 이익 + 자산 매각으로 얻는 손실 + 감액손실</li>
      <li>운영 조정수익(AFFO) = FFO - 반복적 자본지출 = 배당가능자금</li>
      <li>이 리츠가 매달 부동산 굴려서 현금 얼마나 잘 벌고 있나를 보는 것으로 정상적이고 일상적인 영업활동에서 발생한 수익만 산정함. 따라서 일회성 비용(자산 매각으로 얻은 이익, 손실)과 일상적인 영업활동과 무관한 비용(건물 가치 하락으로 인한 손실)은 모두 제외함</li>
      <li>감가상각비 = 건물이나 부동산 같은 고정자산의 장부가치를 매년 조금씩 비용으로 나누어 반영하는 것. 그러나 리츠에서 부동산은 시간이 지난다고 사업가치가 사라지는게 아니므로 오히려 더해줌</li>
    </ul>
  </li>
  <li>실적 발표마다 공시하는 AFFO 성장률과 배당지급비율 확대/축소/유지 상황에 주목해야 해당 리츠의 배당성향 파악 가능</li>
  <li>당기순이익을 대신해 AFFO를 보므로 EPS 대신 주당 AFFO를, P/E 대신 P/FFO, P/AFFO를 주가배수로 참고해야 함</li>
  <li>NOI는 전체 임대수익에서 부동산 관련 경비를 차감한 수치로 부동산 운영수익을 나타냄. 리츠주의 실적을 발표할 때 관건은 FFO, AFFO 성장률을 비롯데 NOI 성장률, NOI 마진이 얼마나 개선되었는지</li>
  <li>NOI 수치를 자본환원율로 나누면 리츠의 전체 부동산 가치, 여기서 부채를 차감하면 순자산가치가 됨</li>
  <li>임대수익은 임차인의 월 임대료를 꾸준히 지불할 수 있는 재정능력에 달려있으며, 리츠 사업 보고서에 있는 임차인 프로필로 현금 능력, 신용등급 확인 가능
    <ul>
      <li>임대료 감당률 = (EBITDA + 임대료) ÷ 연간 임대비용 = 몇 년 동안 임대료를 낼 만큼의 현금을 보유하고 있는지</li>
      <li>EBITDA는 임대료가 차감된 영업이익이므로 다시 더해주는 것</li>
      <li>임차인의 신용등급이 BBB 이상인 경우가 다수이면 안정적</li>
      <li>임대료 감당률을 보고 받지 못하거나 신용등급을 알 수 없는 리츠주는 투자 위험도가 높음</li>
      <li>임차인이 사업별로 얼마나 고르게 분포되어있는지 확인하는 것도 중요. 편의점, 약국, 대형 할인마트 등 경기와 무관한 필수소비재 관련 사업주가 임차인 구성의 주를 이루는 것은 강점. 그렇지 않은 임차인들은 어떤 식으로 임대료를 지급받고 어떻게 미지불 임대료 협상을 진행하는지 모니터링 필요</li>
    </ul>
  </li>
</ul>

<h2 id="4-미국-주식-특수-상황별-체크리스트">4. 미국 주식 특수 상황별 체크리스트</h2>

<h3 id="41-ma-종목-투자-시">4.1 M&amp;A 종목 투자 시</h3>
<ul>
  <li>영업 모델이 건실하고 시장 확대가 예상되며 재무 건전성이 좋으나 주가가 회사와 무관한 대외적 악재로 하락한 경우 매력적인 인수 합병 타깃</li>
  <li>미국에서는 매년 최고치 영업이익과 현금 보유금을 경신하며 잉여 현금, 높은 주가 배수를 자랑하는 기업이 많아 중장기 성장 동력을 위해 M&amp;A를 적극 활용함</li>
  <li>인수 주체는 같은 섹터 내 유사 기업 또는 사모펀드나 헤지펀드 같은 재무적 투자자인 경우도 있음. 미국에서는 평균 15~30% 인수 프리미엄을 붙여 인수금을 제시함</li>
  <li>M&amp;A 대상이 될 법한 주식에 투자할 수 있는 정보가 공시자료에 충분히 제공되기에 인수 대상 물색/딜을 진행하는 관점은 기관투자자와 개인투자자가 크게 다르지 않음</li>
  <li>인수 기업, 피인수 기업이 둘다 상장 기업인 경우 두 기업 간의 주가 배수 차이는 딜 성사 가능성을 알아내는 방법 중 하나. 최근에 격차가 많이 벌어진 경우 등</li>
  <li>개인투자자는 공시자료에서 인수 가격, 인수 대금 지급 형태, 인수 성사 조건, 딜이 성사되지 않을 경우 피인수 기업에 주는 위약 수수료 등을 확인하여 주주에게 얼마나 유리한 딜인지를 파악해야 함 (Preliminary Proxy, Definitive Proxy, DEFM 14A 확인)
    <ul>
      <li>100% 현금 인수일 경우 피인수 기업 주주들의 주식은 정해진 가격으로 강제 매각됨. 거래 대금 지급 방식에 주식 양도가 포함되어 있으면 주식 교환비율(현금 대비 주식 배율)에 맞춰 일부를 인수 기업 주식으로 할당 받음</li>
      <li>검색 키워드 : Closing Conditions, Condi-tions to the Merger, Termination Fee, Break-up Fee 등</li>
    </ul>
  </li>
  <li>M&amp;A 발표 직후부터 딜이 성사되기까지의 차익으로 수익 실현이 가능하나 여러 요인으로 무산되는 경우도 흔함. 개인 투자자는 매도 결정을 위해 공시자료에 있는 인수계약 불이행/재협상 사유, 위약금 등을 확인하여 인수가 어떻게 진행될지를 예측할 수 있음</li>
  <li>인수합병 시 인수/피인수 기업 모두 IR, 8-K 공시 및 보도 자료로 공시되나 스팩과의 합병일 때는 인수 주체가 되는 스팩이 SEC에 의무적으로 공시하는 Form 425 공시 및 8-K 중에서 ‘Entry into a Material Definitive Agreement’ 섹션에서 자세한 내용 확인 가능</li>
</ul>

<h3 id="42-ipo-주식">4.2 IPO 주식</h3>
<ul>
  <li>미국 증시에 IPO 직후 주가가 급등하는 경향이 있어 IPO 시장이 활발함. 단, 시황에 민감하여 철회/무기한 연기되는 경우도 많음</li>
  <li>나스닥 거래소의 IPO 캘린더, 뉴욕증권거래소의 IPO 센터에서 섹터 별로 자세한 추이를 확인할 수 있음</li>
  <li>헤지펀드, 사모펀드, 연기금 및 기타 대형 기관투자자는 주관사를 거쳐 할인된 가격으로 공모주 매입할 수 있으나 개인투자자 입장에서는 기본 최소 물량 때문에 권장되지 않음. 괜찮은 공모주 물량은 보통 기관투자자 &gt; 개인고액자산가 선에서 마감됨</li>
  <li>개인투자자 입장에서는 상장 후 주가 상승을 기대한다면 콜 옵션을 매수하거나(공모가 밑으로 하락시에도 행사안하면 그만), 공모주 투자 인덱스 펀드를 선택하거나, 롱숏 IPO 펀드 유형을 고려할 수 있으나 이 경우는 대부분 운용 수수료가 높음</li>
  <li>IPO 대신 뉴욕거래소/나스닥에 직상장하는 방법도 있음. IPO와 달리 기존 주주의 지분을 주식시장에서 매매 가능한 주식으로 교환한다는 차이가 있었으나, 최근 2020년 개정안에 따라 신주 발행도 가능해져 개인투자자에게도 첫 거래일에 주가 급등에 대한 수익을 낼 수 있는 기회가 주어짐
    <ul>
      <li>2억 5000만 달러 이상 규모여야 한다는 조건이 있으며 형성되는 시가에 요구되는 하한가가 있음</li>
      <li>IPO 보다 훨씬 빠르고 간편하게 기업공개가 가능하나 IPO의 인수 중개 과정을 생략하므로 기업 가치 선정/로드쇼 등으로 잠재 기관투자자에게 주식을 홍보해주는 투자은행의 도움을 받지 못함. 따라서 인지도 낮은 기업은 IPO 형태가 더 유리할 수 있음</li>
      <li>록업 기간 규제를 받지 않아 상장과 동시에 바로 보유 주식을 팔고 나올 수 있으며 투자은행에게 지급하는 자문 수수료가 없어 막대한 비용을 절감할 수 있음</li>
      <li>어느 정도 주가를 지지해주는 기관투자자/투자은행이 없어 변동성이 훨씬 커 리스크가 있음</li>
    </ul>
  </li>
  <li>미국 공모주 투자 시 알아야 할 6가지 날짜
    <ul>
      <li>공모가 산정일(IPO 날짜)</li>
      <li>상장 첫 거래일</li>
      <li>클로징 날짜(기업이 IPO/M&amp;A 등으로 자금 조달 시 해당 주관사로부터 거래 대금을 받은, 실질적으로 딜이 성사된 날)</li>
      <li>록업 기간
        <ul>
          <li>핫한 공모주에 참여해 단기 차익을 노리는 플리핑을 금지하기 위해 IPO를 앞두고 거래/홍보를 제한하는 기간. 통상 90일~180일 사이. 해당 날짜가 지나면 내부자들이 주식을 대량 매도하여 주가가 하락하는 경우 많음</li>
        </ul>
      </li>
      <li>침묵 기간
        <ul>
          <li>기업이 SEC에 공시 자료를 등록한 날부터 SEC에서 해당 공시 자료가 유효함을 승인하고 EDGAR에 공개하는 날까지 (경영진, 주관 투자은행 등 내부자들이) 주식 관련 어떤 의견이나 정보도 발표할 수 없는 기간. IPO의 경우에는 S-1 공시 발표시점부터 상장 이후 주식이 공개시장에서 거래되기 시작한지 40일째가 되는 날까지</li>
          <li>내부자가 편익을 챙길 수 없도록 투자자들을 보호하기 위함</li>
          <li>록업 만료일 전후로도 15일간의 침묵 기간이 있음</li>
        </ul>
      </li>
      <li>매매 제한 기간
        <ul>
          <li>기업 내부자들이 자사주 매매를 할 수 없도록 금지된 기간. 주로 어닝 시즌에 실적 발표 직전 며칠은 내부자들의 매매 금지됨. 해당 기업의 회계분기 말 이후부터 시작</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>개인 투자자에게는 침묵기간 후 애널리스트들이 처음으로 주식에 레이팅을 주는 Initiation Report라는 리서치 보고를 발표하고 이 방대한 투자 의견에 시장이 민감하게 반응하므로 해당 기간이 좋은 매매 기회가 될 수 있음</li>
  <li>IPO 주식은 유통하기 전부터 수요가 몰려 수급 현상 때문에라도 가격이 상승하며, 특정 산업(IT 같은) 밸류에이션 버블까지 가세하면 공모 전부터 주가는 크게 부풀려짐. 따라서 공모가에 매수하는 것도 심사숙고 해야함</li>
</ul>

<h3 id="43-로빈후드의-남다른-ipo">4.3 로빈후드의 남다른 IPO</h3>
<ul>
  <li>미국에서 일반적인 기업들은 예측 불가능한 주가 변동성을 우려하여 기관에만 공모주를 배정하다시피 하지만, 로빈후드는 IPO를 통하여 최종 38 달러(Priced at the low-end = 최종가격)로 자사앱에서 개인투자자들이 공모주의 20~35% 정도 되는 물량을 공모가에 매수할 수 있게 함(Form 424B4)
    <ul>
      <li>사고 싶었는데 못사는 상황이 없어져 오히려 첫날 주가 폭등이 없어짐</li>
    </ul>
  </li>
  <li>S-1에서는 내부자 트레이딩으로 의심되어 SEC가 조사하겠다고 한 내용이 공시됨
    <ul>
      <li>투자자들은 해당 내용을 참고하여 SEC 규제 당국과의 마찰이 과거에도 있었고 앞으로도 있을 것이며, 이런 마찰로 주가에 상당한 규제 리스크가 존재한다는 걸 인지해야 함</li>
      <li>사건 : 레딧에 모인 수백만명의 개미 투자자들이 전통적 기업이 기관투자자에 의해 지나치게 공매도 당하고 있다는 걸 지적 -&gt; 우리가 함께 매수해서 주가를 끌어올리고, 헤지펀드들에게 ‘숏스퀴즈’를 걸자는 집단 운동이 일어남 -&gt; 거래가 한번에 너무 많이 몰려 증거금이 지나치게 많이 필요해지자 로빈후드는 해당 밈주식들을 매매정지 조치함 -&gt; 로빈후드 임직원 일부가 우연히도 해당 주식들을 매매정지 조치가 있었던 1/28일 직전에 매도 -&gt; 내부자 정보에 따른 거래인가?
        <ul>
          <li>공매도 : 주식을 빌려서 지금 비싼 가격에 판 다음, 나중에 더 싸졌을 때 다시 사서 갚는 것</li>
          <li>숏스퀴즈 : 공매도 세력이 빌린 주식을 되사서 갚아야 할 때, 주가가 오르면 손해를 감수하고 더 비싸게 매수해야 하는 상황. 이로 인해 주가가 폭등할 수 있음</li>
          <li>헤지펀드는 “망할 것 같은 기업”의 주가가 떨어질 것으로 보고, 그 하락에 돈을 걸기 위해 공매도를 함</li>
        </ul>
      </li>
      <li>브로커딜러 임직원은 대부분 개별 주식 매매가 전면 금지이나, 개인투자자에 가까운 로빈후드 직원들에게 어디까지 매매 제한을 두어야 하는지 아직 법적 기반이 없음</li>
      <li>로빈후드는 증권사 역할을 하지만 새로 등장한 IT 기반의 브로커딜러에 대한 규제 프레임워크가 아직 완성되지 않아 완성될때까지 마찰이 있을 것이며, 주가에 악영향을 끼치는 건 덤</li>
    </ul>
  </li>
  <li>상장 후 5 거래일째가 되던 날 장이 열리자 28% 이상 주가 폭락
    <ul>
      <li>로빈후드는 IPO 전에 투자자들에게 전환사채(IPO가 끝나면 공모가의 70% 수준”의 낮은 가격으로 주식으로 바꿀 수 있는 권리)를 발행했는데, 이는 이미 S-1과 사업 보고서 등에서 수차례 공시된 내용</li>
      <li>로빈후드는 록업기간을 면제하는 조항을 두어서 상장 첫날부터 주식을 팔 수 있었음</li>
      <li>그런데 로빈후드 초기 투자자들이 약 9,800만 주에 달하는 주식을 매도하게 될 것이라는 뉴스 헤드라인 때문에 주가 희석에 대한 소문이 커뮤니티를 돌게되며 패닉 셀 유발</li>
      <li>결국 로빈후드는 그 다음날 8-K 공시와 보도 자료를 통해 전날 공시된 매도 가능 물량은 초기 투자자들의 전환사채 전환과 기존 록업 조항에 따른 것일 뿐 아직 SEC 승인절차가 남았고 2분기 실적 발표전까지는 해당 물량의 어떤 매도도 없을 것이라는 해명 보고서를 공시함</li>
      <li>이로인해 이튿날 그 주가가 다시 17% 회복됨</li>
    </ul>
  </li>
</ul>

<h3 id="44-스팩주">4.4 스팩주</h3>
<ul>
  <li>IPO와 달리 스팩 인수 건은 별도의 SEC 심사가 이뤄지지 않음. 따라서 IPO 대신 스팩회사로의 인수합병을 진행하면 SEC 규정에 피요한 의무 제출 서류, 세부 공개 절차, 기타 복잡한 규제를 피해갈 수 있음.</li>
  <li>주관사인 투자은행의 실사를 거쳐 밸류에이션 끝에 적정 공모가를 정해 IPO를 하는 일반 기업들과 달리 스팩은 유닛 단가 개념으로 주로 6, 8, 10 달러에 거래가 이루어짐. 밸류에이션 할 대상이 없어 사업 보고서도 기대하기 어려움</li>
  <li>투자자는 스팩 주식을 사면서 인수합병에 투자할 수 있고 정해진 기간 안에 기업 인수가 이뤄지지 않으면 펀드를 청산해 원금을 돌려받을 수 있음. 다만 스팩 공모 단계에서 투자자는 아무런 인수 대상도 없이 스팩을 운영하고 투자처를 발굴하는 사람들에게 투자하는 셈.</li>
  <li>상장으로 조달한 자금의 80% 이상을 사용해 18~24개월 안에 기업을 인수해야 하고 그렇지 못하면 해산되어 투자자는 스팩주 공모가에 투자 원금을 돌려 받음</li>
  <li>스팩이 인수합병을 진행하여 최종 인수 승인까지 받으면 기존 스팩 주식은 1주 당 인수 기업 주식 1주로 전환되며 인수 완료 후에는 정해진 기간,  행사가 등의 조건에 주식을 살 수 있는 Warrent 행사가 가능</li>
  <li>인수 대상 회사의 가치평가 없이 단지 인수 대상 발표 만으로 주가가 2배 가까이 급등하는 경우가 흔했지만 지금은 거품이 좀 꺼짐. 스팩주가 가장 크게 급등하는 구간은 합병 성사가 아닌, 합병 발표 시점이며 스팩주의 업사이드는 원금 보장과 합병에 대한 기대</li>
  <li>합병 발표 이후부터는 해당 기업의 실적과 미래 성장성이 반영된 주가로 거래되고, 여기서부터는 전혀 다른 접근법이 필요</li>
  <li>스팩주는 공모 단계부터 주식과 워런트를 한 쌍의 유닛으로 구성해 상장. 워런트는 “미래에 미리 정해진 가격으로 주식을 살 수 있는 권리”. 보통 IPO 이후 정해진 기간이 지나면 주식과 워런트로 따로 분리되어 각각 따로 사고 팔 수 있어짐
    <ul>
      <li>주가 희석 때문에 주식과 워런트는 1 대 1이 아닌 1 대 3비율과 같이 주어짐. 워런트는 정수 개수만 인정되므로 그만큼 유닛을 더 보유해야 손해를 안 봄</li>
      <li>스팩의 유닛 분리는 반드시 8-K 공시를 선행함. 이 때 해당 공시에서는 감사를 마친 제무제표와 스팩 공모로 조달한 자금을 반영한 자본금 변경 사항까지 나오므로 확인하는 게 좋음</li>
      <li>워런트는 보통 인수합병 성사 후 행사 가능하며 만기일이 지나면 사라짐. 해당 기간 공시 확인 필요</li>
    </ul>
  </li>
  <li>인수합병 과정에서 공시하는 프록시(DEF-14A)를 확인하여 적어도 주요 거래 내용(Key Tran-saction Terms) 섹션 확인하여 인수합병 이후 회사의 기업 가치(Pro-forma Enterprise Value)와 간단한 밸류에이션 지표 확인</li>
  <li>워런트에는 보통 콜 리스크가 있음. S-1, 8-K 확인
    <ul>
      <li>예: “합병 후 주가가 20일 중 10일 이상 $18 이상이면, 회사가 워런트를 30일 내에 행사하지 않으면 무효 처리할 수 있음.”</li>
    </ul>
  </li>
  <li>기초자산(주식)의 가격이 조금만 움직여도 워런트 가격은 훨씬 더 크게 움직임. 워런트 행사가보다 현재 주가가 더 높을때 워런트 가치는 가장 높음</li>
  <li>스팩의 워런트가 지닌 높은 레버리지 효과 때문에 인수합병 발표(주가 오름)나 성사 시점(신뢰가 높아져 더 오름)에 실현할 단기 수익을 노리는 트레이더들도 있음</li>
  <li>스팩 투자에 관심이 있다면 수시로 업데이트하는 스팩주의 공모 현황을 모니터링하고, 스팩을 운용하는 투자 인력과 그들의 투자 과정까지 신뢰할 수 있는지 따져봐야 함</li>
  <li>스팩주는 사모펀드의 블라인드 풀(투자자가 어떤 자산에 투자할지 미리 정확히 알지 못하는 상태에서 전문가에게 돈을 맡기는 펀드)과 유사한 효과가 있지만 사모펀드보다 최소 투자금액이 적고 접근이 쉬우며, 전문가들이 다양한 인수 대상을 고르기 때문에 분산 투자 효과가 있음</li>
  <li>단기로 접근한다면 인수합병 발표 시점을 주목해야 하고, 장기적으로 본다면 인수합병 후 성공적인 상장에 이어 계속 성장할 주식을 스팩 원금가로 싸게 진입한다는 사실에 의의를 둬야 함. 후자의 경우 길게는 2년 이상 투자금을 묶어놔야 함</li>
</ul>

<h3 id="45-주식분할">4.5 주식분할</h3>
<ul>
  <li>주식분할은 말그대로 보유한 1주의 주식이 여러개로 분할되어 가격도 개수도 그만큼 나눠질 뿐 기업의 펀더멘털과는 무관함. 그러나 기업이 주식 분할을 결정할 때 시장의 인식에는 변화가 생김</li>
  <li>기관 투자자 입장에서는 아무런 변화가 없지만 개인 투자자들은 가격 부담 때문에 고려하지 않던 주식의 가격이 1/n으로 줄어들면 더 관심을 보이기 때문에 그러한 심리를 이용해 주가 상승을 기대함. 실제로 애플, 테슬라가 주식 분할을 발표한 직후 주가가 11%, 13% 상승</li>
  <li>그러나 기업가치와 무관한 주가 상승이기 때문에 기업 가치와 상관 없는 이유로 주식을 매도할 가능성이 높은, 기업이 선호하지 않는 투자자들이 유입될 수 있음. 이에 따라 단기성 자금이 몰리며 변동성이 높아지므로 주식분할을 선호하지 않는 기업도 많음. 대표적인 예가 버크셔 해서웨이 주식</li>
  <li>주식분할 시 S&amp;P500 지수에는 별 영향이 없지만, 다우 지수는 단순 주가의 평균값이 움직이는 정도를 나타내므로 주식을 분할하여 주가가 분할된 기업의 움직임이 다우 지수에 미치는 영향력은 훨씬 떨어지고, 나머지 29개 주식의 영향력은 더 커짐. 따라서 다우 지수를 움직이는 주요 기업의 주식 분할은 다우 지수를 많이 하락시킬 수 있음</li>
  <li>다우 지수는 나머지 기업 주식과의 균형을 고려하기 때문에 너무 주가가 높은 주식은 포함시키지 않음. 주식 분할 이후 다우 지수에 새로 편입되는 등의 호재가 작용하면 주가의 추가 상승을 기대할 수도 있으나, 그런게 아니라면 차라리 다른 건전한 성장주 중 주식분할을 예상하는 주식에 투자하는 게 나음
    <ul>
      <li>기업이 건실하지만 주가가 너무 높아 다우 지수에 포함 안되고 있는 아마존, 구글, 넷플릭스 및 기타 등등</li>
    </ul>
  </li>
  <li>주식분할은 일시적 유동성 공급 면에서 호재일 수 있으나 기업의 성장성이 받쳐줘야 함. 그렇지 않다면 장기적으로 주가를 오르게 하진 않음</li>
</ul>

<h3 id="46-배당주">4.6 배당주</h3>
<ul>
  <li>배당은 기업이 잉여자본금을 주주에게 환원해주는 것</li>
  <li>배당률 = 연간배당금/현재 주가일 뿐이고 배당 성향도 기업 상황에 따라 얼마든지 바뀔 수 있으므로 배당주를 탐색할 때 단순히 배당률이 높거나 오랜 배당 역사가 있는지 보는 것은 의미가 없음
    <ul>
      <li>실제로 코로나 시기(2020년) 동안 경기침체 타격으로 배당금을 축소, 중지한 종목은 총 639개나 되었음</li>
    </ul>
  </li>
  <li>고배당주가 고배당인 이유, 저배당주가 저배당인 이유와 배당을 꾸준히 유지할 현금 여력이 있는 지를 기업 공시와 제무제표를 통해 반드시 확인해야 함</li>
  <li>배당성향은 회사가 벌어들인 순이익 중에서 얼마를 배당금으로 지급했는지를 나타내는 비율
    <ul>
      <li>배당성향=( 배당금/순이익 )×100</li>
    </ul>
  </li>
  <li>일반적으로 기업 순이익과 주당순이익에 배당성향을 적용해 배당금을 책정함. 단, 리츠 같은 특수한 경우 주당 순이익이 아닌 AFFO 수치에 배당성향 적용
    <ul>
      <li>예를 들어 통신사인 AT&amp;T의 2020년 2분 10-Q의 손익계산서에 공시된 당기순이익, 희석주당순이익은 Asset Impairments, Depreciation &amp; Amortization 처럼 실제 현금 지출이 아닌 회계 비용을 모두 차감해서 표시하고 있어 산업 특성 상 배당 지금 여력을 판단하는 기준인 실제 현금 보유력과 무관함</li>
      <li>따라서 AT&amp;T 경영진은 순이익이 아닌 잉여현금흐름(영업현금흐름 - 자본지출)을 기준으로 배당성향 책정해 분기별 배당금 지급 사항 공시</li>
      <li>최근 어닝 콜에서 CFO는 연초에 발표한 200억 달러 자본지출 계획은 여전히 유효하며, 현금흐름은 영업활동에 따른 현금 증가분을 목표로 하고 있고 자본지출을 절감하는 식의 현금 유는 없을거라 명시함 -&gt; 현재로선 성장을 위한 자본 투자를 소홀히 하지 않으며 정상적인 영업활동에 지출하는 영업비용, 이자비용 등을 충분히 감당할 잉여현금흐름 창출 능력이 있다는 것</li>
    </ul>
  </li>
  <li>배당성향은 기업이 벌어들인 돈 대비 얼마를 돌려주는지, 배당률은 투자자가 지금 가격에 투자했을 때 기대할 수 있는 배당 수익이 얼마인지를 보여줌</li>
  <li>배당주 배당성향 체크리스트
    <ul>
      <li>기업 실적 : 기업의 이익과 현금흐름(EPS, AFFOPS, FCF)이 배당과 함께 성장하고 있어야 배당금도 성장함</li>
      <li>배당성향 변화 추이 : 배당성향이 올라 배당금이 커진 건 경영진이 기업 미래 이익이 상승할거라 판단했기 때문이고 그 반대의 경우는 기업 이익 악화 신호이자 배당 성향 축소 조짐</li>
      <li>배당 패턴 : 배당금이 일관성 있게 유지 또는 성장하고 있는지, 큰 변동성이 있었다면 어떤 이유였는지</li>
      <li>배당률 산정 기준 : 배당률 계산에 사용된 연간배당금이 과거 1년간 지급한 금액인지, 예상 금액인지, ETF 배당의 경우 주가가 펀드 주가(시장가)인지 순자산(실제 구성 주식 주가들의 합)인지, 주가와 순자산에 큰 차이가 있는지 확인</li>
    </ul>
  </li>
</ul>

<h2 id="5-현실적인-미국-주식투자-전략">5. 현실적인 미국 주식투자 전략</h2>

<h3 id="51-리스크-관리">5.1 리스크 관리</h3>
<ul>
  <li>목표 수익률을 제대로 확립하려면 먼저 리스크 대비 수용 가능성을 이해해야 함. 리스크를 수용하는 만큼 기대수익도 커짐
    <ul>
      <li>주식, 채권 6:4의 흔한 비율의 포트폴리오 구성 시 연 8~10%이 현실적인 목표 수익률, 주식만으로 채울경우 리스크가 올라가지만 연 10~15% 정도</li>
    </ul>
  </li>
  <li>리스크는 단순히 손실 가능성이 아닌, 수익 변동성으로 이해하는 것이 정확함
    <ul>
      <li>공격적인 투자 전략으로 알려진 헤지펀드는 리스크 대비 높은 수익률을 실현하며 다른 기관투자자보다 훨씬더 보수적이고 리스크 관리를 핵심으로 여김</li>
    </ul>
  </li>
  <li>개인투자자들에게 가장 효과적인 리스크 관리는 포트폴리오의 자산분배 전략. 음의 상관관계(한쪽 자산가격이 올라갈 때 다른 쪽 자산가격이 내려가는 관계)인 자산을 적절히 배분하여 급변하는 시장 움직임에도 평균 수익률을 방어</li>
  <li>리스크 수용도란 리스크 감당 능력이 아닌, 개인이 리스크를 받아들이는 성향을 의미함. 반면에 리스크 감당 능력은 말그대로 감당할 수 있는 개인의 재정 능력을 의미</li>
  <li>수익을 내는 트레이더는 사고파는 시점을 미리 정해놓고 포지션을 잡음. 손실과 수익실현에 대한 기준점이 미리 있어야 함</li>
  <li>손절 StopLoss’ S/L과 익절 Take Profit; T/P의 지정가 설정과 자동 매매 기능으로 주가의 평균 변동성 구간을 나타내는 ATR(Average True Range)에서 1.5배를 벗어나는 구간에서 지정가 매도 주문을 걸어놓는 방법도 자주 쓰임. 종목, 섹터마다 시장 수익률과 변동 폭의 편차가 심하고 어닝 시즌 같은 시기에 더욱 편차가 증가하니 유의해야 함</li>
  <li>손실 상쇄 전략으로 풋 옵션 구매가 있음. 풋 옵션은 미래에 특정 주식을 특정 가격에 팔 수 있는 권리로, 매수한 주식의 주가 하락 시 풋 옵션 가격은 반대로 오르며 손실 한도를 제한함
    <ul>
      <li>단, 적어도 1년 이상 투자를 지속할 가치평가를 한 기업이고 단기간의 변동성에 의한 일시적 하락세가 예상될 때만 의미가 있으며, 6개월 정도의 단기 수익을 노리고 매수했다면 3, 6개월 만기의 풋 옵션을 사는 건 의미가 없음</li>
    </ul>
  </li>
</ul>

<h3 id="52-성장주와-가치주">5.2 성장주와 가치주</h3>
<ul>
  <li>성장주 : 전체 시장보다 높은 가격에 거래되고 주가 배수가 높음. 낮은 순이익이나 향후 기대 성장률이 높음. 경기와 무관하게 높은 성장에 대한 기대를 받음. 가격 변동성이 높으며 주로 IT, 임의 소비재가 이에 속함</li>
  <li>가치주 : 주로 펀더멘털은 탄탄한데 특정 요소(컨센서스에 못미친 분기 실적, 소송, 경영진 문제 등) 때문에 일시적으로 주가가 떨어진 기업. 상대적 주가 배수, 가격 변동성이 낮음. 시장에서 아직 가치를 인정받지 못하지만 향후 가치가 주가에 반영되기를 기대하고 매수하므로 장기투자 필요. 주로 금융주, 유틸리티, 에너지 섹터가 이에 속함</li>
  <li>경기침체기에는 가치주가, 그 외 경기 호황, 상승장에서는 성장주 수익률이 시장을 압도함
    <ul>
      <li>침체기에는 사람들이 안정성을 선호함. 가치주는 이미 이익을 내고 있고, PER이 낮음 → 방어적 성격</li>
      <li>배당도 주고, 실적 변동도 적음</li>
      <li>호황기에는 금리가 낮음 → 미래 수익의 현재 가치가 커짐</li>
      <li>성장주는 미래 수익 기대가 크기 때문에 → 주가가 더 크게 반응</li>
    </ul>
  </li>
  <li>당장 1년 안에 결판을 볼게 아니라면 성장주, 가치주 중 하나에만 베팅하지 말고 기업 가치에 중점을 두되 시황에 따라 비율을 조정하며 수익을 극대화하는게 최선의 방법</li>
</ul>

<h3 id="53-채권과-주식">5.3 채권과 주식</h3>
<ul>
  <li>일반적으로 경기 침체 시 위험 자산인 주식이 빠져 주가가 하락하고, 안전자산인 채권에 몰려 가격이 상승하는 반면 경기 호황 시에는 기업의 수익에 대한 기대로 주식 매수가 증가하여 주가가 상승하고 금리 상승 전망으로 채권 가격이 낮아지는 등 서로 반대로 움직임</li>
  <li>단, 코로나 시기에 경제 활성화를 위해 저금리 상황에서 국채까지 매입, 국민들에게 직접 현금까지 지급하며 돈이 남아 금리는 더더욱 낮아지고 채권과 주식의 동반 랠리가 이어짐</li>
  <li>채권 이자는 정해져 있으므로 금리가 더 떨어져야 수요가 증가하고 가격도 오르는데, 경기 회복에 대한 기대감으로 오르는 주식과 달리 이미 0% 금리라 수요가 적어짐.</li>
  <li>그러나 주식대비 안정적이고 절대적인 고이자 수익 채권에 투자하는 건 유리할 수 있음. 미국의 투자적격 등급 회사채나 고수익 회사채의 경우 요즘 같은 경기침체기에 채무 불이행 위험이 상승하면 미국 국채 대비 훨씬 더 높은 금리 스프레드를 지급해야하기 때문</li>
  <li>또한 코로나로 인한 경기침체가 10년간 지속될거라 생각하지 않는 이상 경기회복 이후 채권을 포함한 포트폴리오는 제 역할을 충분히 발휘할 수 있음. 단기적인 현상이 아닌 장기적인 자산 가격 추이를 보면 두 자산은 반대방향으로 움직이는 게 맞음</li>
  <li>채권 투자가 불리한 시황이면 방어자산으로 현금 보유를 택하는 것도 좋을 수 있음. 핵심은 무조건 주식과 채권 비율을 맞추기보단 내 투자 목적을 고려하는 것</li>
  <li>시장 흐름을 살피려면 연방기금금리, 미국 국채 수익률, LIBOR, 인프레이션, 주요 환율 등의 경제지표와 그 외에도 대선이나 외교 정책, 새로운 정책 발표 같은 굵직한 정치적 이벤트들을 알아야 함</li>
</ul>

<h3 id="54-레버리지-투자">5.4 레버리지 투자</h3>
<ul>
  <li>기대수익률이 더 높은 자산에 집중하는 것과 레버리지로 수익률을 끌어올리는 것 중에서는 레버리지가 더 효과적임. 레버리지 없이 수익을 극대화하려면 고위험-고수익 자산에 더 집중할 수 밖에 없기 때문</li>
  <li>레버리지란, 선물계약·스왑·옵션 등의 파생상품을 활용해 기초자산(주식, 지수 등)의 하루 수익률을 2배, 3배 등으로 배수 추종하는 투자 구조. 실제 자산을 배수만큼 직접 사는 것이 아니라, 기초자산이 오르거나 내릴 때 수익률을 배수만큼 얻거나 잃을 권리를 가진 파생계약을 활용</li>
  <li>ETF의 경우 지수추종으로 치면 SPY, VOO, IVV 등에 대하여 배수 레버리지를 활용한 ETF 상품들이 있음. 하락장 일 때 2배, 3배 강도로 더 하락한다는 리스크가 있지만 해당 타이밍에 저점 매수 전략으로 추가 매수를 한다거나 새로운 진입 시점으로 잡으면 반등장에서 더 큰 폭의 수익률을 노릴 수 있음</li>
  <li>3배수 레버리지 ETF에 투자 시 원금이 녹아버릴 정도가 되려면 S&amp;P500 지수가 33% 이상 폭락했을 때인데 이 정도 규모의 폭락장은 글로벌 마켓에서도 찾아보기 힘듦. 인덱스 추종 펀드와 함께 레버리지 상품과의 비율을 조절해 활용하면 효과적인 포트폴리오 관리가 가능</li>
  <li>레버리지 상품은 하락시 복리효과가 더 강하게 적용되기 때문에 원금이 회복되려면 하락한 비율보다 훨씬 더 높은 상승폭이 필요
    <ul>
      <li>예 : 100만원에서 50% 손실 -&gt; 원금회복하려면 100% 비율로 상승 필요, 여기서 레버리지까지 고려하면 더 큰 상승폭 필요</li>
    </ul>
  </li>
  <li>반대로 시장을 숏하는 증시하락에 베팅하는 레버리지 상품도 있으나 실행하기 힘들 뿐더러 거래량이 적어 유동성이 낮으므로 추천하지 않음</li>
</ul>

<h3 id="55-애널리스트-리포트">5.5 애널리스트 리포트</h3>
<ul>
  <li>미국은 한국과 달리 애널리리스트 독립성을 명확히 보장하는 법적·제도적 장치가 있고 매년 바이사이드 투자 인력이 각각의 투자은행 애널리스트를 평가한 전문성, 독립성, 객관성 순위 공개. 따라서 애널리스트는 객관성을 유지하고 주가 분석에 따른 하향조정 리포트가 자주 나오는 편</li>
  <li>애널리스트가 분석한 목표주가가 시장가격과 연동하거나 심지어 실제 주가를 후행하는 경우도 있음. 이런 현상은 주로 성장주에서 나타나는데 애널리스트가 분석한 펀더멘털과 밸류에이션 모델의 결과값이 실제 시장에서 거래되는 가격과 편차가 큰 경우가 흔하기 때문</li>
  <li>성장주는 시장의 기대와 투자심리(주가가 오를수록 투자심리가 더 뜨거워짐)에 의해 주가가 폭발적으로 오르기도 하는데, 이럴 경우 전통적인 펀더멘털 분석이 무력해지기 때문</li>
  <li>재무적 숫자로 설명할 수 없는 시장의 기대심리를 잔뜩 반영해 주가의 상승세가 이어지면 애널리스트는 어느 정도 시장심리를 후반영해 목표주가를 수정하기도 함</li>
  <li>투자은행은 업무 특성상 대형 기관투자자의 거래를 중개하거나 자문하므로 기관의 자금흐름을 가장 먼저 파악할 수 있으나 이 역시 증권사 리포트(목표 주가·투자의견)로 선반영되므로 또 한 번 실제 매매가격을 후행하는 셈</li>
  <li>따라서 애널리스트 보고서에서 목표주가보다는 실적 추정치를 주목해야 함. 해당 기업의 실적 추정치 변화를 보는 것이 투자 의견보다 더 정확하기 때문. 목표 주가나 투자 의견에 변화가 없어도 애널리스트가 실적 추정치를 상향조정한다면 그 주식에 모멘텀이 있다고 본다는 것
    <ul>
      <li>예를 들어 매도 의견을 고수하던 애널리스트가 분기 실적 발표 전 경영진과의 미팅에서 새로운 자금조달 힌트를 얻거나 시장에 뜻밖의 호재가 생겼을 경우 매도 의견은 유지하되 일전에 발표한 비관적인 실적 예상치를 다소 상향조정할 수 있음</li>
    </ul>
  </li>
  <li>한 명의 애널리스트가 아닌 여러 투자은행이 같은 추세를 보인다면 주가에 큰 영향을 미침. 애널리스트들의 실적 추정치 평균을 스트리트 컨센서스라 하는데 어닝 시즌 동안 단기 주가를 움직이는 가장 큰 동력은 추정치 대비 실제 발표한 수치와의 갭</li>
  <li>애널리스트가 분석한 목표 주가는 도달하기까지 얼마가 걸릴지 알 수 없으며, 도달하지 않을수도 있음. 결국 개인투자자는 개인보다 정보 접근성, 전문성에서 우위인 애널리스트의 기업 분석 내용을 참고하여 스스로 기업의 펀더멘털에 따른 가치평가를 하고 적정주가를 산정해야 함</li>
  <li>증권사 리포트 체크 포인트
    <ul>
      <li>애널리스트 목표 주가는 회의적 시각에서 최대한 비판적으로 볼 것. 기업 가치와 시장 가치의 차이를 이해라고 목표 주가를 어떤 방법으로 도출했는지, 애널리스트의 의견을 어떤 방식으로 반영했는지 이해</li>
      <li>해당 산업과 기업의 객관적 팩트만 구분해서 소화할 것. 최대한 여러 명의 애널리스트 보고서를 참조, 비교해 주가방향의 객관성을 유지하고 항상 컨센서스와 비교해 업계 평균 컨센서스와 차이가 크면 왜 그런지 이해해야 함</li>
      <li>애널리스트 분석과 경영진 예측의 근거 자료를 확인하고 비교. 애널리스트가 왜 이런 가정을 하고, 그 근거는 무엇이며 타당한지, 경영진의 가이던스와 얼마나 차이가 나고 어디서 비롯되었는지, 현재 기업 상황과 시황을 봤을 때 말이 되는 모델인지</li>
      <li>애널리스트 리포트는 물론 시황, 경영진 가이던스, 자신의 의견 등을 비교해보며 기업 가치를 끊임없이 반문하고 분석하는 훈련이 필요</li>
    </ul>
  </li>
  <li>미국에선 증권사 리서치 리포트를 개인이보려면 돈을 지불해야 함. 대신 애널리스트의 목표 주가와 투자 의견, 그에 사용된 기본적인 수치들이 거의 실시간으로 각종 증권 뉴스 포탈에 올라오고 그 투자 의견의 변화 추기만 종합해서 종목별로 열람할 수 있는 무료 사이트가 많음</li>
  <li>가끔 주식투자 커뮤니티(Seeking Alpha, The Motley Fool 등)에서 특정 종목에 대한 증권사 리포트 일부를 공유하고 애널리스트의 가치평가 방법 및 그에 대한 분석을 하는 글이 종종 올라와 참고하기 좋음</li>
</ul>

<h3 id="56-투자-원칙을-지킨다는-것">5.6 투자 원칙을 지킨다는 것</h3>
<ul>
  <li>투자자는 자신만의 투자 원칙을 세워야 함. 투자 원칙 없이 주식투자를 하는 것은 도박과 다를게 없음</li>
  <li>자신의 투자 원칙에 참고할 보편적 투자 원칙
    <ul>
      <li>고위험 고수익에 내포된 위험과 보상 체계를 정확히 이해하고 수익실현과 손절매 기준을 세움
        <ul>
          <li>높은 리스크를 감수하고 고위험 성장주에만 집중하는 ETF나 개별 종목에 투자했다면 그 리스크에 따른 결과값을 이해하고 손실 기준점을 확립할 것. 급락 시 어디까지 손실을 감당할 수 있는지 기준을 먼저 계획해야 의연하게 대처할 수 있음</li>
        </ul>
      </li>
      <li>투자 기간이 길수록 자산 수익률 리스크가 낮아짐
        <ul>
          <li>투자 기간이 길수록 전체 가격 변동성이 낮아져 수익률 리스크도 낮아짐. 주식투자는 장기 보유하며 하락세든 상승세든 관계없이 초기 투자 전략, 투자 판단을 고수하는 것만으로도 리스크를 상당 수준 제거할 수 있음</li>
        </ul>
      </li>
      <li>정액분할투자를 함
        <ul>
          <li>특정 포지션에서 한 번에 매수하지 않고 주기적으로 정해진 금액을 투자해 평균 단가를 낮추는 방법. 주가가 떨어졌을때는 자동으로 더 많은 수의 주식을 매수하고, 주가가 오를 대는 덜 매수함. 즉, 매수하는 주식 수는 단가에 따라 변함</li>
          <li>갑자기 찾아오는 변동성과 불확실함 속에서도 포트폴리오를 키워갈 수 있게 함</li>
        </ul>
      </li>
      <li>포트폴리오 조정으로 리스크를 낮추고 수익률을 높임(리밸런싱)
        <ul>
          <li>예를 들어 포트폴리오가 주식 60%, 채권 30%, 금 10%이라면 분기마다 그 비율을 유지하도록 투자금을 조정함. 한쪽이 급상승하면 원래 목표로 한 배분비율에 따라 청산하고 나머지에 재분배</li>
          <li>오른 자산을 팔고 덜오르거나 떨어진 자산을 사서 자산 방어를 위해 원래 목표로 한 배분비율을 유지하여 수익률을 개선하고 손실을 방어함</li>
          <li>분기마다 주로 연기금이나 뮤추얼펀드, 보험회사의 자산 운용사 등 Passive Funds들이 내부적인 자산 배분에 대한 가이드라인을 지키기위해 리밸런싱을 하는데 이로인해 대규모 매도·매수가 발생</li>
          <li>개인은 이런 흐름을 미리 인지하고 감안하면 되는데 이를 이용해 직후에 ETF 가격 방향을 예측해서 콜옵션(상승), 풋옵션(하락)으로 레버리지 수익을 추구할 수도 있음. 단, 시장 방향을 예측할 줄 알아야 함</li>
        </ul>
      </li>
      <li>투자 원칙을 반드시 지킬 것</li>
    </ul>
  </li>
</ul>

<h2 id="6-미국-주식-트레이딩-전략과-기본">6. 미국 주식 트레이딩 전략과 기본</h2>

<h3 id="61-주가-변동에-대응하는-투자-전략의-기본">6.1 주가 변동에 대응하는 투자 전략의 기본</h3>
<ul>
  <li>개인투자자에게 가장 현실적인 투자수익은 주식을 사고파는 매매수익이 아닌 장기 보유에서 얻는 수익</li>
  <li>기업의 펀더멘털과 무관하게 시장이 반응하는 데는 크게 Headline Effects(뉴스 헤드라인만으로 긍정/부정적으로 인식하여 주식을 매매), Catalysts Trading(투자자들이 이미 숙지하고 있는 기업 이벤트에 대해 호재/악재를 판단하여 주식을 매매)이 있음</li>
  <li>Catalysts(촉매)는 주가가 크게 상승하는 계기가 될 수 있는 기업의 특별 이벤트로 중/장기, 단기, 하드, 소프트 캐털리스트로 구분
    <ul>
      <li>장기 캐털리스트 : 인수합병, 기업분할, 흑자 전환, 신사업 개발 등 시간이 걸리는 기업 자체적인 주가 동인</li>
      <li>하드 캐털리스트 : 실적 발표, 투자자의 날, 애널리스트의 날, 인수의향/인수합경 발표, 자사주 매입, 자산 매입/매각, 배당 뉴스, 경영진 또는 이사회 멤버 교체, 행동주의 헤지펀드 지분 업데이트 등 주가에 직접적인 영향을 미치고 구체적인 날짜와 재무적 영향을 미치는 실행 아이템이 있음</li>
      <li>소프트 캐털리스트 : 애널리스트의 투자 의견 변화, 관련 산업 규제, 신사업 개발, 신약/신상품시장 확대, 원자재 가격의 변동, 기타 기업에 영향을 미치는 매크로 변수의 변화 등 기점이 되는 특정 날짜나 기업의 구체적인 액션이 없어 간접적인 효과를 줌. 다른 주가 동인들과 복합적으로 작용하여 영향이 상쇄되기도 함</li>
    </ul>
  </li>
  <li>단기 캐털리스트의 대표 예는 어닝 시즌의 실적발표날로, 해당 날짜에 실적이 컨센서스보다 높게 나오는지, 낮게 나오는지에 따라 변동성이 크게 나타나며, 이를 노리고하는 어닝 플레이 전략도 있음. 단, 이 경우 목표 수익률 이상으로 주가가 움직였을 경우 반드시 수익실현을 해야 함. 주가가 금방 제자리를 찾아가는 경우가 많음. 투자자의 날이나 애널리스트 날에도 동일</li>
  <li>장기투자자들에게도 추가 매수 또는 수익실현을 위해 일부 자금을 움직일 기회가 되므로 이런 큰 촉매의 실현 여부가 결정되는 이벤트는 반드시 기억해야 하며, 예상대로 혹은 예상과 반대로 움직일 수 있으므로 목표 수익 실현 또는 손실 방어를 위해 익절 또는 손절 주문을 걸어두는게 좋음. 장기투자 기조에 영향을 주지 않은 촉매라도 주가가 단기적으로 왜 그렇게 크게 움직였는지는 이해할 수 있어야 리스크 관리가 가능함</li>
  <li>실적 발표 내용이 내 밸류에이션과 일치하지 않으면 포지션을 뒤집어야 할 수 있고, 반대로 밸류에이션에 변화가 없는데 시장이 이상할 정도로 과잉 반응했다면 추가매수/매도 실행</li>
</ul>

<h3 id="62-매크로거시경제-트레이딩">6.2 매크로(거시경제) 트레이딩</h3>
<ul>
  <li>개인 투자자는 적어도 시장을 움직이는 매크로 팩터들과 그게 내 포트폴리오에 어떤 영향을 미치는지 정도는 이해해야 함</li>
  <li>채권의 경우 10년물 국채(10-Year Treasury)를 주시. 일반적으로 채권 수익률이 상승하는 경우(금리 인하) 달러가 강세를 보임. 채권 수요가 커지면서 세계 자본이 미국 채권으로 몰리며 달러 수요도 증가하기 때문</li>
  <li>인플레이션 우려가 있을 경우 중앙은행이 긴축 통화정책(Tight Monetary Policy)를 시행하여 연방기금의 금리를 올려 통화 공급량을 줄이고 물가 상승폭 제한</li>
  <li>금리 상승기에는 기술성장주 등 롱 듀레이션 주식이 하락하고 가치주 등 숏 듀레이션 주식과 고배당주, 고수익 단기채는 상승. 주가는 미래 현금흐름(이익, 배당 등)을 현재가치로 환산한 값인데 롱 듀레이션 주식은 매출과 이익이 멀리 떨어진 시점에 주로 발생하므로 금리가 높을수록 가치가 하락</li>
  <li>인플레이션이 너무 가파르게 진행될 경우 보통 금, 원유, 원자재, 부동산 및 기타 등등 인플레이션에 대한 헤지 자산 수요가 급증하고 채권 가격도 하락
    <ul>
      <li>단, 원자재에 대한 공급 체인 이슈와 그로 인한 인플레이션으로 스테그플레이션이 일어날 경우 기업 실적 전망치가 하락하여 주식 시장이 무너지고 리스크 자산 수요 하락 -&gt; 더 안전한 국채로 수요가 몰려 채권 가격이 상승할 수 있음</li>
      <li>공급체인 이슈에는 코로나 19 같은 상황이나 중국의 내수/공급 지표 등이 영향을 끼침</li>
    </ul>
  </li>
  <li>기관투자자들은 가장 효율적인 인플레이션 방어자산으로 원자재를 꼽음. 원자재 선물 및 관련 주식에 투자하는 것.</li>
  <li>연준 의장의 금리 관련 발언이나 재무부 장관의 정책 방향성을 암시하는 발언에 따라 증시가 하락할 경우 매크로 쇼크에 의한 것. 이 경우에도 원자재 관련주, 에너지주들이 강세를 보임</li>
  <li>미국 시장에서는 애널리스트들이 분기별 보고서 외에 주요 매크로 이벤트나 매크로 쇼크가 있을 때도 수시로 매크로 전망 관련 보고서를 발표하므로 참고
    <ul>
      <li>키워드 : Macro Forecast, Macro Out-look, Commodities Futures, US 10YrBond Yield Outlook</li>
    </ul>
  </li>
  <li>벨웨더 주식(경제 전반적인 상황과 해당 섹터에 대한 선행지표 역할을 하는 주식)으로는 주로 경기순환주가 있음. 벨웨더 주식이 어닝 시즌에 좋은 실적을 발표한다는 것은 경제 상황이 호전되리라는 강한 시그널
    <ul>
      <li>이를 코로나 19 이수 증시에 적용해보면, 경제 재개 관련 뉴스 및 기대심리와 함께 다우 지수나 S&amp;P 500 지수가 상승한 것은 벨웨더 주식이 이끄는 경기순환주나 가치주 등의 주가 상승으로 인한 것</li>
      <li>인플레이션, 미국 정부 정책 방향성, 중앙은행의 통화정책 등 여러가지 매크로 상황에 따라 높은 상관관계로 움직이므로 기본적인 매크로 경제를 이해하고 주가 흐름을 읽을 수 있다면 중단기적 트레이딩 수익을 낼 수 있음</li>
      <li>항공/호텔 및 숙박업 주식들은 여행 수요는 물론 비즈니스 수요(호텔 산업 주요 수익원은 출장이나 콘퍼런스 등)를 가장 먼저 반영하므로 이들의 주가 추이는 전반적인 경기회복 또는 침체의 시그널을 줌. 또한 건설업, 건설장비 업체 역시 글로벌 경제 흐름을 선반영할 수 있으며 그외에도 섹터 별 먼저 시장의 방향성을 보여주는 기업들이 해당함</li>
    </ul>
  </li>
</ul>

<h3 id="63-상시적-변수에-대응하는-매매-전략">6.3 상시적 변수에 대응하는 매매 전략</h3>
<ul>
  <li>내 포트폴리오 변동성에 가장 큰 영향을 미치는 요인 중 하나가 기존 투자 종목과 높은 상관관계에 있는 다른 기업 주식들. 유사/경재 기업군들의 트레이딩을 파악하여 같은 방향으로 움직일 것인지, 반대 방향으로 움직일지 정도는 파악해야 함
    <ul>
      <li>어펌 홀딩스(분할 결제=BNPL를 지원하는 핀테크 기업)의 관련 기업으로 페이팔, 스퀘어, 애프터페이.. 카드사로는 비자, 마스터.. 더 넓은 범위에서는 애플페이, 구글페이 등이 있음. 그외에도 어펌 매출의 3분의 1이 상을 차지하는 펠로톤(고가 운동기구를 판매, 분할 결제가 잦음)도 관련이 있음</li>
      <li>어펌 자체적으로 특별한 이벤트나 공시가 없었으나 애플이 어펌을 견제하기 위해 골드만삭스와 파트너십을 맺어 BNPL 서비스 제공을 발표하며 주가가 하루에 10% 이상 하락</li>
      <li>그 다음달 스퀘어가 애프터페이 인수 건에 대하여 자사 IR 사이트와 SEC에 8-K, 보도자료를 공시하며 다음날 어펌 주가가 15% 가까이 폭등. 공시에 인수 목적이 BNPL 사업 확장 및 성장이라고 설명됨. 유사/경쟁 기업군의 두 기업이 인수합병을 발표하며 어펌 역시도 같은 목적으로 인수 대상이 될 가능성이 시사되고, 그렇지 않더라도 BNPL 비즈니스에 대한 시장 관심도가 높아졌기 때문</li>
    </ul>
  </li>
  <li>정기적 어닝 시즌 및 기업 주요 이벤트 외에 갑자기 뜬 뉴스 헤드라인 만으로도 주가가 크게 움직임. 이 변동 폭은 프리마켓과 애프터마켓에서 가장 큼</li>
  <li>8-K는 예기치 않은 상황에 대해 주주에게 보고하는 내용으로, SEC에 업로드됨과 동시에 보도 자료도 함께 공시됨. 어펌이 아마존과의 파트너십을 체결하여 앞으로 아마존에서 소비한 금액이 50달러 이상일 경우 어펌의 BNPL 모델에 따라 월 할부로 지불하게 되었다는 8-K 공시가 뜬 다음 거래일날, 주가가 50%이상 폭등한 적이 있음. 장기 투자자 입장에서도 일시적인 수익실현 기회로 볼 수 있음</li>
  <li>재무부 장관이 상원 청문회에서 국가 부도 위기를 언급했을 때 국채 금리가 상승(국가가 빛을 못 갚을까봐 국채 가격 하락 + 위험자산이 되버린 국채에게 프리미엄 요구 -&gt; 국채 금리 상승)하고 인플레이션 장기화 우려(정부가 돈이 부족해지면 중앙은행에 돈을 찍어내서 돈이 과도하게 풀릴 수 있음)가 겹쳐 금리에 민감한(인플레이션 때문에 정책 금리를 올릴수도 있음) 기술 성장주들이 급락함, 어펌의 경우 마스터 카드가 BNPL 시장에 뛰어든다는 뉴스로 매크로 팩터와 개별 주식 타격이라는 두 요소가 한꺼번에 작용해 악재</li>
  <li>매크로 변수에 의해 주가 변동성이 나타날 경우 특정 섹터 비중을 축소하거나 확대하는 방식으로 포트폴리오를 리밸런싱하는 게 좋음. 일시적인 변동성이 아닐 경우가 많음</li>
</ul>

<h3 id="64-어닝-시즌을-활용한-매매">6.4 어닝 시즌을 활용한 매매</h3>
<ul>
  <li>실적과 무관하게 섹터 단위로 시장이 부과하는 프리미엄이 높아지거나 낮아질 수 있음. 같은 섹터 내 특정 기업 매출 성장률이 눈에 띄게 높아지만 비교 기업 주가에 조정이 오기도 함</li>
  <li>실적 발표를 앞두고 미결제 약정액(시장에서 아직 청산되지 않고 남아있는 콜옵션과 풋옵션 계약의 총 개수)을 확인하여 전망을 알 수 있음. 콜옵션 체결 물량이 우세하면서 옵션 프리미엄 가격 또한 상승하고, 풋옵션 매도 포지션 신규 진입자가 증가(현재 주가에서 더 안내릴거라 배팅)했다면 실적에 대한 긍정적 투자자 정서가 반영된 것</li>
  <li>주가를 움직이는 실적 발표의 주요 포인트
    <ul>
      <li>당기 실적이 애널리스트 컨센서스를 넘어섰는지, 아니면 못미치는지?</li>
      <li>당기 실적이 경영진이 예상한 목표치, 가이던스를 달성했는지?</li>
      <li>실적 수치들에 반영 또는 미반영된 요소는 무엇이며, 그 이유는 무엇인지?</li>
      <li>경영진의 실적 가이던스에 어떤 변화가 있었는지?</li>
      <li>실적 외 사업에 영향을 미치는 새로운 뉴스가 있는지? (자산 매입/매각, 파트너십, 경영진 변경, 규제, 소송 등)</li>
      <li>검색 키워드 : Beat Estimate, Financial Outlook, Guidance, Revised Up/Down, Street Estimate/Consensus, Earnings Beat, Earnings Surprise, Fall Short of Expectations</li>
    </ul>
  </li>
  <li>실적이 기대치를 훨씬 넘어설 경우 프리마켓부터 형성된 매수세로 모든 뉴스가 선반영된 가격이 된 후 수익실현을 하는 단기 트레이더의 매도세에 의해 익일 주가에 조정이 오기도 함. 이런 상황에서 매매 손실을 줄이려면 지정가 주문을 걸어두거나 반대로 주가가 이미 충분히 상승한 만큼 차익 실현 세력을 예상하여 공매도를 취하는 방법이 있음</li>
</ul>

<h3 id="65-미국의-매매정지-제도">6.5 미국의 매매정지 제도</h3>
<ul>
  <li>Trading Halt : 미국 각 증권거래소에서 변동성이 심하거나 심할 것으로 예상되는 주식에 대해 5분 동안 매매를 정지시키는 것. Single Stock Circuit Breaker라고도 함</li>
  <li>Held at Open : 증권거래소에서 개장 직후 매매가 정지되도록 제한한 경우. 많은 기업들이 개장 전이나 장 마감 이후에 실적 발표나 8-K 공시 같은 중요 발표를 하는데, 투자자들이 내용을 충분히 숙지하고 트레이딩 결정을 내리게 하기 위함이나 매수/매도세가 한쪽으로 크게 기운 상태에서 주문 실행까지 지연되며 변동성이 더 증폭되기도 함</li>
  <li>Volatility Halt : 특정 주식 등락폭이 ATPR(거래가격 범위, 지난 5분 동안 거래된 주가의 평균 가격이 기준)를 넘어선 수준에서 15초 이상 거래가 지속될 경우 5분동안 취해지는 매매정지. 일반 우량주 기준 개장 후 15분과 장 마감 이전 25분까지는 ATPR을 10%이상 벗어난 경우, 그외에는 5% 이상 벗어난 경우 시행됨</li>
  <li>News Halts : 주가 등락폭이 클 것으로 예상되는 특정 캐털리스트 발표를 앞두고 기업 측에서 해당 증권거래소에 직접 요청해 이뤄지는 매매정지. 공시 직후 주가가 요동치는걸 방지하기 위함으로, 이런 경우 8-K 공시가 뜸</li>
  <li>Compliance Halts : SEC, FINRA 같은 규제 당국과 NYSE, NASDAQ, AMEX 등의 증권거래소 자체적으로 규제상의 이유를 들어 매매정지. 대표적으로 상장폐지 발표, 비정상적 매매에 대한 조사 착수, 의무 공시 자료 누락 등의 예가 있음. 이런 종류의 매매정지는 악재로 작용하여 정지가 풀린 후 주가 폭락</li>
  <li>Circuit Breaker : 개별주에 대한 상/하방 변동성 약화가 아닌, 증권거래소에서 증시 폭락사태 발생 시 증시 전체에 대해 시행하는 매매정지. 강도에 따라 레벨 1, 2, 3으로 나뉘며 레벨 1은 S&amp;P500 지수 7% 이상 하락, 레벨2는 13%이상 하락, 레벨3은 20% 이상 하락 시 시행됨. 미국 동부 시간으로 오후 3시 25분까지 레벨 1, 2 서킷 브레이커 발동가능. 레벨 3에서는 아예 그날 매매가 종료됨</li>
  <li>Uptick Rule : 공매도의 남용이나 공매도 자체로 인한 하락 모멘텀을 제한하여 낙폭이 심한 변동성을 줄이기 위해, 숏 셀링 서킷 브레이커가 발동한 주식은 그다음 거래일까지 자동으로 업틱 룰이 적용됨. 업틱 룰 발동 시 해당 주식의 공매도는 현재 주가보다 높은 가격으로만 가능함
    <ul>
      <li>공매도는 버블 제거를 통한 적정 가격 형성이라는 순기능도 있으나, 주가 폭락을 겨냥하고 의도적인 공매도 공시를 하는 숏 셀러가 있을 수 있음</li>
      <li>어느 헤지펀드가 공매도 포지션을 잡았다는 뉴스가 뜨면 그 헤드라인 자체만으로 주주에게 악재. 기관투자자는 개인투자자보다 정보상 우위에 있다는 인식때문에 개인투자자들의 매도를 유발하기도 함</li>
      <li>숏 셀링 서킷 브레이커는 해당 거래일 장중 하락폭이 전일 종가(마감가격) 대비 10% 이상일 때 발동</li>
      <li>증권 매매 플랫폼에서 급등률이 높은 순, 급락률이 높은 순으로 주식 리스트들을 나열해 보면 빨간색으로 Warning 심볼이 붙어 있는 게 있음. 업틱 룰이 적용된 주식이라는 의미로, 급락률이 높은 주식뿐만아니라 급상승 주식에도 종종 붙어있는데, 대게 이전 거래일에 주가가 많이 빠져서 업틱 룰이 발동하고 이튿날 회복을 넘어 급등세를 보인 것. 단순히 급등한 주식을 매수하고 급락한 주식을 매도 및 공매도하는 건 이미 주가를 움직인 모멘텀이 반영되어 있는 경우가 많아 위험함</li>
    </ul>
  </li>
</ul>

<h3 id="66-개인투자자-필수-레퍼런스로-유용한-미국-주식-사이트">6.6 개인투자자 필수 레퍼런스로 유용한 미국 주식 사이트</h3>
<ul>
  <li>SEC 기업 공시자료 열람
    <ul>
      <li>BAMSEC : bamsec.com</li>
      <li>EDGAR : sec.gov</li>
    </ul>
  </li>
  <li>전반적인 시황, 매크로 뉴스 확인
    <ul>
      <li>Bloomberg : bloomberg.com</li>
      <li>CNBC : cnbc.com</li>
      <li>CNN business : edition.cnn.com/business</li>
      <li>Market Watch : marketwatch.com</li>
    </ul>
  </li>
  <li>애널리스트 투자 의견과 컨센서스 수치 확인
    <ul>
      <li>Benzinga : benzinga.com</li>
      <li>Finviz : finviz.com</li>
      <li>Google Finance : google.com/finance</li>
      <li>Investing.com : investing.com</li>
      <li>Koyfin : koyfin.com</li>
      <li>MarketBeat : marketbeat.com/stocks</li>
      <li>TradingView : tradingview.com</li>
      <li>Yahoo!Finance : Finance.yahoo.com</li>
    </ul>
  </li>
  <li>종목 스크리닝과 재무제표 정리
    <ul>
      <li>Macrotrends : macrotrends.net</li>
      <li>Stockrow.com : stockrow.com</li>
    </ul>
  </li>
  <li>헤지펀드 및 유명 기관투자자들의 포트폴리오(일부) 확인
    <ul>
      <li>Gurufocus : gurufocus.com</li>
      <li>WhaleWisdom : Whalewisdom.com</li>
    </ul>
  </li>
  <li>개별 종목 분석과 투자 아이디어 제공
    <ul>
      <li>Finbos : finbox.com</li>
      <li>MarketScreener : marketscreener.com</li>
      <li>Seeking Alpha : seekingalpha.com</li>
      <li>The Motley Fool : fool.com</li>
      <li>VIC : valueinvestorsclub.com</li>
    </ul>
  </li>
  <li>개별 종목 혹은 펀드의 기술적 분석
    <ul>
      <li>Barchart : barchart.com</li>
      <li>MorningStar : morningstar.com</li>
      <li>StockChart : stockcharts.com</li>
      <li>Zachs : zacks.com</li>
    </ul>
  </li>
  <li>ETF 관련 사이트
    <ul>
      <li>ETF database : etfdb.com</li>
      <li>ETF Trends : etftrends.com</li>
    </ul>
  </li>
  <li>배당주 관련 사이트
    <ul>
      <li>Dividend.com : dividend.com</li>
      <li>Dividend Investor : dividendinvestor.com</li>
    </ul>
  </li>
  <li>기업 실적 발표와 캘린더 제공
    <ul>
      <li>Alpha Street : news.alphastreet.com</li>
      <li>Earnings Whisper : earningswhispers.com</li>
      <li>Fidelity eResearch : eresearch.fidelity.com/eresearch/goto/conferenceCalls.jhtml</li>
      <li>TipRanks : tipranks.com</li>
    </ul>
  </li>
  <li>IPO와 SPAC, 비장상 기업 관련 사이트
    <ul>
      <li>CB Insights : cbinsights.com/research-unicorn-companies</li>
      <li>Nasdaq IPO : nasdaq.com/market-activity/ipos</li>
      <li>NYSE IPO : nyse.com/ipo-center/filings</li>
      <li>SPAC Analytics : spacanalytics.com</li>
      <li>SPAC Insider : spacinsider.com</li>
      <li>SPAC Research : spacresearch.com</li>
    </ul>
  </li>
  <li>포트폴리오 시뮬레이션
    <ul>
      <li>Portfolio Visualizer : portfoliovisualizer.com</li>
    </ul>
  </li>
  <li>매크로 경제 지표
    <ul>
      <li>Fed : federalreserve.gov/releases/h15</li>
      <li>FRED : fred.stlouisfed.org</li>
    </ul>
  </li>
</ul>]]></content><author><name>Toyo</name></author><category term="Investments" /><category term="U.S. stocks" /><summary type="html"><![CDATA[1. 미국 주식시장 구조 미국 주식시장은 3개의 시장 플레이어로 구성됨. 미국증권거래위원회(SEC) : 매매 관리 감독, 규제. 셀사이드 : 유가 증권을 유통하는 증권사. 미국에서는 투자은행IB가 담당. 매매 중개자이자 딜러에 속함. 바이사이드 : 투자 대상을 선별해 자산을 투자하는 운용 주체. 개인 또는 외부 투자자의 자금을 운영하는 펀드회사. 헤지펀드, 사모펀드, 자산운용자, 보험사 등 을의 입장인 셀사이드는 갑인 바이사이드에게 매매 수수료를 받는 대신 기본 매매 업무뿐 아니라 기업 연계 서비스도 제공 셀사이드 애널리스트 : 증권사, 투자은행 등에서 일하며 기업 분석 리포트를 작성하고 기관/개인에게 투자 의견을 제공. 투자자의 셀사이드 리서치 의존도가 예전에 비해 낮아지자 증권사 측에서는 셀사이드 애널리스트를 줄이는 추세 바이사이드 애널리스트 : 연기금, 자산운용사, 보험사, 헤지펀드 등에서 내부 투자 판단을 위한 분석을 수행하는 전문가. 외부에 분석 결과를 공개하지 않음 공시 자료를 정확히 이해하고 미래 손익을 추정하는 작업이 어려운 이유는 기업이 보고한 숫자를 그대로 받아들여서는 안되기 때문. 기업이 특정 비용을 예외로 간주해 누락한 이유가 무엇인지, 의도적으로 제외한 요소는 없는지, 경영진이 말하는 계속사업이익은 정말 지속가능한지, 재무상태표에 숨은 부채나 자산은 없는지 등 합리적인 의심 요소는 수없이 많음 특별손익(Extraorinary Gains,/Losses), 일회성 비용(One-time Expenses; Non-recurring Charges) 같은 용어가 보이면 그 항목의 자금흐름을 정확히 이해할 필요가 있음. 회계기준을 위반하지 않으면서 경영진이 보여주고 싶은 부분만 보여주고 특정 비용을 잘 포장해 재무제표상의 숫자를 크게 왜곡할 수 있음]]></summary></entry><entry><title type="html">SSE</title><link href="/cs/2025/01/01/SSE.html" rel="alternate" type="text/html" title="SSE" /><published>2025-01-01T00:00:00+00:00</published><updated>2025-01-01T00:00:00+00:00</updated><id>/cs/2025/01/01/SSE</id><content type="html" xml:base="/cs/2025/01/01/SSE.html"><![CDATA[<h2 id="1-실시간-웹의-필요성과-통신-기술">1. 실시간 웹의 필요성과 통신 기술</h2>

<h3 id="11-실시간-페이지의-필요성-및-활용-사례">1.1 실시간 페이지의 필요성 및 활용 사례</h3>

<ul>
  <li><strong>실시간 페이지</strong>는 사용자가 페이지를 새로고침하지 않고도 실시간으로 데이터를 확인할 수 있게 합니다.</li>
  <li>주요 활용 사례:
    <ul>
      <li><strong>주식 시장</strong>: 실시간으로 주가 변동 정보를 제공.</li>
      <li><strong>채팅 애플리케이션</strong>: 새로운 메시지를 즉시 전송 및 수신.</li>
      <li><strong>라이브 알림 시스템</strong>: 긴급 알림, 주문 상태 업데이트 등 실시간 알림 제공.</li>
      <li><strong>게임 및 스포츠 이벤트</strong>: 점수, 진행 상황 등의 실시간 업데이트.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="12-실시간-서버-클라이언트-통신-기술">1.2 실시간 서버-클라이언트 통신 기술</h3>

<h4 id="121-long-polling">1.2.1 Long-Polling</h4>
<ul>
  <li><strong>개념</strong>:
    <ul>
      <li>클라이언트가 서버에 요청을 보내고, 새로운 데이터가 준비될 때까지 서버가 응답을 지연시킴.</li>
      <li>새로운 데이터가 준비되면 서버는 응답을 반환, 클라이언트는 즉시 새로운 요청을 보냄.</li>
    </ul>
  </li>
  <li><strong>특징</strong>:
    <ul>
      <li>실시간 데이터를 제공할 수 있지만, <strong>불필요한 요청/응답 반복</strong>으로 비효율적.</li>
      <li>각 데이터 전송마다 새로운 연결을 설정해야 하므로 서버와 클라이언트 모두 리소스를 많이 사용.</li>
    </ul>
  </li>
</ul>

<h4 id="122-websocket">1.2.2 WebSocket</h4>
<ul>
  <li>클라이언트-서버 간의 양방향 통신</li>
  <li>양방향 연결이므로 3-way handshake 필요. 핸드셰이크가 성공하면 HTTP 연결을 WebSocket으로 프로토콜 전환</li>
  <li>연결이 여전히 사용 가능한지에 대한 확인 및 재연결 처리 로직을 직접 구현해야 함</li>
  <li>라이브 채팅, 게임, 금융 거래 플랫폼 등 지연 시간이 짧고 빈번한 업데이트가 필요한 경우 사용</li>
</ul>

<h4 id="123-웹-트랜스-포트-api">1.2.3 웹 트랜스 포트 API</h4>
<ul>
  <li>웹소켓과 마찬가지로 양방향 통신</li>
  <li>웹 클라이언트와 서버 간의 효율적이고 지연 시간이 짧은 통신을 위해 설계된 최첨단 API</li>
  <li>HTTP/3와 QUIC 프로토콜을 기반으로 함. QUIC는 기본적으로 UDP를 사용하지만, 신뢰성 있는 데이터 전송을 위해 TCP와 유사한 기능을 제공</li>
  <li>여러 개의 스트림을 통해 동시에 여러 파일이나 데이터를 보낼 수 있음</li>
  <li>웹 트랜트 포트 API가 매우 복잡하기 소스 코드에서 직접 웹 트랜스포트를 사용하기 보다 웹 트랜스포트를 기반으로 한 라이브러리 사용 필요</li>
  <li>하나의 연결 안에서 단방향과 양방향 스트림 모두에 대해 높은 처리량을 지원하며, 여러 스트림이 필요한 시나리오에서 웹 소켓보다 우수한 성능을 발휘할 것으로 예상</li>
  <li>Node.js를 포함한 다른 서버 프레임워크에서 널리 지원되지 않고, safari와의 호환성이 떨어지기 때문입니다. 게다가 이 기술은 HTTP/3에 의존하는데, nginx와 같은 많은 웹서버들은 HTTP/3 연결을 아직 실험적으로 제공</li>
</ul>

<h4 id="124-server-sent-events-sse">1.2.4 Server-Sent Events (SSE)</h4>
<ul>
  <li>http를 통해 서버 -&gt; 클라이언트로 단방향 통신</li>
  <li>라이브 뉴스 피드, 스포츠 점수 등 서버 -&gt; 클라이언트 단방향으로의 실시간 업데이트에 적합</li>
  <li>클라이언트에서 이벤트를 생성하는 서버의 url로 EventSource 인스턴스 초기화, 해당 인스턴스에 이벤트 핸들러(onMessage)달아 수신</li>
  <li>서버 측에서는 스크립트에 반드시 Content-Type 헤더가 text/event-stream으로 설정되어 있어야 하고, 각 메시지를 SSE 사양에 맞춰야 함
    <ul>
      <li>이 사양은 이벤트 타입, 데이터 페이로드를 명시해야 하고 이벤트 ID나 재시도 타이밍 등의 선택적인 필드를 포함</li>
    </ul>
  </li>
  <li>클라이언트에서 서버로 요청을 보내 연결을 맺고, 이후 서버에서 필요할 때마다 연결된 클라이언트들로 데이터 전송</li>
  <li>연결이 끊길 경우 클라이언트의 EventSource 객체에서 Last-Event-ID 헤더를 통해 서버에 마지막으로 수신한 이벤트 ID를 전달하여 자동 재연결</li>
  <li>기본 EventSource API를 사용하면 http 본문에서 POST와 같은 데이터를 보낼 수 없어 모든 데이터를 URL 파라미터에 포함해야 함
    <ul>
      <li>기본 EventSource API 대신 eventsource polyfill 라이브러리를 사용하면 커스텀 http 헤더를 보내는 등의 추가 기능을 제공</li>
      <li>본문 데이터를 전송하고 GET 대신 POST 요청을 사용할 수 있는 Microsoft의 fetch-event-source 라이브러리도 있음</li>
    </ul>
  </li>
  <li>대부분의 최신 브라우저는 도메인 당 6개의 연결을 허용하므로 모든 안정적인 서버-클라이언트 메시징 방법의 사용성이 제한됨
    <ul>
      <li>HTTP를 통해서 할 때는 브라우저당 6개 까지 가능 / HTTP2로는 100개가 기본?</li>
      <li>열려 있는 탭 수에 상관없이 하나의 연결만 열어서 탭 간에 공유하는 방식으로 해결 가능 broadcast-channel npm 패키지의 LeaderElection</li>
    </ul>
  </li>
  <li>IE 브라우저에선 SSE를 지원하지 않지만? polyfills 이용하여 해결 가능</li>
  <li>회사에서 프록시와 방화벽에 비 HTTP 연결을 차단하기 때문에 Server-Sent Events나 롱폴링이 더 사용하기 쉬움</li>
  <li>웹 소켓보다 오버헤드가 적어서 많은 클라이언트에게 메시지를 브로드캐스팅하는 데에 효율적. 그에 따라 서버에서 클라이언트로의 단방향 통신에서 처리량이 더 높을 수 있음
    <ul>
      <li>http 프로토콜을 사용하기 때문에 http -&gt; 웹소켓 프로토콜을 위한 핸드셰이크 작업이 필요 없음</li>
      <li>연결 상태 확인 로직 필요 없음</li>
      <li>데이터 전송 방식이 http로 WebSocket 프레임 포맷보다 단순함</li>
      <li>소켓 연결 방식은 서버에서 클라이언트마다 고유한 소켓 리소스를 소모</li>
    </ul>
  </li>
  <li>웹 소켓과 달리 프로토콜 업데이트 같은 작업 없이 “일반” HTTP 요청을 사용하기 때문에 확장성이 좋음</li>
  <li>클라이언트 재연결 시 이벤트를 놓칠 수 있음. 이벤트를 놓쳐선 안되는 경우 서버에 이벤트들을 버퍼링하거나 저장해둬야 할 수 있음</li>
</ul>

<hr />

<h2 id="2-sse의-데이터-전송-방식과-제약">2. SSE의 데이터 전송 방식과 제약</h2>

<h3 id="21-sse의-데이터-전송-방식">2.1 SSE의 데이터 전송 방식</h3>
<h3 id="22-sse와-다른-실시간-통신-기술-비교">2.2 SSE와 다른 실시간 통신 기술 비교</h3>
<h3 id="23-sse의-제약">2.3 SSE의 제약</h3>

<hr />

<h2 id="3-sse-구현">3. SSE 구현</h2>

<h3 id="31-spring-boot-js-환경에서-sse-통신-구현-방법">3.1 Spring Boot, JS 환경에서 SSE 통신 구현 방법</h3>

<h3 id="32-간단한-실시간-웹-예제">3.2 간단한 실시간 웹 예제</h3>]]></content><author><name>Toyo</name></author><category term="CS" /><category term="SSE" /><summary type="html"><![CDATA[1. 실시간 웹의 필요성과 통신 기술]]></summary></entry></feed>