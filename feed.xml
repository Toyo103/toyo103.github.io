<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-11-26T08:13:17+00:00</updated><id>/feed.xml</id><title type="html">Toyo.log</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>Toyo</name></author><entry><title type="html">자바 기초 정리2 (자바의 신 vol.2)</title><link href="/cs/2025/10/20/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-(%EC%9E%90%EB%B0%94%EC%9D%98-%EC%8B%A0-vol.2).html" rel="alternate" type="text/html" title="자바 기초 정리2 (자바의 신 vol.2)" /><published>2025-10-20T00:00:00+00:00</published><updated>2025-10-20T00:00:00+00:00</updated><id>/cs/2025/10/20/%EC%9E%90%EB%B0%94%20%EA%B8%B0%EC%B4%88%20%EC%A0%95%EB%A6%AC%20(%EC%9E%90%EB%B0%94%EC%9D%98%20%EC%8B%A0%20vol.2)</id><content type="html" xml:base="/cs/2025/10/20/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-(%EC%9E%90%EB%B0%94%EC%9D%98-%EC%8B%A0-vol.2).html"><![CDATA[<h2 id="1-자바-역사와-jvm">1. 자바 역사와 JVM</h2>

<h3 id="11-자바-명칭의-역사">1.1 자바 명칭의 역사</h3>
<ul>
  <li>1996년 JDK 1.0 출시. 이후 출시된 JDK 1.1에서는 JavaBeans, JDBC, 원격 JVM에 있는 메소드를 호출하기 위한 RMI(자바 원격 메소드 호출)가 추가됨</li>
  <li>1998년 12월 명칭이 변경된 J2SE 1.2(Java 2 Standard Edition) 출시. 기업에서 만드는 시스템을 개발하기 위한 Enterprise 에디션과 블랙베리와 같은 전화기에서 사용하고 있는 J2ME와의 혼동을 막기 위해 명칭 변경
    <ul>
      <li>JIT(Just-In-Time)가 추가됨. JIT는 자주 사용되는 바이트코드를 실행 중에 네이티브 코드로 컴파일하여
이후에는 인터프리팅 없이 바로 실행할 수 있도록 하여 성능을 향상</li>
      <li>JVM의 실행 방식은 인터프리터 + JIT 하이브리드 구조 : JVM은 바이트코드를 인터프리터를 통해 실행하며, 실행 중 자주 호출되는 코드는 JIT 컴파일러가 기계어로 변환하여 성능을 향상시킴</li>
      <li>JIT는 자바와 .NET이라는 언어에서 사용</li>
    </ul>
  </li>
  <li>J2SE 1.3에서는 HotSpot JVM, JNDI가 추가됨. JNDI는 어떤 객체를 쉽게 찾을 수 있도록 도와주는 이름을 지정하여 나중에 그 이름으로 객체를 찾아감
    <ul>
      <li>HotSpot 컴파일러
        <ul>
          <li>예전에는 cpu 코어가 제한적이었기에 애플리케이션 시작 시간을 빠르게 하고 적은 메모리를 점유하는 클라이언트 컴파일러와 코어가 많은 장비에서 애플리케이션을 돌리기 위한 서버 컴파일러를 따로 제공했음</li>
          <li>자바가 시작할 때 장비의 스펙을 확인하여 알아서 클라이언트 장비인지 서버 장비인지를 구분함. 명시적으로 지정하려면 java 명령 실행 시 -client, -server 옵션을 주면 됨</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>J2SE 1.4에서는 정규식, NIO가 추가됨. NIO는 이전 버전까지의 IO를 처리할 때 사용한 java.io 패키지에서 제공하는 기능의 단점을 보완하기 위한 것으로, 기존 IO보다 성능이 훨씬 더 빠름</li>
  <li>J2SE 1.5 버전부터는 앞의 1.을 빼고 J2SE 5라고 호칭. 이전 버전과 많은게 달라짐
    <ul>
      <li>제네릭</li>
      <li>어노테이션</li>
      <li>기본 자료형과 기본 자료형을 객체로 다루는 클래스 간의 데이터 변환이 자동으로 발생하는 autoboxing/unboxing 기능</li>
      <li>enum, 매개 변수의 개수를 가변적으로 선언하는 varargs</li>
      <li>향상된 for 루프</li>
      <li>static import</li>
      <li>스레드 처리를 쉽게 하는 java.util.concurrent 패키지</li>
      <li>Scanner 클래스</li>
    </ul>
  </li>
  <li>이후 출시된 Java SE 6 부터는 호칭을 쉽게하기 위해 Java에서 2가 빠짐. Java SE 6까지는 Sun Microsystems에서 만들었지만, Java SE 7부터는 Oracle이 인수하여 관리</li>
  <li>Java SE 8에서는 람다 표현식 사용이 가능해짐</li>
  <li>명칭이 계속 변경되었지만 일반적으로 JDK 1 ~ 1.4, Java 5 ~ 로 호칭 가능</li>
  <li>Oracle에서 관리하는 것 외에도 IBM, HP에서 각각의 운영체제에 맞게 최적화 된 JDK를 개발하여 사용하고 있음. 이 외에도 몇가지 JDK가 더 있는데, 소스에 라이선스 문제가 되는 부분을 제거한 완전 오픈소스 Open JDK도 있음</li>
  <li>각 Java 버전에서 제공되어야 하는 표준 문서가 만들어지면 그 기준에 해당하는 각 벤더에 맞는 JDK가 별도로 만들어짐. 어떤 OS에서 개발하든 JRE 버전만 맞으면 적용할 OS가 달라도 앱 실행 가능</li>
  <li>본인이 사용하는 JDK에서 어떤 것이 제공되고, 제공 안 되는지 정도는 확인해두는게 좋음</li>
</ul>

<h3 id="12-자바-언어의-특징">1.2 자바 언어의 특징</h3>
<ul>
  <li>자바는 단순하고 객체지향적이며 친숙해야 함
    <ul>
      <li>다른 언어를 배운 사람이라면 자바에 대한 기본 컨셉을 배우는 것이 어렵지 않음</li>
      <li>처음 만들때부터 객체지향으로 디자인 된 언어</li>
      <li>개발하면서 필요한 여러 기능들을 라이브러리를 통해 쉽게 개발 가능</li>
    </ul>
  </li>
  <li>자바는 견고하며 보안상 안전함
    <ul>
      <li>자바는 컴파일할 때와 실행할 때 문법적 오류에 대한 체크를 함. 메모리 관리 모델이 매우 단순하고 복잡한 포인터의 개념이 없음. 이러한 특징들이 자바를 믿을 수 있고 견고한 소프트웨어가 될 수 있게 해줌</li>
      <li>자바는 분산환경에서 사용하기 위해 설계되었기 때문에 보안이 매우 중요함. 따라서 외부에서 침입이 불가능한 애플리케이션을 만들 수 있고 네트위크 환경에서 클라이언트로 다운로드 한 승인받지 않은 프로그램은 실행할 수 없게 되어 있음. 단, 내부 오류로 인해 보안 취약점이 발견되기도 함</li>
    </ul>
  </li>
  <li>자바는 아키텍처에 중립적이어야 하며 포터블 해야 함
    <ul>
      <li>자바는 아키텍처에 중립적인 바이트 코드를 생성</li>
      <li>기본 데이터 타입의 크기를 지정해 놓고 숫자 연산자에 대한 행위들을 정의해 둠. 따라서 프로그램이 어떤 플랫폼에서도 동일한 결과가 나오고 하드웨어/소프트웨어 아키텍처에 따른 데이터 타입의 호환성에 문제가 발생하지 않음</li>
    </ul>
  </li>
  <li>자바는 높은 성능을 제공해야 함
    <ul>
      <li>실행환경에서 최대한의 성능을 냄. 자동화된 가비지 컬렉터는 낮은 우선 순위의 스레드로 동작함</li>
      <li>네이티브한 언어로 작성한 부분을 자바에서 사용할 수 있도록 되어있음</li>
    </ul>
  </li>
  <li>자바는 인터프리트 언어이며 스레드를 제공하고 동적인 언어임
    <ul>
      <li>자바 컴파일러는 컴파일 시 매우 엄격한 정적인 점검을 수행하고 실행 시에 동적으로 필요한 프로그램들을 링크시킴. 이후 실행단계에서 인터프리터+JIT를 사용하여 코드를 실행</li>
    </ul>
  </li>
</ul>

<h3 id="13-jvm과-gc">1.3 JVM과 GC</h3>
<ul>
  <li>JVM은 개발자가 작성한 자바 프로그램이 수행되는 프로세스. 자바에선 메모리 관리를 JVM이 알아서 해주는데 이것을 가비지 컬렉터(GC)라고 부름</li>
  <li>JVM은 아래와 같이 영역을 나눠 힙이라는 공간에 객체들을 관리함. 가장 왼쪽에 있는 Young 영역에는 젊은 객체들이, Old 영역에는 늙은 객체들이 자리잡으며 Perm 영역에는 클래스나 메소드에 대한 정보가 쌓임
<img src="/assets/images/힙구조.png" alt="힙구조" /></li>
  <li>Young 영역은 Eden과 2개의 Survivor 영역으로 나뉘는데 객체를 생성하자마자 저장되는 장소는 Eden. 일반적으로 자바에서 메모리가 살아가는 과정은 아래와 같음
    <ol>
      <li>Eden 영역에서 객체가 생성됨</li>
      <li>Eden 영역이 꽉 차면 살아있는 객체만 다른 Survivor 영역으로 객체가 복사됨. Eden 영역에 있는 객체들 중 살아있는 객체들도 다른 Survivor 영역으로 감. 따라서 Survivor 영역의 둘 중 하나는 반드시 비어있게 됨 -&gt; Young GC</li>
      <li>오래 살아있는 객체들은 Old 영역으로 가며 지속적으로 이동하다가 Old 영역이 꽉찰 때 GC가 발생 -&gt; Old GC</li>
    </ol>
  </li>
</ul>

<h2 id="2-javalang-패키지">2. java.lang 패키지</h2>

<h3 id="21-개요">2.1 개요</h3>
<ul>
  <li>자바의 패키지 중에서 유일하게 java.lang 패키지에 있는 클래스들은 import 없이 사용 가능. 자바에서 꼭 필요한 여러 기능들을 제공</li>
  <li>언어 관련 기본적인것, 문자열 관련, 기본 자료형 및 숫자 관련, 스레드 관련, 예외/런타임 관련하여 인터페이스, 클래스, 예외 클래스 등을 제공함</li>
  <li>예외 중 알아둬야 할 2가지로 OutOfMemortError와 StackOverflowError가 있음.
    <ul>
      <li>자바는 가상 머신에서 메모리를 관리하지만 프로그램을 잘못 작성하거나 설정이 제대로 되어 있지 않을 경우 OutOfMemortError가 발생 가능</li>
      <li>StackOverflowError는 호출된 메소드의 깊이가 너무 깊을 때 발생하는 에러. 자바에서는 스택 영역에 어떤 메소드가 어떤 메소드를 호출했는지에 대한 정보를 관리하는데 재귀 메소드를 잘못 작성할 경우 스택에 쌓이는 메소드가 호출 정보의 한계를 넘어설 수도 있음</li>
    </ul>
  </li>
  <li>1편에서 언급된 자바의 기본 어노테이션인 Deprecated, Override, Suppress Warnings도 선언되어 있음</li>
</ul>

<h3 id="22-숫자를-처리하는-클래스">2.2 숫자를 처리하는 클래스</h3>
<ul>
  <li>자바에서 기본 자료형은 힙 영역이 아닌 스택 영역에 저장되어 관리됨. 따라서 계산할 때 보다 빠른 처리 가능</li>
  <li>기본 자료형의 숫자를 객체로 처리해야 할 필요가 있을 경우, 자바에서 제공하는 기본 자료형처럼 선언되어 있는 클래스들이 있음. 대부분 기본 자료형에서 첫 문자만 대문자로 바뀜
    <ul>
      <li>Byte</li>
      <li>Short</li>
      <li>Integer</li>
      <li>Long</li>
      <li>Float</li>
      <li>Double</li>
      <li>Character</li>
      <li>Boolean</li>
    </ul>
  </li>
  <li>Character, Boolean을 제외한 숫자를 처리하는 클래스들은 Wrapper 클래스라 불리며 모두 Number라는 추상클래스를 확장함</li>
  <li>Wrapper 클래스는 자바 컴파일러에서 자동 형 변환을 해주기 때문에 참조 자료형이지만 기본 자료형처럼 사용 가능. 따라서 new를 사용하여 객체를 만들지 않아도 값을 할당할 수 있으며, String 클래스나 기본 자료형이 아님에도 + 연산가능</li>
  <li>Character 클래스 빼고 모두 parse타입이름() 메소드와 valueOf() 메소드를 제공함. 둘다 String과 같은 문자열을 숫자 타입으로 변환한다는 공통점이 있으나 parse는 기본 자료형을, valueOf는 참조 자료형을 리턴함</li>
  <li>이런 Wrapper 클래스가 만들어진 목적은
    <ul>
      <li>매개 변수를 참조형으로만 받는 메소드 처리</li>
      <li>제네릭에 사용하려면 참조 자료형이어야 함</li>
      <li>MIN_VALUE, MAX_VALUE (각 타입이 나타낼 수 있는 값의 범위) 같은 각 Wrapper 클래스에 선언된 상수 값을 사용하기 위해</li>
      <li>숫자와 문자열 간의 변환이나 2, 8, 10, 16 진수 변환을 쉽게 처리하기 위해
        <ul>
          <li>예를 들어 Integer에서 제공하는 toBinaryString(), toHexString() 메소드</li>
        </ul>
      </li>
      <li>그 외에 숫자 참조 자료형에서 제공하는 많은 메소드를 사용하기 위함</li>
    </ul>
  </li>
  <li>참고로 중요한 숫자 연산을 수행할 때 Wrapper 클래스는 아니지만 범위를 넘거나 부동소수점 오차를 방지하기 위해 정수형은 BigInteger, 소수형은 BigDecimal을 사용해야 정확한 계산이 가능함</li>
</ul>

<h3 id="23-system-클래스">2.3 System 클래스</h3>
<ul>
  <li>System 클래스에는 생성자가 없으며, 아래와 같이 3개의 static 변수가 선언되어 있음
    <ul>
      <li>static PrintStream err</li>
      <li>static InputStream in</li>
      <li>static PrintStream out</li>
    </ul>
  </li>
  <li>System.out.println()에서 out은 System 클래스에 static으로 선언된 변수 이름이며 println() 메소드는 PrintStream 클래스에 선언된 static 메소드. 모두 static이라 사용 시 별도의 클래스 객체를 생성할 필요가 없음</li>
  <li>PrintStream과 InputStream은 모두 java.io 패키지에 선언되어 있음</li>
  <li>System.out.println()을 출력을 위해 많이 사용하지만 출력은 System이 아닌 PrintStream과 연관되어 있으며 System은 시스템에 대한 정보를 확인하는 클래스</li>
  <li>System 클래스의 역할
    <ul>
      <li>시스템 속성(Property)값 관리
        <ul>
          <li>static Properties getProperties(), static String getProperty(String key), static Properties setProperties()… 및 기타 등등</li>
          <li>Properties는 java.util 패키지에 속하며 Hashtable의 상속을 받은 클래스. Map처럼 특정 key 값에 대한 value를 가짐</li>
          <li>자바 프로그램을 실행하면 Properties 객체가 생성되며 그 값은 언제 어디서든지 같은 JVM 내에서는 꺼내서 사용할 수 있음</li>
        </ul>
      </li>
      <li>시스템 환경값 조회
        <ul>
          <li>static Map&lt;String,String&gt; getenv(), static String getenv(String name) 등</li>
          <li>환경값(env)은 Properties와 달리 변경이 불가능하고 읽기만 할 수 있음. 대부분 OS나 장비와 관련된 것들
            <ul>
              <li>예 : System.getenv(“JAVA_HOME”)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>GC 수행
        <ul>
          <li>static void gc(), static void runFinalization() 등</li>
          <li>호출하지 않아도 JVM이 알아서 더이상 필요없는 객체를 처리하기위해 GC를 수행함. 위의 함수들은 알아두되 사용하지 말 것</li>
        </ul>
      </li>
      <li>JVM 종료
        <ul>
          <li>static void exit(int status)</li>
          <li>마찬가지로 절대 호출하면 안됨</li>
        </ul>
      </li>
      <li>현재 시간 조회
        <ul>
          <li>static long currentTimeMillis() : 현재 시간을 나타낼 때 유용한 메소드. UTC 기준 1970년 1월 1일 00:00부터 지금까지의 밀리초(1/1,000초) 단위의 차이를 출력함</li>
          <li>static long nanoTime() : 시간의 차이를 측정하기 위한 메소드. 마찬가지로 현재 시간을 출력하지만 currentTimeMillis와 달리 단위가 나노초(1/1,000,000,000초)</li>
        </ul>
      </li>
      <li>기타 관리용 메소드들</li>
    </ul>
  </li>
  <li>System 클래스에 선언된 out, err 변수는 동일하게 PrintStream 클래스의 객체로 정상적인 출력인지, 에러가 났을 때의 출력 결과인지의 차이만 존재</li>
  <li>PrintStream 클래스의 출력을 위한 주요 메소드 : print(), println(), format(), printf(), write() 등
    <ul>
      <li>print(), println()
        <ul>
          <li>모두 기본 자료형과 참조 자료형을 매개 변수로 사용할 수 있음</li>
          <li>byte나 short 타입을 매개 변수로 받는 메소드는 없으나 둘다 정수형이므로 int 타입을 매개 변수로 받는 메소드에서 처리해줌</li>
          <li>String.valueOf(obj)라는 static 메소드를 호출해 받은 결과를 출력함. obj.toString()과 달리 valueOf는 null이 들어가도 오류가 발생하지 않고 그냥 null이라 출력함. 따라서 객체를 출력할 때는 toString()보다 valueOf()를 사용하는 게 훨씬 더 안전</li>
          <li>System.out.println(null + “is object’s value”)와 같이 null에 더하기 연산을 해도 컴파일러에서 이 더하기 문장을 StringBuilder로 변환하여 new StringBuilder().append(obj).append(“ is object’s value”)로 수행하므로 예외를 발생시키지 않음</li>
        </ul>
      </li>
      <li>println 메소드는 매개 변수가 없는 메소드가 존재. 만약 줄바꿈만 처리하고 싶다면 println(“”) 대신 println()으로 처리하는게 불필요한 String 객체를 생성하지 않아 깔끔함</li>
    </ul>
  </li>
</ul>

<h2 id="3-제네릭">3. 제네릭</h2>

<h3 id="31-개요">3.1 개요</h3>
<ul>
  <li>타입 형 변환에서 발생할 수 있는 문제점을 사전에 없애기 위해 만들어짐</li>
  <li>Object 객체는 어느 참조 자료형이든 넣을 수 있지만 값을 꺼낼 때 형 변환을 해야하며, 어느 타입인지 확인하려면 instanceof 예약어로 확인해야함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class Box {
      private Object value;

      public void set(Object value) {
          this.value = value;
      }

      public Object get() {
          return value;
      }
  }
</code></pre></div>    </div>
  </li>
  <li>제네릭을 사용할 경우 클래스나 메서드가 사용할 타입을 미리 지정하지 않고, 사용할 때 어느 타입이든 지정할 수 있음.
 T 타입 매개변수는 선언된 범위 안에서만 의미가 있음
    <ul>
      <li>클래스의 경우
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class Box&lt;T&gt; {   // T는 타입 매개변수 (Type Parameter)
      private T value;

      public void set(T value) {
          this.value = value;
      }

      public T get() {
          return value;
      }
  }
</code></pre></div>        </div>
      </li>
      <li>메소드의 경우
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public &lt;T&gt; void printList(List&lt;T&gt; list) {
      for (T item : list) System.out.println(item);
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>꺾쇠 안에 있는 타입 매개변수로는 현재 존재하는 클래스를 사용해도 되고 존재하지 않는 것을 사용해도 됨. 가상의 타입 이름
    <ul>
      <li>단, 꼭 지켜야 하는 건 아니지만 자바에서 정의한 기본 규칙은 아래와 같음
        <ul>
          <li>E : 요소</li>
          <li>K : 키</li>
          <li>N : 숫자</li>
          <li>T : 타입</li>
          <li>V : 값</li>
          <li>S, U, V : 두 번째, 세 번째, 네 번째에 선언된 타입</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>제네릭으로 사용할 때 지정한 타입의 변수를 일치하지 않는 타입의 참조 자료형에 넣으려고 하면 컴파일 자체가 안됨. “실행 시”에 다른 타입으로 잘못 형 변환하여 예외가 발생하는 일은 없음</li>
  <li>제네릭 타입은 여러개를 정의할 수 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public &lt;T, U&gt; void printPair(T first, U second) {
      System.out.println("First: " + first);
      System.out.println("Second: " + second);
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="32-와일드-카드">3.2 와일드 카드</h3>
<ul>
  <li>와일드 카드는 제네릭 타입의 클래스나 메소드를 사용할 때 꺾쇠 안에 구체적인 클래스 대신 &lt;?&gt;을 넣음. 어떤 타입이 제네릭 타입이 될지 모르거나 상관 없을 경우 사용함</li>
  <li>와일드 카드를 사용하여 선언한 객체는 읽기만 가능하고 쓸 수는 없음. 클래스/메소드 내부에서 ?가 어떤 타입인지 모르기 때문에 Object로 받아야 하며, 매개 변수로만 사용하는 것이 추천됨</li>
  <li>제네릭, 와일드 카드는 각각 &lt;T extends Number&gt;, &lt;? extends Car&gt; 와 같이 타입에 대하여 경계를 지정할 수 있음. 특정 클래스를 상속 받은 클래스만 타입으로 사용할 수 있게 제한하는 것.
 후자를 Bounded Wildcards라고 부름</li>
</ul>

<h2 id="4-컬렉션">4. 컬렉션</h2>

<h3 id="41-자료구조와-collection">4.1 자료구조와 Collection</h3>
<ul>
  <li>자바에서 자료 구조는 여러 데이터를 담을 때 사용하며, 아래와 같은 것들이 있음
    <ul>
      <li>순서가 있는 List 형</li>
      <li>순서가 중요하지 않는 Set 형</li>
      <li>먼저 들어온 것이 먼저 나가는 Queue 형</li>
      <li>키-값으로 저장되는 Map 형</li>
    </ul>
  </li>
  <li>List, Set, Queue는 Collection이라는 인터페이스를 구현하고 있음. Collection 인터페이스는 java.util 패키지에 선언되어 있으며 어러 개의 객체를 하나의 객체에 담아 처리할 때 공통적으로 사용되는 여러 메소드들을 선언해놓음</li>
  <li>Map 만이 Collection과 관련 없는 별도의 인터페이스로 선언됨</li>
  <li>Collection 인터페이스 : public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;</li>
  <li>Collection 인터페이스가 확장하는 Iterable 인터페이스에 선언되어 있는 메소드는 Iterator&lt;T&gt; iterator() 하나로, 이 메소드를 이용하여 데이터를 순차적으로 가져올 수 있음</li>
  <li>Collection 인터페이스에 선언된 주요 메소드
    <ul>
      <li>boolean add(E e)</li>
      <li>boolean addAll(Collection)</li>
      <li>void clear()</li>
      <li>boolean contains(Object)</li>
      <li>boolean containsAll(Collection)</li>
      <li>boolean equals(Object)</li>
      <li>int hashCode()</li>
      <li>boolean isEmpty()</li>
      <li>Iterator iterator()</li>
      <li>boolean remove()</li>
      <li>boolean removeAll(Collection)</li>
      <li>boolean retainAll(Collection)</li>
      <li>int size()</li>
      <li>Object[] toArray()</li>
      <li>&lt;T&gt; T[] toArray(T[])</li>
    </ul>
  </li>
  <li>E = Element는 컬렉션에 저장되는 각각의 데이터를 말함</li>
  <li>List와 Collection 인터페이스를 확장한 다른 인터페이스들과의 차이는 배열처럼 순서가 있다는 것. List를 구현한 클래스들은 ArrayList, Vector, Stack, LinkedList 등이 있음</li>
  <li>ArrayList와 Vector 클래스의 사용법은 거의 동일하고 기능도 거의 비슷. 둘다 확장 가능한 배열인데, ArrayList는 Thread safe하지 않고 Vector는 Thread safe하다는 차이가 있음. 보통 ArrayList가 많이 선호됨</li>
  <li>Stack 클래스는 Vector 클래스의 확장으로 LIFO를 지원하기 위해 만들어짐</li>
  <li>LinkedList 클래스는 List와 Queue를 구현함</li>
</ul>

<h3 id="42-list">4.2 List</h3>

<h4 id="421-arraylist">4.2.1 ArrayList</h4>
<ul>
  <li>상속 관계는 java.lang.Object &gt; java.util.AbstractCollection&lt;E&gt; &gt; java.util.AbstractList&lt;E&gt; &gt; java.util.ArrayList&lt;E&gt;
    <ul>
      <li>AbstractCollection은 Collection 인터페이스, AbstractList는 List 인터페이스 중 일부 공통적인 메소드를 구현함</li>
    </ul>
  </li>
  <li>ArrayList가 구현한 인터페이스로는 Serializable, Cloneable, Iterable&lt;E&gt;(= foreach 사용 가능), Collection&lt;E&gt;, List&lt;E&gt;, RandomAccess(=빠르게 임의로 접근하는 알고리즘이 적용됨) 등이 있음</li>
  <li>배열처럼 사용하지만 대괄호는 사용하지 않고 메소드를 통해 객체를 넣고 빼고 조회</li>
  <li>ArrayList의 생성자
    <ul>
      <li>ArrayList() : 객체 저장 공간이 10개인 ArrayList 생성</li>
      <li>ArrayList(Collection&lt;? extends E&gt; c)</li>
      <li>ArrayList(int initialCapacity) : 매개 변수만큼의 저장 공간을 갖는 ArrayList 생성</li>
    </ul>
  </li>
  <li>대부분 서로 다른 종류의 객체가 아닌 한가지 종류의 객체만 저장. 한가지 종류를 지정하기 위해 생성 시 제네릭을 사용하면 좋음</li>
  <li>선언 시 매개 변수를 넣지 않으면 초기 크기는 10으로, 그 이상의 데이터가 들어가면 자동으로 크기를 늘리는 작업이 수행됨. 이는 성능에 영향을 주므로 예측 가능하다면 예측한 초기 크기를 지정하는게 좋음</li>
  <li>데이터를 담는 메소드
    <ul>
      <li>boolean add(E e)</li>
      <li>void add(int index, E e)</li>
      <li>boolean addAll(Collection&lt;? extends E&gt; c)</li>
      <li>boolean addAll(int index, Collection&lt;? extends E&gt; c)</li>
    </ul>
  </li>
  <li>하나의 Collection 관련 객체를 복사할 일이 있을 때는 생성자를 사용하거나 addAll 메소드를 사용하는 것이 권장됨</li>
  <li>Collection 타입의 매개변수로 제공하는 이유는 Set이나 Queue 같은 Collection을 구현한 다른 객체도 받아들이기 위함</li>
  <li>데이터를 꺼내는 메소드
    <ul>
      <li>int size()</li>
      <li>E get(int index)</li>
      <li>int indexOf(Object o)</li>
      <li>int lastIndexOf()</li>
    </ul>
  </li>
  <li>ArrayList에 들어가 있는 데이터 개수를 확인하려면 size() 메소드 사용. 배열이나 String 문자열의 길이를 가져오는 length()와 달리 저장공간 개수가 아님</li>
  <li>ArrayList에는 중복된 데이터를 넣을 수 있으며 앞에서부터 찾을 때는 indexOf, 뒤부터 찾을 때는 lastIndexOf 사용</li>
  <li>ArrayList 객체에 있는 데이터들을 배열로 뽑아내려면 toArray() 메소드 사용
    <ul>
      <li>Object[] toArray()</li>
      <li>
        <T> T[] toArray(T[] a)
</T>
      </li>
    </ul>
  </li>
  <li>제네릭을 사용하여 선언한 ArrayList 객체를 배열로 생성할 때는 두 번째 메소드를 사용해야 함</li>
  <li>toArray는 ArrayList 객체에 있는 값들을 매개 변수로 넘어온 T 타입의 배열로 만듦. 따라서 보통 new String[0]같은 값을 넘겨 타입만 지정해줌</li>
  <li>데이터 삭제하는 메소드
    <ul>
      <li>void clear() : 모든 데이터 삭제</li>
      <li>E remove(int index) : 지정한 위치에 있는 데이터 삭제 후 삭제한 데이터 리턴</li>
      <li>boolean remove(Object o) : 매개 변수와 동일한 첫 번째 데이터 삭제</li>
      <li>boolean removeAll(Collection&lt;?&gt; c) : 매개 변수 컬렉션에 있는 데이터와 동일한 모든 데이터 삭제</li>
    </ul>
  </li>
  <li>값을 변경하는 메소드
    <ul>
      <li>E set(int index, E element) : index 위치에 있는 데이터를 element 값으로 변경하고 기존의 값을 리턴</li>
    </ul>
  </li>
  <li>추가로 ArrayList 객체 공간의 크기를 데이터 개수만큼으로 변경하는 trimToSize() 메소드가 있음</li>
  <li>ArrrayList를 Thread safe하게 만드려면 아래와 같이 생성
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  List list = Collections.synchronizedList(new ArrayList(...));
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="422-linkedlist">4.2.2 LinkedList</h4>
<ul>
  <li>ArrayList와 다르게 AbstractSequentialList를 상속받음. AbstractSequentialList은 AbstractList와 add(), set(), remove() 메소드에 대한 구현이 상이함</li>
  <li>구현한 인터페이스는 List와 유사하나, List&lt;E&gt;뿐만 아니라 Deque&lt;E&gt;와 Queue&lt;E&gt;를 상속받음. Deque는 Queue 인터페이스의 확장으로 맨 앞/뒤에 값을 넣거나 빼는 작업을 하기 용이하게 되어있음</li>
  <li>생성자
    <ul>
      <li>LinkedList()</li>
      <li>LinkedList(Collection&lt;? extends E&gt; c)</li>
    </ul>
  </li>
  <li>주요 메소드
    <ul>
      <li>LinkedList는 여러 종류의 인터페이스를 구현했기 때문에 중복된 기능을 수행하는 메소드가 많음. 예를 들면 데이터를 추가하는 메소드들은 아래와 같음
        <ul>
          <li>LinkedList의 가장 앞에 데이터 추가
            <ul>
              <li>void addFirst(Object)</li>
              <li>boolean offerFirst(Object)</li>
              <li>void push(Object)</li>
            </ul>
          </li>
          <li>LinkedList 객체의 가장 뒤에 데이터 추가
            <ul>
              <li>void addLast(Object)</li>
              <li>boolean offer(Object)</li>
              <li>offerLast(Object)</li>
            </ul>
          </li>
          <li>LinkedList 객체의 특정 위치에 데이터 추가
            <ul>
              <li>void add(int, Object)</li>
            </ul>
          </li>
          <li>LinkedList 객체의 특정 위치에 있는 데이터를 수정하고 기존 데이터 리턴
            <ul>
              <li>set(int, Object)</li>
            </ul>
          </li>
          <li>매개 변수로 넘긴 컬렉션의 데이터 추가
            <ul>
              <li>addAll(Collection)</li>
            </ul>
          </li>
          <li>매개 변수로 넘긴 컬렉션의 데이터를 지정된 위치에 추가
            <ul>
              <li>addAll(int, Collection)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>데이터를 맨 앞에 추가하는 메소드는 동일한 기능을 수행하는 어떤 메소드를 호출해도 addFirst()를 호출하도록 구현됨. 또한 맨 뒤에 추가하는 메소드는 무조건 add()나 addLast() 메소드를 호출하게 되어 있으므로 add가 붙은 메소드로 통일하여 사용하는 것이 좋음</li>
      <li>그 밖에 맨 앞 데이터를 가져오는 메소드는 모두 내부적으로 getFirst() 메소드를 호출하고, 맨 앞 데이터를 삭제하는 메소드들은 모두 removeFirst() 메소드들을 내부적으로 호출함. 또한 맨 뒤 데이터를 삭제하는 메소드들은 모두 removeLast() 메소드를 내부적으로 호출하므로 혼동을 피하려면 remove가 붙은 메소드를 사용하는 것이 좋음</li>
      <li>LinkedList 객체를 하나씩 검색하기 위한 Iterator 객체는 아래와 같음
        <ul>
          <li>ListIterator listIterator(int)</li>
          <li>Iterator descendingIterator()</li>
        </ul>
      </li>
      <li>Iterator 객체는 앞에서 언급한 것과 같고, ListIterator는 다음 데이터만 검색할 수 있는 Iterator를 보완하여 previous()로 이전 데이터도 검색할 수 있게 만든 것</li>
    </ul>
  </li>
</ul>

<h4 id="423-stack">4.2.3 Stack</h4>
<ul>
  <li>LIFO 기능을 위해서라면 더 빠른 ArrayDeque 클래스가 있으나 Thread safe하진 못함</li>
  <li>취지가 LIFO라는 걸 고려했을 때 Vector를 상속 받아선 안되었으나 자바의 하위 호환성을 위해 현재 상속관계 유지</li>
  <li>객체의 가장 위에 있는 데이터를 리턴하는 peek(), 객체의 가장 위에 있는 데이터를 지우고 리턴하는 pop(), 그 밖에 push(), 객체가 비어있는지 확인하는 empty(), 매개 변수로 넘어온 데이터의 위치를 리턴하는 search()가 있음</li>
</ul>

<h3 id="43-set">4.3 Set</h3>
<ul>
  <li>순서에 상관없이 어떤 데이터가 존재하는지를 확인하는 용도로 자주 사용됨. 데이터가 중복되어 저장되지 않음</li>
  <li>Set 인터페이스를 구현한 주요 클래스로 HashSet, TreeSet, LinkedHashSet이 있음
    <ul>
      <li>HashSet
        <ul>
          <li>상속 관계 : java.lang.Object -&gt; java.util.AbstractCollection -&gt; java.util.AbstractSet&lt;E&gt; -&gt; java.util.HashSet&lt;E&gt;</li>
          <li>AbstractSet 추상 클래스는 Object 클래스의 equals(), hashCode() 메소드를 구현하고, removeAll() 메소드를 추가함. Set은 데이터 중복을 허용하지 않으므로 equals() 메소드가 필수이며 equals()는 hashCode()와 떨어질 수 없는 불가분의 관계 (Object 클래스 내용 참고)</li>
          <li>Set이 구현한 인터페이스는 List와 유사하나, 순서가 없으므로 get(int index)나 indexOf(Object o)와 같은 메소드들은 구현되지 않음</li>
          <li>생성자
            <ul>
              <li>HashSet()	: 기본 생성자. 초기 용량 16, 로드 팩터 0.75 사용</li>
              <li>HashSet(Collection&lt;? extends E&gt; c) : 다른 컬렉션 객체의 데이터를 Set으로. 중복은 자동 제거됨</li>
              <li>HashSet(int initialCapacity) : 지정한 초기 용량으로 HashSet 생성. 로드 팩터는 기본값 0.75 사용</li>
              <li>HashSet(int initialCapacity, float loadFactor) : 초기 용량과 로드 팩터를 모두 지정해서 HashSet 생성</li>
              <li>여기서 로드 팩터는 데이터의 개수/저장 공간으로, 해시 테이블이 얼마나 가득 찼을 때 크기를 두 배로 늘릴지를 결정하는 값. 크기를 늘리게 될 경우 해시 재정리 작업에 들어가는데 내부 자료 구조를 다시 생성하는 단계를 거치므로 성능에 영향이 감. 따라서 initialCapacity와 loadFactor는 총 데이터의 크기보다 큰 임계값을 갖도록 설정하는 게 좋음</li>
            </ul>
          </li>
          <li>주요 메소드
            <ul>
              <li>boolean add(E e)</li>
              <li>boolean remove(Object o)</li>
              <li>void clear()</li>
              <li>boolean contains(Object o)</li>
              <li>int size()</li>
              <li>boolean isEmpty()</li>
              <li>Iterator&lt;E&gt; iterator()</li>
              <li>Object clone()</li>
            </ul>
          </li>
          <li>Iterator 메소드가 구현되었으므로 for 루프를 사용하거나 아래와 같이 직접 iterator 객체를 생성하여 순회할 수 있음
            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Set&lt;String&gt; set = new HashSet&lt;&gt;(Arrays.asList("A", "B", "C"));
  Iterator&lt;String&gt; it = set.iterator();
  while (it.hasNext()) {
      String value = it.next();
      System.out.println(value);
  }
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="44-map">4.4 Map</h3>

<h4 id="441-hashtable">4.4.1 HashTable</h4>
<ul>
  <li>Map 인터페이스를 구현한 클래스로 유명한건 HashMap, TreeMap, LinkedHashMap인데 그 외에도 Hashtable이라는 클래스가 있음</li>
  <li>일반적인 Map 인터페이스를 구현한 클래스들과는 다름
    <ul>
      <li>Map은 컬렉션 뷰를 사용하지만 Hashtable은 Enumeration 객체를 통해 데이터를 처리</li>
      <li>Map은 키, 값, 키-값 쌍으로 데이터를 순환하여 처리할 수 있으나 Hashtable은 키-값 쌍으로는 데이터를 처리할 수 없음</li>
      <li>Map은 이터레이션을 처리하는 도중 데이터를 삭제하는 안전한 방법을 제공하지만 Hashtable은 그렇지 않음</li>
    </ul>
  </li>
  <li>HashMap 클래스와 달리 Hashtable은 키나 값에 null 값을 저장할 수 없고 멀티스레드에 안전하다는 차이가 있
음</li>
  <li>HashTable이 Collection 인터페이스보다 더 먼저 생겼고 나중에 생긴 Map에 맞춰 보완되었기에 이러한 차이가 생김</li>
  <li>HashTable을 제외한 Map으로 끝나는 클래스들을 멀티 스레드에서 동시 접근하여 처리하려면 아래와 같이 선언해서 사용해야 함. JDK 1.2부터 제공되는 대부분의 Collection 관련 클래스들이 그러함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Map m = Collections.synchronizedMap(new HashMap(...));
</code></pre></div>    </div>
  </li>
  <li>Map은 put(), get(), remove() 메소드로 데이터를 넣고 조회하고 제거함</li>
</ul>

<h4 id="442-hashmap">4.4.2 HashMap</h4>
<ul>
  <li>생성자
    <ul>
      <li>HashMap()	: 초기 용량(capacity)을 16으로 생성</li>
      <li>HashMap(int initialCapacity)</li>
      <li>HashMap(int initialCapacity, float loadFactor)</li>
      <li>HashMap(Map&lt;? extends K, ? extends V&gt; m) : 다른 Map의 모든 데이터를 복사해 새 HashMap을 생성</li>
    </ul>
  </li>
  <li>HashMap에 담을 데이터 개수가 많은 경우에는 초기 크기를 지정해 주는 것이 좋음</li>
  <li>HashMap의 키는 기본 자료형과 참조 자료형 모두 될 수 있는데, 직접 정의한 클래스를 키로 사용할 땐 Object 클래스의 hashCode(), equals() 메소드를 잘 구현해 놓아야 함</li>
  <li>HashMap은 내부적으로 배열을 사용하는데, 이 배열의 각 칸을 버킷이라고 부르고
각 버킷 안에는 연결리스트 또는 트리 구조가 들어감. 새로운 값을 추가할 때 어떤 버킷에 저장할지는 hashCode() 값으로 결정됨</li>
  <li>get(키 값)으로 값을 조회할 때도 hashCode()로 먼저 버킷을 확인한 후 해시코드가 같은 키-값이 여러개이면 equals()로 키 값 비교</li>
  <li>Map은 존재하지 않는 키로 get()을 하면 outOfBound 예외를 발생시키는 Collection과 달리 null을 반환함</li>
  <li>이미 존재하는 키로 값을 넣을 경우엔(put) 새로운 값으로 대치함</li>
  <li>HashMap에 있는 키 목록을 Set으로 반환하는 keySet(), 값 목록을 Collection 타입 목록으로 반환하는 values() 메소드가 있음</li>
  <li>entrySet() 메소드는 Entry 타입 객체들의 Set을 반환. Map에 선언된 Entry 객체는 하나의 키-값 쌍을 저장하는 하며, 키와 값을 가져오는 getKey(), getValue()를 제공함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class EntrySetExample {
      public static void main(String[] args) {
          // HashMap 생성 및 데이터 추가
          Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
          map.put("apple", 3);
          map.put("banana", 2);
          map.put("cherry", 5);

          // entrySet()을 이용한 순회
          for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
              String key = entry.getKey();
              Integer value = entry.getValue();
              System.out.println(key + " = " + value);
          }
      }
  }
</code></pre></div>    </div>
  </li>
  <li>그 밖에 boolean 리턴 타입을 가지는 containsKey(), containsValue()와 키 값을 매개변수로 삭제하는 remove() 메소드, 데이터 개수를 확인하는 size() 메소드가 있음</li>
</ul>

<h4 id="443-treemap">4.4.3 TreeMap</h4>
<ul>
  <li>데이터 저장 시 키를 정렬하는 맵. String 타입의 키일 때 기본 정렬 순서는 숫자 &gt; 알파벳 대문자 &gt; 알파벳 소문자 &gt; 한글 순인데, 키가 객체나 숫자일 경우에는 순서가 다름</li>
  <li>많은 데이터를 보관하면 HashMap보다는 느리나, 정렬이 필요할 때는 TreeMap을 사용하는 것이 유리함</li>
  <li>TreeMap이 키를 정렬하는 것은 SortedMap 인터페이스를 구현했기 때문인데, 키가 정렬 되었을 때의 장점은 firstKey(), lastKey() 외에도 특정 키 뒤에 있는 키 higherKey(), 특정 키 앞에 있는 키 lowerKey() 등의 메소드들을 제공하여 키를 검색하는 프로그램을 작성할 때 유리하다는 것</li>
</ul>

<h4 id="444-properties-클래스">4.4.4 Properties 클래스</h4>
<ul>
  <li>Properties 클래스는 HashTable을 확장하였으므로 Map 인터페이스에서 제공하는 모든 메소드 사용 가능</li>
  <li>기본적으로 자바에서는 Properties 클래스를 사용하여 시스템의 속성을 제공. System 클래스에 static으로 선언되어 있는 getProperties() 메소드를 호출하면 Properties 타입의 객체를 리턴
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class SystemKeySetExample {
      public static void main(String[] args) {
          // 시스템 속성 가져오기
          Properties props = System.getProperties();

          // keySet()으로 모든 키 조회
          Set&lt;Object&gt; keys = props.keySet();

          // 모든 키와 값 출력
          for (Object key : keys) {
              System.out.println(key + " = " + props.get(key));
          }
      }
  }
</code></pre></div>    </div>
  </li>
  <li>Properties 객체에는 시스템 속성 외에도 애플리케이션에서 사용하기 위해 필요한 여러 속성값들을 저장하고, 빼고, 읽어들일 수 있음</li>
  <li>Properties 클래스에서 추가로 제공하는 메소드
    <ul>
      <li>load(InputStream inStream)</li>
      <li>load(Reader reader)</li>
      <li>loadFromXML(InputStream in)</li>
      <li>store(OutputStream out, String comments)</li>
      <li>store(Writer writer, String comments)</li>
      <li>storeToXML(OutputStream os, String comment)</li>
      <li>storeToXML(OutputStream os, String comment, String encoding)</li>
    </ul>
  </li>
  <li>load 메소드는 파일에서 속성을, loadFromXML는 xml로 되어 있는 속성을 읽음. store는 파일에 속성을 저장하고 storeToXML는 xml로 구성되는 속성 파일을 생성함</li>
  <li>comment 매개 변수는 속성 파일에 주석으로 저장되는 값</li>
  <li>아래는 .properties 파일과 Properties 객체 간에 저장된 속성 내용을 주고 받는 예제
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class PropertiesStoreLoadExample {
      public static void main(String[] args) {
          // 1. Properties 객체 생성 및 값 설정
          Properties props = new Properties();
          props.setProperty("username", "admin");
          props.setProperty("password", "1234");
          props.setProperty("server", "localhost");
          props.setProperty("greeting", "안녕하세요");

          String fileName = "config.properties";

          // 2. 파일에 저장 (UTF-8)
          try (OutputStream out = new FileOutputStream(fileName)) {
              props.store(out, "Sample Config File");
              System.out.println("Properties 저장 완료!");
          } catch (IOException e) {
              e.printStackTrace();
          }

          // 3. 파일에서 읽어오기
          Properties loadedProps = new Properties();
          try (InputStream in = new FileInputStream(fileName)) {
              loadedProps.load(in);

              System.out.println("\n=== Properties 읽기 결과 ===");
              // 전체 속성 출력
              loadedProps.forEach((key, value) -&gt; 
                  System.out.println(key + " = " + value)
              );
              ...
          }
          ...
      }
  }
</code></pre></div>    </div>
  </li>
  <li>.properties 파일의 내용은 키=값들이 나열된 형태로 되어 있음. 위의 예제에서 loadFromXML, storeToXML를 대신 사용하면 Properties 객체를 xml 파일로 내보내거나 xml 파일 내용을 Properties 객체로 읽어올 수 있음</li>
  <li>xml은 .properties와 달리 태그 형식으로 구성됨. html도 xml의 일종</li>
</ul>

<h2 id="5-스레드">5. 스레드</h2>

<h3 id="51-개요">5.1 개요</h3>
<ul>
  <li>java 명령어를 사용하여 클래스를 실행시키는 순간 main() 메소드가 수행되면서 하나의 스레드가 시작됨</li>
  <li>WAS도 똑같이 Tomcat의 main() 메소드를 호출하여 하나의 main()에서 시작된 스레드들이 만들어져서 동작하는 것</li>
  <li>아무런 스레드를 생성하지 않아도 JVM을 관리하기 위한 여러 스레드가 존재함. GC 관련 스레드가 여기에 속함</li>
  <li>프로세스 하나가 시작하는데 많은 자원이 드는데 스레드는 훨씬 더 적은 물리 메모리를 점유함. 또한 지금같은 멀티코어 시대에는 다중 스레드로 실행하는게 더 빠른 결과를 가져다 줌</li>
</ul>

<h3 id="52-runnable-인터페이스-thread-클래스">5.2 Runnable 인터페이스, Thread 클래스</h3>
<ul>
  <li>스레드를 생성하려면 Runnable 인터페이스를 구현하거나, Runnable 인터페이스를 구현한 Thread 클래스를 사용하는 방법이 있음</li>
  <li>Runnable 인터페이스는 스레드가 시작되면 수행되는 메소드 void run() 하나만을 정의한 반면 Thread 클래스는 매우 많은 생성자와 메소드들을 제공하여 편리함</li>
  <li>자바에선 클래스가 하나의 클래스만 상속할 수 있으므로, 다른 클래스를 확장해야 하는 클래스에서 스레드를 사용하려면 Thread 클래스 대신 Runnable 인터페이스를 구현해야 함. 만약 그럴 필요가 없다면 스레드 클래스를 사용하는 것이 편함</li>
  <li>스레드가 수행할 동작을 구현하는 메소드는 run()이지만, 스레드를 시작하는 메소드는 start()임. start() 메소드는 직접 구현하지 않아도 알아서 run()을 수행하도록 자바에서 구현함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class ThreadExample {
      public static void main(String[] args) {

          // 1. Runnable 구현 방식
          Runnable runnableTask = new Runnable() {
              @Override
              public void run() {
                  System.out.println("Runnable 스레드 실행 중: " + Thread.currentThread().getName());
              }
          };
          Thread t1 = new Thread(runnableTask);
          t1.start(); // 새로운 스레드 시작

          // 2. Thread 클래스 상속 방식
          Thread t2 = new Thread() {
              @Override
              public void run() {
                  System.out.println("Thread 상속 스레드 실행 중: " + Thread.currentThread().getName());
              }
          };
          t2.start(); // 또 다른 스레드 시작

          // main 스레드
          System.out.println("메인 스레드 실행 중: " + Thread.currentThread().getName());
      }
  }
</code></pre></div>    </div>
  </li>
  <li>위의 예제와 같이 Runnable 인터페이스를 구현한 스레드 클래스는 start() 메소드로 바로 시작할 수 없으며 Thread 클래스의 생성자에 해당 객체를 추가하여 시작해야 함</li>
  <li>위의 예제에 있는 3가지 출력문은 코드 순서대로 출력되지 않음. 스레드를 start() 메소드로 시작하면 프로세스가 아닌 하나의 스레드가 JVM에 추가되어 실행되므로 각 스레드는 비동기적으로 실행됨</li>
</ul>

<h3 id="53-thread-클래스-생성자">5.3 Thread 클래스 생성자</h3>
<ul>
  <li>생성자
    <ul>
      <li>Thread()</li>
      <li>Thread(Runnable target) : 지정한 Runnable 객체를 실행할 스레드를 생성</li>
      <li>Thread(Runnable target, String name) : 실행할 Runnable과 스레드 이름을 함께 지정</li>
      <li>Thread(String name) : 스레드 이름만 지정. run()은 오버라이드해서 사용</li>
      <li>Thread(ThreadGroup group, Runnable target) : 특정 스레드 그룹에 속하는 스레드를 생성하고, 실행할 Runnable 지정. 해당 group에 속하는 스레드를 target 기반으로 생성하는 것</li>
      <li>Thread(ThreadGroup group, Runnable target, String name) : 스레드 그룹, 실행 대상, 스레드 이름을 모두 지정</li>
      <li>Thread(ThreadGroup group, Runnable target, String name, long stackSize) : 스레드 그룹, 실행 대상, 이름, 스택 크기까지 지정</li>
      <li>Thread(ThreadGroup group, String name) : 스레드 그룹과 이름만 지정</li>
    </ul>
  </li>
  <li>모든 스레드는 이름이 있음. 특별히 지정하지 않으면 “Thread-n”으로 지어지며 n은 스레드가 생성된 순서에 따라 증가. 스레드 이름은 겹쳐도 에러가 예외가 발생하진 않음</li>
  <li>스레드의 그룹을 묶으면 ThreadGroup 클래스에서 제공하는 메소드들을 통해 여러 정보를 얻을 수 있음</li>
  <li>stackSize는 스택의 크기를 정의하지만, 스레드에서 얼마나 많은 메소드를 호출하는지 또는 얼마나 많은 스레드가 동시에 처리되는지는 JVM이 실행되는 OS 플랫폼에 따라 많이 다르므로 이 값은 무시될 수 있음</li>
  <li>Thread 클래스를 상속하여 구현할 경우 생성자는 아래와 같이 호출
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class MyThread extends Thread {
      public MyThread(String name) {
          super(name); // 해당 이름을 가진 스레드 생성
      }

      @Override
      public void run() {
          System.out.println("스레드 실행 중: " + Thread.currentThread().getName());
      }
  }
</code></pre></div>    </div>
  </li>
  <li>스레드를 시작할 때 어떤 값(아래에선 message)을 전달하고 싶을 경우 아래와 같이 구현할 수 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class MyThread extends Thread {
      private String message;

      public MyThread(String name, String message) {
          super(name);
          this.message = message;
      }

      @Override
      public void run() {
          System.out.println(getName() + " : " + message);
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="54-synchronized">5.4 synchronized</h3>
<ul>
  <li>여러 스레드가 한 객체에 선언된 메소드에 접근하여 데이터를 처리하려 하면 값이 꼬일 수 있음. 메소드에서 인스턴스 변수를 수정할려고 할 때 발생하는 문제로, 매개변수나 메소드에서만 사용하는 지역변수만 다루는 메소드는 무관함</li>
  <li>synchronized는 2가지 방법으로 사용가능
    <ul>
      <li>메소드 자체를 synchronized로 선언</li>
      <li>메소드 내의 특정 문장만 synchronized로 감싸기</li>
    </ul>
  </li>
  <li>synchronized를 사용하면 이 메소드에 몇 개의 스레드가 접근하든 한 순간에는 하나의 스레드만 이 메소드를 수행하게 됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class CommonCalculate {
      private int amount = 0;

      public void plus(int value) {
          amount += value;
      }

      // 현재 값 조회
      public int getAmount() {
          return amount;
      }
  }

  public class ModifyAmountThread extends Thread {
      private CommonCalculate calc;

      public ModifyAmountThread(CommonCalculate calc) {
          this.calc = calc;
      }

      @Override
      public void run() {
          for (int i = 0; i &lt; 10000; i++) {
              calc.plus(1);
          }
      }
  }

  public class RunSync {
      public static void main(String[] args){
          RunSync runSync = new RunSync();
          runSync.runCommonCalculate();
      }
      public void runCommonCalculate(){
          CommonCalculate calc = new CommonCalculate();
          ModifyAmountThread thread1= new ModifyAmountThread(calc);
          ModifyAmountThread thread2= new ModifyAmountThread(calc);

          thread1.start();
          thread2.start();
          try {
              // join 메소드는 스레드가 종료될 때까지 기다리는 메소드
              thread1.join();
              thread2.join();
              System.out.println("Final value is " + calc.getAmount());
          } catch(InterruptedException e){
              e.printStackTrace();
          }
      }
  }
</code></pre></div>    </div>
  </li>
  <li>RunSync를 5번 실행하면 정상적이지 않은 결과를 확인할 수 있음. 한 스레드에서 plus(1)을 수행한 amount 값을 amount 인스턴수 변수에 치환하기전에 다른 스레드가 또 들어와 이 연산을 수행하려 하게 되고, 결과적으로 꼬이게 됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Final value is 16447
  Final value is 19782
  Final value is 13399
  Final value is 14543
  Final value is 20000
</code></pre></div>    </div>
  </li>
  <li>아래와 같이 plus() 메소드를 synchronized 함수로 만들면 동일한 20000이라는 결과를 받을 수 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      public synchronized void plus(int value) {
          amount += value;
      }
</code></pre></div>    </div>
  </li>
  <li>그러나 만약 synchronized 메소드에 여러 로직이 있고, 그중 amount 인스턴수 변수를 한 줄에서만 다룬다고 하면 나머지 로직들을 수행하는데 불필요한 대기 시간이 발생하여 성능에 문제가 발생함. 이런 경우 synchronized 블록이 권장됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  private final Object lock = new Object();

  public void plus(int value) {
      // synchronized 블록: lock 객체를 문지기로 사용
      synchronized (lock) {
          amount += value;
      }
  }
</code></pre></div>    </div>
  </li>
  <li>위에 선언된 lock 객체는 monitor 객체라 불리며, synchronized 블록의 공동 열쇠와 같음. 코드를 보호하려면 여러 스레드가 반드시 같은 monitor 객체를 공유해야 함</li>
  <li>만약 인스턴스 변수가 2개 이상이고, 2개의 메소드에서 각각 다른 인스턴스 변수만 수정한다면 서로 독립적으로 실행되도록 해야 함. 같은 monitor 객체를 두 개의 메소드에서 사용하면 락이 같이 걸리므로 각 메소드별로 다른 monitor 객체를 만들어야 함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class SeparateLockExample {
      private int value1 = 0;
      private int value2 = 0;

      // 메소드별 다른 monitor 객체
      private final Object lock1 = new Object();
      private final Object lock2 = new Object();

      public void incrementValue1() {
          synchronized (lock1) { // lock1을 문지기로 사용
              value1++;
              System.out.println(Thread.currentThread().getName() + " incrementValue1: " + value1);
          }
      }

      public void incrementValue2() {
          synchronized (lock2) { // lock2를 문지기로 사용
              value2++;
              System.out.println(Thread.currentThread().getName() + " incrementValue2: " + value2);
          }
      }
  }
</code></pre></div>    </div>
  </li>
  <li>위의 예제들에서 CommonCalculate를 사용하여 스레드 객체를 생성할 때는 당연히 같은 CommonCalculate 객체를 생성자에 전달해야 함. 동일한 객체를 참조하는 것이 아니라면 synchronized를 사용하는 의미가 없음</li>
  <li>자바의 신 vol.1에서 StringBuffer는 스레드에 안전하고 StringBuilder는 안전하지 않다고 언급되었는데, StringBuffer는 synchronized 블록으로 주요 데이터 처리 부분을 감싸두었고 StringBuilder는 그렇지 않기 때문. 따라서 StringBuffer는 하나의 문자열 객체를 여러 스레드에서 공유하는 경우에만 사용하고, 그렇지 않은 경우 StringBuilder를 사용하면 됨</li>
</ul>

<h3 id="55-thread-클래스-주요-메소드">5.5 Thread 클래스 주요 메소드</h3>

<h4 id="551-sleep-메소드">5.5.1 sleep 메소드</h4>
<ul>
  <li>Thread에 있는 static 메소드는 대부분 해당 스레드보다는 JVM에 있는 스레드를 관리하기 위한 용도로 사용되나, sleep 메소드는 예외</li>
  <li>종류
    <ul>
      <li>static void sleep(long millis) : 지정한 밀리초(ms) 동안 현재 스레드를 일시 정지</li>
      <li>static void sleep(long millis, int nanos) : 지정한 밀리초 + 나노초(ns) 동안 현재 스레드를 일시 정지</li>
    </ul>
  </li>
  <li>Thread.sleep() 메소드를 사용할 때는 항상 try-catch로 묶어 주어야 함. 또한 적어도 InterruptedException으로 catch 해주어야 함 (적어도라는 건 InterruptedException이나 해당 예외가 아니더라도 그 상위에 있는 예외로 받아주어야 한다는 의미)</li>
  <li>main() 메소드 수행이 끝나더라도 main() 메소드나 다른 메소드에서 시작한 스레드가 종료하지 않으면 자바 프로세스는 끝나지 않는데, 데몬 스레드는 예외임</li>
</ul>

<h4 id="552-스레드의-속성을-확인하고-지정하는-메소드">5.5.2 스레드의 속성을 확인하고 지정하는 메소드</h4>
<ul>
  <li>종류
    <ul>
      <li>void run()</li>
      <li>long getId() : 스레드의 고유 id 리턴. id는 JVM에서 자동으로 생성해줌</li>
      <li>String getName()</li>
      <li>void setName(String name)</li>
      <li>int getPriority() : 스레드 우선순위 확인</li>
      <li>void setPriority(int newPriority) : 스레드 우선순위 지정</li>
      <li>boolean isDaemon(boolean on) : 스레드가 데몬인지 확인</li>
      <li>StackTraceElement[] getStackTrace() : 스레드를 데몬으로 설정할지 말지 설정</li>
      <li>Thread.State getState()</li>
      <li>ThreadGroup getThreadGroup()</li>
    </ul>
  </li>
  <li>스레드의 우선 순위는 대기하고 있는 상황에서 더 먼저 수행할 수 있는 순위. 직접 설정하기 보단 기본값으로 사용하는 것이 권장됨</li>
  <li>Thread 클래스에 정의된 우선 순위와 관련된 3개의 상수가 있음. 우선 순위는 되도록 지정하지 않는 것이 좋으나 정할 일이 있다면 숫자보단 아래의 상수를 사용
    <ul>
      <li>MAX_PRIORITY : 가장 높은 우선순위로 값은 10</li>
      <li>NORM_PRIORITY : 일반 스레드의 우선순위로 값은 5</li>
      <li>MIN_PRIORITY : 가장 낮은 우선순위로 값은 1</li>
    </ul>
  </li>
  <li>스레드를 데몬 스레드로 지정하면 그 스레드가 수행되고 있든 아니든 상관없이 JVM이 종료될 수 있음. 단, 해당 스레드가 start()로 시작되기 전에 데몬 스레드로 지정되어야 함. 다른 스레드들의 종료 여부와는 별개로 별도의 모니터링 스레드 등을 띄우기 위해 사용</li>
</ul>

<h4 id="553-스레드를-통제하는-메소드">5.5.3 스레드를 통제하는 메소드</h4>
<ul>
  <li>종류
    <ul>
      <li>Thread.State getState(): 스레드의 상태 확인
        <ul>
          <li>리턴하는 Thread.State는 Thread 클래스에 선언된 enum 클래스. 이 클래스에 선언된 상수들은 아래와 같음
            <ul>
              <li>NEW : 스레드 객체는 생성되었지만 시작되지 않음</li>
              <li>RUNNABLE : 실행 중 또는 실행 대기 상태</li>
              <li>BLOCKED : 모니터 락을 기다리는 중</li>
              <li>WAITING : 다른 스레드의 특정 작업을 무기한 기다리는 중</li>
              <li>TIMED_WAITING : 일정 시간 동안 기다리는 상태</li>
              <li>TERMINATED : 실행 종료</li>
            </ul>
          </li>
          <li>이 enum 클래스는 public static으로 선언되어 Thread.State.NEW와 같이 사용 가능</li>
          <li>어떤 스레드든 NEW -&gt; [RUNNABLE, BLOCKED, WAITING, TIMED_WAITING] -&gt; TERMINATED 라이프 사이클을 가짐</li>
        </ul>
      </li>
      <li>void join() : 끝날 때까지 무제한 대기</li>
      <li>void join(long millis) : 특정 시간(ms) 동안만 대기</li>
      <li>void join(long millis, int nanos) : 더 정밀한 대기. 매개변수로 받은 millis + nanos만큼 대기하며, nanos는 1 밀리초 미만의 0~999,999까지만 지정 가능. 이 범위를 벗어나면 IllegalArgumentException을 발생시키며 중단됨</li>
      <li>void interrupt() : 수행중인 스레드 중지. InterruptedException을 발생시키면서 중단됨. (InterruptedException는 스레드가 sleep() 또는 join() 등으로 일시 정지된 상태일 때, 다른 스레드가 interrupt()를 호출하면 발생) 스레드가 시작하기 전이나 종료된 후에 호출하면 예외나 에러 없이 그냥 다음 문장으로 넘어감. 이전에는 stop()라는 메소드가 있었는데 안전상의 이유로 deprecated 됨</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class SleepThread extends Thread {
      long sleepTime;
      public SleepThread(long sleepTime) {
          this.sleepTime = sleepTime;
      }
      @Override
      public void run() {
          try {
              // Thread-0
              System.out.println("Sleeping " + getName());
              Thread.sleep(sleepTime);
              System.out.println("Stopping " + getName());
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }
  }

  public class RunSupportThreads {
      public static void main(String[] args) {
          RunSupportThreads sample = new RunSupportThreads();
          sample.checkThreadState1();
      }
      public void checkThreadState1() {
          SleepThread thread = new SleepThread(2000);

          try {
              // NEW
              System.out.println("thread state = " + thread.getState());
              thread.start();

              // RUNNABLE
              System.out.println("thread state (after start) = " + thread.getState());
              Thread.sleep(1000);

              // TIME_WAITING
              System.out.println("thread state (after 1 sec) = " + thread.getState());

              thread.join();
              thread.interrupt();

              // TERMINATED
              System.out.println("thread state (after join) = " + thread.getState());
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
      }
  }
</code></pre></div>    </div>
  </li>
  <li>
    <p>위 예제의 RunSupportThreads 출력 결과는 아래와 같음</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  thread state=NEW
  thread state(after start)=RUNNABLE
  Sleeping Thread-0
  thread state(after notify)=TIMED_WAITING
  Stopping Thread-0
  thread state(after join)=TERMINATED
</code></pre></div>    </div>
  </li>
  <li>
    <p>스레드 내부적으로 2초 동안 sleep하므로 메인 스레드에서 해당 스레드를 시작하고 1초 sleep 후 상태 출력하면 TIME_WAITING</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void checkJoin() {
      SleepThread thread = new SleepThread(2000);

      try {
          thread.start();
          thread.join(500);   // 0.5초 동안만 join
          thread.interrupt(); // 인터럽트 요청
          System.out.println("thread state (after join) = " + thread.getState());
      } catch (InterruptedException ie) {
          ie.printStackTrace();
      }
  }
</code></pre></div>    </div>
  </li>
  <li>
    <p>위와 같이 스레드가 종료되기전에 interrupt()를 호출하면 InterruptedException가 발생하게 됨.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  java.lang.InterruptedException: sleep interrupted
  thread state(after join)=TIMED_WAITING
      at java.lang.Thread.sleep(Native Method)
      at e.thread.support.SleepThread.run(SleepThread.java:11)
</code></pre></div>    </div>
  </li>
  <li>InterruptedException이 던져지는 순간 스레드가 곧바로 TERMINATED가 되는 게 아니라 예외가 끝나고 run() 메소드가 종료될 때 비로소 TERMINATED가 됨</li>
  <li>thread.join(5000)으로 늘리면 스레드가 종료될때까지 기다린 후 interrupt()하게 되므로 정상적인 결과 출력</li>
  <li>그 밖에 상태 확인을 위한 메소드로 현재 스레드가 해당 스레드에 대한 수정권한이 있는지 확인하는 checkAccess(), isAlive(), 다른 스레드가 interrupt로 종료되었는지 확인하는 isInterrupted(), 자신의 스레드가 interrupt로 종료되었는지 확인하는 interupted() 등이 있음</li>
  <li>Object 클래스에 선언된, 스레드와 관련있는 메소드 (synchronized 블록의 monitor 객체 기반으로 동작)
    <ul>
      <li>void wait() : monitor lock을 반납하고 스레드를 WAITING 상태로 만듦. 다른 스레드가 notify(), notifyAll() 호출할 때까지 대기</li>
      <li>void wait(long timeout) : 지정한 시간동안 대기(ms)</li>
      <li>void wait(long timeout, int nanos)</li>
      <li>void notify() : monitor에 대해 WAITING 중인 스레드 1개를 깨움</li>
      <li>void notifyAll() : monitor에 대해 WAITING 중인 모든 스레드를 깨움</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class StateThread extends Thread {

      private Object monitor;

      public StateThread(Object monitor) {
          this.monitor = monitor;
      }

      @Override
      public void run() {
          try {
              // 루프 동안 스레드를 실행중인 상태로 유지
              for (int loop = 0; loop &lt; 10000; loop++) {
                  String a = "A"; 
              }

              synchronized (monitor) {
                  monitor.wait();  // WAITING 상태 진입
              }

              System.out.println(getName() + " is notified.");

              Thread.sleep(1000); // TIMED_WAITING 상태
          } catch (InterruptedException ie) {
              ie.printStackTrace();
          }
      }
  }

  public class RunObjectThreads {
      public static void main(String args[]) {
          RunObjectThreads sample = new RunObjectThreads();
          sample.checkThreadState3();
      }
  }

  public void checkThreadState3() {
      Object monitor = new Object();
      StateThread thread = new StateThread(monitor);
      StateThread thread2 = new StateThread(monitor);

      try {
          System.out.println("thread state = " + thread.getState());

          thread.start();
          thread2.start();

          System.out.println("thread state (after start) = " + thread.getState());

          Thread.sleep(100);
          System.out.println("thread state (after 0.1 sec) = " + thread.getState());

          // notify는 반드시 synchronized(monitor) 블록 내부에서 수행해야 함
          synchronized (monitor) {
              monitor.notify();     // WAITING 중인 스레드 깨움
          }

          Thread.sleep(100);
          System.out.println("thread state (after notify) = " + thread.getState());

          thread.join();
          System.out.println("thread state (after join) = " + thread.getState());

          thread2.join();
          System.out.println("thread2 state (after join) = " + thread2.getState());
      } catch (InterruptedException ie) {
          ie.printStackTrace();
      }
  }
</code></pre></div>    </div>
  </li>
  <li>스레드 2개를 시작 후 스레드 내부와 메인 스레드 각각에 같은 monitor 객체를 공유하는 synchronized 블록이 있으므로 한 스레드가 wait 상태에 돌입하면 다른 한 스레드는 바로 notify()를 실행하여 깨우게 됨</li>
  <li>
    <p>출력 결과는 아래와 같음</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  thread state=NEW
  thread state(after start)=RUNNABLE
  thread state(after 0.1 sec)=WAITING
  Thread-0 is notified.
  thread state(after notify)=TIMED_WAITING
  thread state(after join)=TERMINATED
</code></pre></div>    </div>
  </li>
  <li>맨 마지막 출력인 “thread2 state (after join) = “ + thread2.getState()가 출력되지 않았는데 notify()를 호출하면 먼저 대기하고 있는 것부터 풀어주기 때문. synchronized 블록에서 notify()를 연달아 실행해도 되지만 wait 상태가 여러개인 경우도 있으므로 notifyAll()을 사용하는 것이 좋음</li>
  <li>wait()로 WAITING 상태가 된 경우 interrupt()로 대기 상태에서 풀려날 수도 있지만 notify()로 풀어야 예외도 발생하지 않고 wait() 이후의 문장도 정상적으로 수행함</li>
</ul>

<h4 id="554-threadgroup에서-제공하는-메소드">5.5.4 ThreadGroup에서 제공하는 메소드</h4>
<ul>
  <li>종류
    <ul>
      <li>int activeCount()	: 활성 스레드 수 리턴</li>
      <li>int activeGroupCount() : 활성 스레드 그룹의 개수 리턴</li>
      <li>int enumerate(Thread[] list) : list 매개변수로 현재 그룹 내 활성 스레드 목록 복사. 그룹에 있는 모든 스레드의 객체를 제대로 담으려면 activeCount() 메소드를 통해 활성 스레드 수를 정확히 파악한 후 그 개수만큼 배열을 생성해 넘겨야 함</li>
      <li>int enumerate(ThreadGroup[] list)	list 매개변수로 현재 스레드 그룹에 있는 모든 스레드 그룹 목록 복사</li>
      <li>String getName() : 그룹 이름 반환</li>
      <li>ThreadGroup getParent() : 부모 ThreadGroup 반환</li>
      <li>void list() : 스레드 그룹의 상세 정보 출력</li>
      <li>void setDaemon(boolean daemon) : 현재 스레드 그룹에 속한 스레드들을 데몬으로 지정</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class RunGroupThreads {

      public static void main(String[] args) {
          RunGroupThreads sample = new RunGroupThreads();
          sample.groupThread();
      }

      public void groupThread() {
          try {
              // SleepThread는 Thread를 상속한 클래스라고 가정
              SleepThread sleep1 = new SleepThread(5000);
              SleepThread sleep2 = new SleepThread(5000);

              // ThreadGroup 생성
              ThreadGroup group = new ThreadGroup("Group1");

              // Thread 생성, 그룹 지정, SleepThread(Runnable) 지정
              Thread thread1 = new Thread(group, sleep1, "Thread-1");
              Thread thread2 = new Thread(group, sleep2, "Thread-2");

              // 스레드 시작
              thread1.start();
              thread2.start();

              Thread.sleep(1000); // 잠시 대기

              // 그룹 정보 출력
              System.out.println("Group name = " + group.getName());

              int activeCount = group.activeCount();
              System.out.println("Active count = " + activeCount);

              group.list(); // 그룹 상태 출력

              // enumerate로 스레드 목록 가져오기
              Thread[] tempThreadList = new Thread[activeCount];
              int result = group.enumerate(tempThreadList);
              System.out.println("Enumerate result = " + result);

              // 스레드 이름 출력
              for (Thread thread : tempThreadList) {
                  System.out.println(thread);
              }

          } catch (Exception e) {
              e.printStackTrace();
          }
      }
  }
</code></pre></div>    </div>
  </li>
  <li>
    <p>출력된 결과는 아래와 같음</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Sleeping Thread-0
  Sleeping Thread-1
  Group name=Group1
  Active count=2
  java.lang.ThreadGroup[name=Group1,maxpri=10]
      Thread [Thread-2,5,Group1]
      Thread [Thread-3,5,Group1]
  Enumerate result=2
  Thread [Thread-2,5,Group1]
  Thread [Thread-3,5,Group1]
  Stopping Thread-0
  Stopping Thread-1
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="6-자바-io">6. 자바 I/O</h2>

<h3 id="61-개요">6.1 개요</h3>
<ul>
  <li>I/O는 프로그램에 있는 내용을 파일에 읽거나 저장할 일이 있을 때, 또는 다른 서버나 디바이스로 보낼 일이 있을 때 사용</li>
  <li>JVM을 기준으로 읽을 때에는 Input, 파일로 쓰거나 외부로 전송할 때에는 Output</li>
  <li>초기 단계의 자바에서는 I/O 처리를 위해 java.io 패키지에 있는 클래스를 제공했는데, 바이트 기반의 데이터를 처리하기 위해 여러 종류의 스트림이라는 클래스를 제공</li>
  <li>스트림은 끊기지 않고 연속적인 데이터를 말하며, 읽는 작업은 InputStream, 쓰는 작업은 OutputStream을 통해서 작업하도록 함</li>
  <li>바이트가 아닌 char 기반 문자열은 Reader, Writer를 사용</li>
  <li>JDK 1.4부터는 빠른 I/O를 위해 버퍼와 채널기반으로 데이터를 처리하는 NIO가, Java 7에서는 NIO2가 추가됨</li>
</ul>

<h3 id="62-file-클래스">6.2 File 클래스</h3>
<ul>
  <li>java.io 패키지에 있는 File 클래스. Java 7부터는 NIO2가 등장하며 java.nio.file 패키지의 Files 클래스가 더 많이 쓰임. 모든 메소드가 static으로 선언된 Files 클래스와 달리 File 클래스는 객체를 생성하여 사용해야 함</li>
  <li>생성자
    <ul>
      <li>File(String pathname)	단일 문자열 경로</li>
      <li>File(String parent, String child)	부모·자식 문자열 조합</li>
      <li>File(File parent, String child)	부모를 File 객체로 사용</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  import java.io.File;

  public class FileSample {
      public static void main(String[] args) {
          FileSample sample = new FileSample();

          String pathName = "C:\\godofjava\\text";
          // String pathName = "/godofjava/text";  // 유닉스

          sample.checkPath(pathName);
      }

      public void checkPath(String pathName) {
          File file = new File(pathName);
          file.mkdirs();
          System.out.println(pathName + " is exists? = " + file.exists());
      }
  }
</code></pre></div>    </div>

    <ul>
      <li>pathName을 보면 역슬래시가 연달아 \사용되고 있는데 자바에서 String 안에 역슬래시를 한 번만 쓰면 그 뒤에 단에 따라 약속된 특수기호로 인식하기 때문(\t, \n 등). 별개로 유닉스 계열 OS는 /로 디렉토리를 구분함</li>
      <li>위 예제에서 pathName은 디렉토리 경로이며 해당 경로의 디렉토리들(godofjava, text)을 생성하기 위해 mkdirs()메소드 사용. 만약 하나의 디렉토리만 생성하면 된다면 mkdir()을 사용하면 됨</li>
      <li>경로를 생성했으므로 \godofjava\text is exists = true가 출력됨</li>
    </ul>
  </li>
  <li>
    <p>파일 종류나 권한, 생성일을 확인하는 메소드는 아래 예제로 확인</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void checkFileMethods(String pathName) {
      File file = new File(pathName);

      System.out.println(pathName + " is directory? = " + file.isDirectory());
      System.out.println(pathName + " is file? = " + file.isFile());
      System.out.println(pathName + " is hidden? = " + file.isHidden());

      // 실행중인 자바 프로그램이 해당 File 객체에 대한 읽기/쓰기/실행 권한이 있는지 확인
      System.out.println(pathName + " can read? = " + file.canRead());
      System.out.println(pathName + " can write? = " + file.canWrite());
      System.out.println(pathName + " can execute? = " + file.canExecute());

      System.out.println(pathName + " last modified = " + new Date(file.lastModified()));
  }
</code></pre></div>    </div>
  </li>
  <li>파일을 삭제하려면 delete() 메소드 사용. 정상삭제된 경우 true를 반환함</li>
  <li>
    <p>디렉토리 파일이 아닌 일반 파일을 처리하고 확인하는 메소드는 아래 예제로 확인</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class FileManageClass {

      public static void main(String[] args) {
          FileManageClass sample = new FileManageClass();

          String pathName = File.separator + "godofjava" + File.separator + "text";
          String fileName = "test.txt";

          sample.checkFile(pathName, fileName);
      }

      public void checkFile(String pathName, String fileName) {
          File file = new File(pathName, fileName);

          try {
              System.out.println("Create result = " + file.createNewFile());
              getFileInfo(file);
          } catch (Exception e) {
              e.printStackTrace();
          }
      }

      public void getFileInfo(File file) throws IOException {
          System.out.println("Absolute path = " + file.getAbsolutePath());
          System.out.println("Absolute file = " + file.getAbsoluteFile());

          System.out.println("Canonical path = " + file.getCanonicalPath());
          System.out.println("Canonical file = " + file.getCanonicalFile());

          System.out.println("Name = " + file.getName());
          System.out.println("Path = " + file.getPath());
      }
  }
</code></pre></div>    </div>

    <ul>
      <li>createNewFile()로 비어있는 새 파일 생성. IOExcetpion을 던지므로 try-catch로 묶어줘야 함</li>
      <li>
        <p>출력 결과는 아래와 같음</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Create result = true    // 파일 생성 성공. 만약 이미 파일이 있었다면 false가 됨
  Absolute path = C:\godofjava\text\test.txt
  Absolute file = C:\godofjava\text\test.txt
  Canonical path= C:\godofjava\text\test.txt
  Canonical file = C:\godofjava\text\test.txt
  Name = test.txt
  Path = \godofjava\text\test.txt
</code></pre></div>        </div>
      </li>
      <li>getFileInfo()에서 ~Path()메소드는 전체 경로를 ~File() 메소드는 File 객체 리턴</li>
      <li>absolute path와 canonical path는 둘 다 절대경로이지만 표현 방식에 차이가 있음. absolute path가 현재 경로 기준으로 계산한 절대경로라면 canonical path는 파일 시스템 기준 유일하게 표현할 수 있는 절대경로
        <ul>
          <li>absolute path = C:\temp..\real\test.txt</li>
          <li>canonical path = C:\real\test.txt</li>
        </ul>
      </li>
      <li>File 객체가 일반 파일을 담고 있을 때 getPath()를 사용하면 경로+파일이름을 출력함. 경로만 출력하려면 file.getParent() 사용</li>
    </ul>
  </li>
  <li>디렉토리에 있는 목록을 확인하는 list 메소드
    <ul>
      <li>static File[] listRoots() : 파일 시스템의 루트 디렉터리 목록을 리턴. (예: “C:\”, “D:\”)</li>
      <li>String[] list() : 현재 디렉터리 하위 목록 리턴</li>
      <li>String[] list(FilenameFilter filter)</li>
      <li>File[] listFiles()</li>
      <li>File[] listFiles(FileFilter filter)</li>
      <li>File[] listFiles(FilenameFilter filter)</li>
    </ul>
  </li>
  <li>FileFilter와 FilenameFilter는 각각 accept라는 메소드가 정의된 인터페이스
    <ul>
      <li>FileFilter : boolean accept(File pathname)</li>
      <li>FilenameFilter : boolean accept(File dir, String name)
        <ul>
          <li>여기서 dir은 부모 디렉토리</li>
        </ul>
      </li>
      <li>인터페이스를 상속받아 accept를 구현한 필터를 정의하면서 필요한 목록만 검색하도록 할 수 있음. FilenameFilter가 파일 이름을 바로 알 수 있어 파일 확장자로 거르는 작업을 하기 용이해보이지만, 디렉터리와 파일을 구분하지 못하기 때문에 .jpg로 끝나는 디렉터리가 있으면 걸러낼 수가 없음</li>
      <li>fileName.endWith(“.jpg”) 같이 확장자를 걸러내는 필터 구현 가능</li>
    </ul>
  </li>
</ul>

<h3 id="63-inputstream과-outputstream">6.3 InputStream과 OutputStream</h3>
<ul>
  <li>자바 I/O는 기본적으로 InputStream과 OutputStream이라는 abstract 클래스를 통해 제공됨. 해당 클래스들의 자식 클래스들을 통해 읽고 쓸 수 있음</li>
  <li>InputStream은 Closeable 인터페이스를 구현하는데, 이 인터페이스를 구현하면 해당 리소스는 close() 메소드로 닫으라는 것을 의미함</li>
  <li>java.io 패키지에 있는 클래스를 사용할 때는 작업이 종료되면 해당 리소스를 다른 클래스에서 작업할 수 있도록 닫아줘야 함</li>
  <li>리소스는 스트림을 통해 작업할 수 있는 모든 것을 말하며 파일이 될 수도, 네트워크 연결이 될 수도 있음</li>
  <li>InputStream 클래스에는 다양한 메소드들이 선언되어 있는데, 가장 중요한 건 read(), close() 메소드</li>
  <li>InputStream을 확장한 클래스 중 주로 많이 사용되는 클래스로 FileInputStream, FilterInputStream, ObjectInputStream 등이 있음</li>
  <li>FilterInputStream의 생성자는 FileInputStream, ObjectInputStream와 달리 protected로 선언되어 상속 받은 클래스에서만 객체를 생성할 수 있음</li>
  <li>OutputStream은 Closeable, Flushable 인터페이스를 추가로 구현함. Flushable 인터페이스에는 flush() 메소드가 선언되어 있음. 리소스에 데이터를 쓸 때 매번 쓰기 작업을 요청할때 마다 저장하면 효율이 안 좋으므로 버퍼를 두고 어느정도 차게 되면 한번에 저장하는데 flush()는 현재 버퍼에 있는 내용을 기다리지 말고 바로 저장하는 것</li>
  <li>OutputStream는 write(), flush(), close() 메소드를 가지며 OutputStream을 확장한 자식클래스는 InputStream와 종류가 비슷함</li>
  <li>스트림은 byte를 다루기 위한 것으로 주로 네트워크를 처리할 때 사용되며 char 기반의 문자열을 처리할 때는 Reader, Writer을 쓰는 편이 좋음</li>
</ul>

<h3 id="64-reader와-writer">6.4 Reader와 Writer</h3>
<ul>
  <li>Reader는 Readable, Closeable 인터페이스를 구현한 추상 클래스로 InputStream과 유사한 메소드들을 가짐. Reader를 확장한 클래스들 중에서는 BufferedReader, InputStreamReader가 많이 사용됨</li>
  <li>Writer는 Appendable, Closeable, Flushable 인터페이스를 구현한 추상 클래스. OutputStream와 유사한 메소드를 갖고 있지만 append()라는 메소드가 존재한다는 점이 다름
    <ul>
      <li>Writer append(char c)</li>
      <li>Writer append(CharSequence csq)</li>
      <li>Writer append(CharSequence scq, int start, int end) : 매개 변수로 넘어온 CharSequence 값을 해당 CharSequence 값의 start 인덱스부터 end 인덱스까지만 추가</li>
      <li>CharSequence 인터페이스의 대표적인 구현 클래스에는 StringBuilder, StringBuffer가 있으며 이것은 대부분의 문자열을 다 받아서 처리한다는 의미</li>
      <li>문자열이 String 타입이면 write() 메소드를 사용해도 무방하나 StringBuilder, StringBuffer로 문자열을 만들면 append() 사용하는 게 훨씬 편함</li>
    </ul>
  </li>
  <li>
    <p>아래는 Writer 추상 클래스의 구현 중 하나인 FileWriter 클래스 예제. FileWriter는 파일에 문자 단위로 데이터를 기록할 때 주로 사용됨</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class ManageTextFile {

      public static void main(String[] args) {
          ManageTextFile manager = new ManageTextFile();

          int numberCount = 10;
          String fullPath = File.separator + "godofjava" + File.separator + "text"
                  + File.separator + "numbers.txt";

          manager.writeFile(fullPath, numberCount);
      }

      public void writeFile(String fileName, int numberCount) {
          FileWriter fileWriter = null;
          BufferedWriter bufferedWriter = null;

          try {
              File file = new File(fileName);

              // 현재 파일 객체의 상위 디렉토리 경로를 생성
              file.getParentFile().mkdirs();

              // Writer는 파일이 없으면 새로 생성해줌
              fileWriter = new FileWriter(file);  

              // Writer 객체를 매개변수로 받아 BufferedWriter 객체 생성
              bufferedWriter = new BufferedWriter(fileWriter);    

              for (int i = 0; i &lt;= numberCount; i++) {
                  bufferedWriter.write(Integer.toString(i));
                  bufferedWriter.newLine();   // 줄 바꿈
              }

              System.out.println("Write success !!!");

          } catch (IOException ioe) {
              ioe.printStackTrace();
          } catch (Exception e) {
              e.printStackTrace();
          } finally {
              if (bufferedWriter != null) {
                  try {
                      bufferedWriter.close();
                  } catch (IOException ioe) {
                      ioe.printStackTrace();
                  }
              }

              if (fileWriter != null) {
                  try {
                      fileWriter.close();
                  } catch (IOException ioe) {
                      ioe.printStackTrace();
                  }
              }
          }
      }
  }
</code></pre></div>    </div>

    <ul>
      <li>Writer의 write(), append()는 버퍼없이 바로 쓰므로 대신 BufferedWriter 클래스를 사용함</li>
      <li>FileWriter 객체 생성 시 IOException이 발생할 수 있으므로 try-catch로 감싸줘야 함. 여기서 IOException은 다음의 상황에서 발생할 수 있음
        <ul>
          <li>매개 변수로 넘어온 파일 이름이 파일이 아닌 경로</li>
          <li>해당 파일을 권한 등의 문제로 생성 불가</li>
          <li>파일이 존재하지만 여러 이유로 파일을 열 수가 없음</li>
        </ul>
      </li>
      <li>try 블록에 close()를 넣으면 중간에 예외가 발생할 경우 호출되지 않을 수 있으므로 finally 블록에 넣어줘야 함. finally에서 FileWriter, BufferedWriter 객체를 close()하려면 try 문장 전에 선언해줘야 함</li>
      <li>예제에서 FileWriter, BufferedWriter 순으로 객체를 생성했는데, 닫아줄대는 생성할때의 역순으로 닫아줘야 정상적인 처리가 가능함</li>
      <li>FileWriter 생성자는 FileWriter(File)외에도 여러가지가 있는데 FileWriter(File file, boolean append)에서 append 값을 true로 지정하면 다시 생성자를 실행할 때 기존 파일에 붙여쓰기가 되고, false이면 덮어쓰기가 됨</li>
    </ul>
  </li>
  <li>
    <p>FileReader 클래스를 이용한 텍스트 파일 읽기 예제는 위의 FileWriter 예제에서 Writer를 Reader로 변경해주면 나머지는 유사하며, try 블록에서 데이터를 읽는 부분만 다름</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String data;
  while ((data=bufferedReader.readLine()) != null){
      System.out.println(data);
  }
</code></pre></div>    </div>

    <ul>
      <li>while 소괄호 안에 두개 이상의 문장이 포함될 수 없기때문에 readLine()으로 읽어들인 데이터를 data에 담아 null인지 확인하는 위와 같은 방법을 주로 사용</li>
    </ul>
  </li>
  <li>java.util 패키지의 Scanner 클래스나 Java 7에서 제공하는 Files 클래스를 사용하면 훨씬 쉽게 파일을 읽을 수 있음. Scanner 클래스는 텍스트 기반의 기본 자료형이나 문자열 데이터를 처리하기 위한 클래스로 정규 표현식을 사용하여 데이터를 잘라 처리할 수도 있음</li>
</ul>

<h2 id="7-serializable과-nio">7. Serializable과 NIO</h2>

<h3 id="71-serializable">7.1 Serializable</h3>
<ul>
  <li>Serializable 인터페이스 자체에는 아무런 메소드도 정의되어 있지 않지만, 만든 클래스가 파일에 읽거나 쓸 수 있게 하거나 다른 서버로 보내거나 받을 수 있게 하려면 이 인터페이스를 구현해야 함</li>
  <li>Serializable 인터페이스를 구현한 후에는 serialVersionUID 값을 지정해 주는 것이 좋음. 별도로 지정하지 않으면 자바 소스가 컴파일될 때 자동 생성됨</li>
  <li>static final long serialVersionUID = 1L; 과 같이 반드시 static final long serialVersionUID으로 선언해야 함. serialVersionUID는 해당 객체의 버전을 명시하는데 사용</li>
  <li>코드에서 해당 객체를 읽어올 때 읽어오는 쪽에서도 해당 클래스가 존재하여 현재 JVM에 로드되어야 함. 이 때 클래스 이름이 같더라도 이 ID가 다르면 다른 클래스로 인식함. 또한 같은 ID라도 변수의 개수나 타입 등이 다르면 다른 클래스로 인식함</li>
</ul>

<h4 id="711-객체-저장-및-읽기">7.1.1 객체 저장 및 읽기</h4>
<ul>
  <li>
    <p>ObjectOutputStream 클래스를 이용하여 객체를 저장할 수 있음</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class SerialDTO implements Serializable {

      private String bookName;
      private int bookOrder;
      private boolean bestSeller;
      private long soldPerDay;

      public SerialDTO(String bookName, int bookOrder, boolean bestSeller, long soldPerDay) {
          super();
          this.bookName = bookName;
          this.bookOrder = bookOrder;
          this.bestSeller = bestSeller;
          this.soldPerDay = soldPerDay;
      }

      @Override
      public String toString() {
          return "SerialDTO [bookName=" + bookName +
                  ", bookOrder=" + bookOrder +
                  ", bestSeller=" + bestSeller +
                  ", soldPerDay=" + soldPerDay +
                  "]";
      }
  }
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class ManageObject {

      public static void main(String[] args) {
          ManageObject manager = new ManageObject();

          String fullPath = separator + "godofjava" + separator + "text"
                  + separator + "serial.obj"; // 객체는 .obj 파일에 저장

          SerialDTO dto = new SerialDTO("GodOfJavaBook", 1, true, 100);

          manager.saveObject(fullPath, dto);
      }

      public void saveObject(String fullPath, SerialDTO dto) {
          FileOutputStream fos = null;
          ObjectOutputStream oos = null;

          try {
              fos = new FileOutputStream(fullPath);   // FileOutputStream 객체 생성
              oos = new ObjectOutputStream(fos);       // 생성한 FileOutputStream 객체를 매개변수로 넘겨 해당 객체가 fullPath 파일에 저장되게 함

              oos.writeObject(dto);                    // 직렬화하여 파일에 쓰기
              System.out.println("Write Success");

          } catch (Exception e) {
              e.printStackTrace();

          } finally {
              // ObjectOutputStream 닫기
              if (oos != null) {
                  try {
                      oos.close();
                  } catch (Exception e) {
                      e.printStackTrace();
                  }
              }

              // FileOutputStream 닫기
              if (fos != null) {
                  try {
                      fos.close();
                  } catch (Exception e) {
                      e.printStackTrace();
                  }
              }
          }
      }
  }
</code></pre></div>    </div>
  </li>
  <li>만약 위의 SerialDTO에서 Serializable 인터페이스를 구현하지 않았을경우 실행하면 NotSerializableException 발생</li>
  <li>위 예제 실행 시 C:\godofjava\text 디렉터리에 serial.obj 파일이 생성됨. 객체는 바이너리로 저장되어 확인해보긴 어려움</li>
  <li>
    <p>객체를 읽어오려면 앞 예제와 동일하게 Output 대신 Input으로 된 클래스들을 사용하면 됨. 달리 바뀐 부분은 try 블록의 아래와 같음</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // saveObject() 메소드와 유사
  public void loadObject(String fullPath){
      ...
      try {
          fis = new FileInputStream(fullPath);
          ois = new ObjectInputStream(fis); 

          // readObject() 메소드의 리턴 타입이 Object이므로 형 변환
          Object obj = ois.readObject();
          SerialDTO dto = (SerialDTO)obj;
          System.out.println(dto);
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>
    <p>출력 결과는 아래와 같음</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  SerialDTO [bookName=GodOfJavaBook, bookOrder=1, bestSeller=true, soldPerDay=100]
</code></pre></div>    </div>
  </li>
  <li>만약 SerialDTO 클래스에 인스턴스 변수를 새로 추가해서 다시 실행하면 SerialVersionUID가 다르다는 InvalidClassException 예외 메시지가 출력됨. Serializable을 구현한 객체의 형태가 변경되면 컴파일 시 serialVersionUID가 다시 생성됨</li>
  <li>SerialDTO 클래스에 private static final long serialVersionUID = 1L;를 추가하고 saveObject()를 다시 실행하여 obj 파일 내용 갱신 후 loadObject() 재실행하면 정상 실행됨</li>
  <li>
    <p>만약 serialVersionUID는 같은데 저장되어 있는 객체(현재 JVM에 로드된 객체)에 bookName 인스턴스 변수명을 bookNames로 읽는 객체와 다르게 하면 해당 값은 null로 처리됨. 저장되어 있는 객체에서 찾지 못하기 때문</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  SerialDTO [bookNames=null, bookOrder=1, bestSeller=true, soldPerDay=100]
</code></pre></div>    </div>
  </li>
  <li>위와 같이 null로 처리될 뿐 예외가 발생하진 않지만, 내용이 바뀌어도 알 수가 없으므로 데이터가 바뀌면 serialVersionUID의 값도 바꾸는 습관을 가져야 함</li>
</ul>

<h4 id="712-transient-예약어">7.1.2 transient 예약어</h4>
<ul>
  <li>
    <p>아래와 같이 Serializable을 구현한 클래스 인스턴스 변수의 선언문 앞에 transient 예약어 추가</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  transient private int bookOrder;
</code></pre></div>    </div>
  </li>
  <li>
    <p>transient 예약어를 사용하여 선언한 변수는 Serializable 대상(저장 대상)에서 제외됨. 따라서 출력이 아래와 같이 0으로 됨</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  SerialDTO [bookName=GodOfJavaBook, bookOrder=0, bestSeller=true, soldPerDay=100]
</code></pre></div>    </div>
  </li>
  <li>
    <p>패스워드 변수처럼 보안상 중요한 변수나 꼭 저장해야 할 필요가 없는 변수에 사용</p>
  </li>
</ul>

<h3 id="72-nio">7.2 NIO</h3>
<ul>
  <li>JDK 1.4부터 제공되는 NIO는 오로지 속도 때문에 추가됨</li>
  <li>NIO는 스트림 대신 채널과 버퍼를 사용함. 채널은 물건을 중간에서 처리하는 도매상, 버퍼는 도매상에게서 물건을 사고 소비자에게 파는 소매상과 비슷함. 데이터를 주고받을 때는 소매상인 버퍼를 통해 처리</li>
  <li>NIO에서 제공하는 Buffer는 java.nio.Buffer 클래스를 확장하여 제공되며, ByteBuffer, CharBuffer, DoubleBuffer.. 및 기타 등등 여러 확장이 있음</li>
  <li>버퍼의 상태 및 속성을 확인하기 위한 메소드
    <ul>
      <li>int capacity() : 버퍼 크기 리턴</li>
      <li>int limit() : 읽기 또는 쓰기 가능한 최대 위치 리턴</li>
      <li>int position() : 현재 버퍼의 위치 리턴</li>
    </ul>
  </li>
  <li>버퍼에서 위치를 변경하는 메소드
    <ul>
      <li>Buffer flip() : limit 값을 현재 position으로 변경 후 position을 0으로 이동</li>
      <li>Buffer mark() : 현재 position을 mark</li>
      <li>Buffer reset() : 버퍼의 position을 mark한 곳으로 이동</li>
      <li>Buffer rewind() : 현재 버퍼의 position을 0으로 이동</li>
      <li>int remaining() : limit - position 계산 결과 리턴</li>
      <li>boolean hasRemaining() : postion과 limit 값에 차이가 있을 경우 true 리턴</li>
      <li>Buffer clear() : 버퍼 내용을 지우고 현재 position 0으로 이동, limit 값을 버퍼 크기로 변경</li>
    </ul>
  </li>
  <li>NIO는 파일을 읽고 쓰거나 복사 또는 네트워크로 데이터를 주고 받을 때도 사용할 수 있음</li>
  <li>
    <p>파일 read/write 예제</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void writeFile(String fileName, String data) throws Exception {
      FileChannel channel = new FileOutputStream(fileName).getChannel();

      byte[] byteData = data.getBytes();
      ByteBuffer buffer = ByteBuffer.wrap(byteData);

      channel.write(buffer);
      channel.close();
  }
</code></pre></div>    </div>

    <ol>
      <li>FileOutputStream 클래스의 getChannel() 메소드를 호출하여 FileChannel 객체 생성</li>
      <li>ByteBuffer의 wrap() static 메소드를 호출하여 ByteBuffer 객체 생성. wrap()은 이미 있는 배열을 그대로 버퍼로 감싸서 사용함</li>
      <li>FileChannel 객체의 write() 메소드에 ByteBuffer 객체를 넘겨 파일에 쓰도록 함</li>
    </ol>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void readFile(String fileName) throws Exception {
      FileChannel channel = new FileInputStream(fileName).getChannel();

      ByteBuffer buffer = ByteBuffer.allocate(1024);

      channel.read(buffer);
      buffer.flip();

      while (buffer.hasRemaining()) {
          System.out.print((char) buffer.get());
      }

      channel.close();         // 마지막에 닫기
  }
</code></pre></div>    </div>

    <ol>
      <li>FileInputStream 클래스의 getChannel() 메소드를 호출하여 FileChannel 객체 생성</li>
      <li>지정한 크기의 byte 버퍼를 생성하는 ByteBuffer의 allocate() 메소드 실행</li>
      <li>FileChannel 객체의 read() 메소드에 ByteBuffer 객체를 넘겨 데이터가 담기게 함</li>
      <li>ByteBuffer의 get() 메소드는 한 바이트씩 데이터 읽는 작업 수행</li>
    </ol>
  </li>
</ul>

<h2 id="8-네트워크-프로그래밍">8. 네트워크 프로그래밍</h2>

<h3 id="81-socket-클래스를-사용한-tcp-통신">8.1 Socket 클래스를 사용한 TCP 통신</h3>
<ul>
  <li>데이터 전송을 보장하는 TCP 통신을 위해 java.net 패키지의 Socket 클래스를 사용하여 데이터 전송</li>
  <li>Socket 클래스 객체를 데이터를 보내는 쪽(주로 클라이언트)에서 생성해서 사용하면, 데이터를 받는 쪽(주로 서버)에서 요청에 대한 Socket 객체를 생성하여 데이터를 처리. Socket 객체는 서로 원격에 있는 장비와의 연결 상태를 보관함</li>
  <li>데이터를 보내는 쪽에서는 Socket 클래스를, 받는 쪽에서는 ServerSocket 클래스를 사용. 받는 쪽에선 new로 Socket 객체 생성할 것 없이 ServerSocket 클래스가 제공하는 메소드에서 클라이언트 요청을 감지하면 Socket 객체를 자동 생성하여 전달해줌</li>
  <li>ServerSocket 생성자
    <ul>
      <li>ServerSocket()	포트 없이 생성 → 나중에 bind() 가능</li>
      <li>ServerSocket(int port)	포트 지정</li>
      <li>ServerSocket(int port, int backlog)	포트 + 대기 큐 크기 지정</li>
      <li>ServerSocket(int port, int backlog, InetAddress bindAddr)	포트 + 대기 큐 + 특정 IP 에 바인딩</li>
    </ul>
  </li>
  <li>backlog는 ServerSocket 객체가 바빠서 연결 요청을 바로 처리하지 못하고 대기시킬 때 대기 큐의 크기. 지정하지 않으면 50개가 기본값</li>
  <li>bindAddr는 특정 주소에서만 접근이 가능하도록 지정할 때 사용</li>
  <li>ServerSocket()을 제외한 생성자들을 사용하면 객체 생성 즉시 연결을 대기할 수 있는 상태가 되며, ServerSocket()는 accept 메소드를 통해 별도의 연결작업을 해야 함
    <ul>
      <li>Socket accept() : 새로운 소켓 연결을 기다리고 연결되면 Socket 객체 리턴</li>
      <li>void close() : 소켓 연결을 종료</li>
    </ul>
  </li>
  <li>close() 안하면 JVM에서 계속 동작되므로 해당 포트를 다른 프로그램에서 사용할 수 없음</li>
  <li>Socket 클래스 생성자
    <ul>
      <li>Socket()</li>
      <li>Socket(Proxy proxy)</li>
      <li>Socket(SocketImpl impl)</li>
      <li>Socket(InetAddress address, int port)</li>
      <li>Socket(InetAddress address, int port, InetAddress localAddr, int localPort)</li>
      <li>Socket(String host, int port)</li>
      <li>Socket(String host, int port, InetAddress localAddr, int localPort)</li>
    </ul>
  </li>
  <li>위의 3개 생성자를 제외한 나머지 생성자들은 모두 객체 생성과 함께 지정된 서버에 접속함</li>
  <li>Socket(String host, int port)가 가장 사용하기 편리함</li>
  <li>마찬가지로 close()는 필수</li>
  <li>
    <p>아래는 소켓을 대기하는 서버 예제</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void startServer() {
      ServerSocket server = null;
      Socket client = null;

      try {
          server = new ServerSocket(9999);
          System.out.println("Server started.");

          while (true) {
              System.out.println("Server: Waiting for request.");
              client = server.accept();
              System.out.println("Server: Accepted.");

              InputStream stream = client.getInputStream();
              BufferedReader in = new BufferedReader(
                      new InputStreamReader(stream));

              String data;
              StringBuilder receivedData = new StringBuilder();

              while ((data = in.readLine()) != null) {
                  receivedData.append(data);
              }

              System.out.println("Received data: " + receivedData);

              in.close();
              stream.close();
              client.close();

              // EXIT 메시지 받으면 서버 종료
              if ("EXIT".equals(receivedData.toString())) {
                  System.out.println("Stop SocketServer");
                  break;
              }
          }

      } catch (Exception e) {
          e.printStackTrace();
      } finally {
          if (server != null) {
              try {
                  server.close();
              } catch (Exception e) {
                  e.printStackTrace();
              }
          }
      }
  }  
</code></pre></div>    </div>
  </li>
  <li>9999번 포트에서 대기. accept()로 원격 호출 대기상태로 전환하고 socket 객체를 리턴받아 client 변수에 할당</li>
  <li>Socket 클래스의 getInputStream() 메소드로 데이터를 읽기 위한 InputStream 객체를 받음. 상대에게 데이터를 쓰는(전송하는) 쪽은 getOutputStream() 사용</li>
  <li>
    <p>아래는 데이터를 전송하는 클라이언트 예제</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void sendSocketSample() {
      for (int loop = 0; loop &lt; 3; loop++) {
          sendSocketData("I liked java at " + new Date());
      }
      sendSocketData("EXIT");
  }

  public void sendSocketData(String data) {
      Socket socket = null;

      try {
          System.out.println("Client: Connecting");
          socket = new Socket("127.0.0.1", 9999);   // 서버 접속
          System.out.println("Client: Connect status=" + socket.isConnected());

          Thread.sleep(1000); // 현재 실행 중인 스레드를 1초 동안 멈춤

          OutputStream stream = socket.getOutputStream();
          BufferedOutputStream out = new BufferedOutputStream(stream);

          byte[] bytes = data.getBytes();
          out.write(bytes);                         // 데이터 전송
          out.flush();

          System.out.println("Client: Sent data" + data);

          out.close();
          stream.close();

      } catch (Exception e) {
          e.printStackTrace();
      } finally {
          if (socket != null) {
              try {
                  socket.close();                   // 소켓 종료
              } catch (Exception e) {
                  e.printStackTrace();
              }
          }
      }
  }    
</code></pre></div>    </div>
  </li>
  <li>같은 장비의 같은 포트로 소켓 객체 생성(127.0.0.1, 9999)</li>
  <li>out.close() 를 호출하면 out 이 감싸고 있는 기반(OutputStream)도 같이 닫히지만 BufferedOutputStream 을 제거하거나 구조가 바뀔 때를 대비하여 명시적으로 해주는 게 좋음</li>
  <li>위의 예제를 실행하며 발생할 수 있는 예외는 2가지가 있음
    <ul>
      <li>java.net.BindException (Address already in use) : 이미 해당 포트로 서버를 띄워놓음</li>
      <li>java.net.ConnectException (Connection refused) : 서버 실행 안하고 클라이언트 프로그램만 실행했을 때</li>
    </ul>
  </li>
</ul>

<h3 id="82-datagramsocket-클래스를-사용한-udp-통신">8.2 DatagramSocket 클래스를 사용한 UDP 통신</h3>
<ul>
  <li>데이터의 유실이 있어도 문제가 없을 때 사용. TCP보다 빠름</li>
  <li>DatagramSocket 클래스 하나에서 보내는 역할과 받는 역할을 모두 수행하며, 스트림을 사용하지 않고 DatagramPacket이라는 클래스를 사용함</li>
  <li>DatagramSocket 클래스 생성자
    <ul>
      <li>DatagramSocket() : 포트 자동 배정</li>
      <li>DatagramSocket(DatagramSocketImpl impl)</li>
      <li>DatagramSocket(int port)</li>
      <li>DatagramSocket(int port, InetAddress laddr)</li>
      <li>DatagramSocket(SocketAddress bindaddr) : IP+포트 혼합 바인딩</li>
    </ul>
  </li>
  <li>마찬가지로 close() 메소드로 닫아주어야 하며, 데이터를 주고 받기위해 아래 메소드 제공
    <ul>
      <li>void receive(DatagramPacket packet) : 데이터를 받기 위해 대기. 데이터를 받으면 packet 객체에 저장</li>
      <li>void send(DatagramPacket packet) : packet 객체에 있는 데이터 전송</li>
    </ul>
  </li>
  <li>DatagramPacket 클래스 생성자
    <ul>
      <li>DatagramPacket(byte[] buf, int length) : 유일한 수신용 객체 생성자</li>
      <li>DatagramPacket(byte[] buf, int length, InetAddress addr, int port)</li>
      <li>DatagramPacket(byte[] buf, int offset, int length)</li>
      <li>DatagramPacket(byte[] buf, int offset, int length, InetAddress addr, int port)</li>
      <li>DatagramPacket(byte[] buf, int offset, int length, InetAddress addr)</li>
      <li>DatagramPacket(byte[] buf, int length, InetAddress addr)</li>
    </ul>
  </li>
  <li>byte[] buf는 전송되는 데이터. offset을 넣을 경우 해당 offset (위치)값부터 데이터를 전송</li>
  <li>length는 byte[] buf에서 몇 바이트를 전송하거나 수신하는 데 사용할 것인지를 지정하므로, length가 byte[] buf 크기보다 크게 설정되면 IllegalArgumentException 발생</li>
  <li>DatagramPacket 클래스의 주요 메소드로 getData()는 바이트 배열로 전송받은 데이터를 리턴하고 getLength()는 전송받은 데이터의 길이를 int 타입으로 리턴</li>
  <li>
    <p>아래는 UDP 통신 서버 쪽 예제</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void startServer() {
      DatagramSocket server = null;

      try {
          server = new DatagramSocket(9999);
          int bufferLength = 256;
          byte[] buffer = new byte[bufferLength];

          DatagramPacket packet = new DatagramPacket(buffer, bufferLength);

          while (true) {
              System.out.println("Server: Waiting for request.");

              server.receive(packet);

              int dataLength = packet.getLength();  // 실제 수신 데이터 길이
              System.out.println("Server: received. Data length=" + dataLength);

              String data = new String(packet.getData(), 0, dataLength);
              System.out.println("Received data: " + data);

              if ("EXIT".equals(data)) {
                  System.out.println("Stop DatagramServer");
                  break;
              }
          }

      } catch (Exception e) {
          e.printStackTrace();
      } finally {
          if (server != null) {
              server.close();
          }
          ...
      }
  }
</code></pre></div>    </div>
  </li>
  <li>new String(packet.getData(), 0, dataLength);로 UDP로 받은 바이트 데이터를 실제 수신 길이만큼 문자열로 변환</li>
  <li>
    <p>아래는 UDP 통신 클라이언트 쪽 예제</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void sendDatagramData(String data) {
      DatagramSocket client = null;
      try {
          client = new DatagramSocket();
          InetAddress address = InetAddress.getByName("127.0.0.1");
          byte[] buffer = data.getBytes();
          DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 9999);

          client.send(packet);
          System.out.println("Client: Sent data");

          client.close();
          Thread.sleep(1000);

      } catch (Exception e) {
          e.printStackTrace();
      }
      ...
</code></pre></div>    </div>
  </li>
  <li>UDP는 TCP와 다르게 데이터가 성공적으로 전송되지 않아도 예외를 발생시키지 않으므로, 서버 프로그램 없이 클라이언트만 실행시켜도 System.out.println(“Client: Sent data”);가 정상 출력됨</li>
</ul>

<h2 id="9-java-7">9. Java 7</h2>

<h3 id="91-java-7에서-달라진-것들">9.1 Java 7에서 달라진 것들</h3>
<ul>
  <li>숫자 표시 방법 보완
    <ul>
      <li>
        <p>byte, short, int, long과 같은 정수형은 원래 8, 10, 16 진수로 표현이 가능했음. 숫자 앞에 아무런 접두사가 없으면 10진수, 숫자 앞에 0을 넣으면 8진수, 0x를 숫자 앞에 넣으면 16진수</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int decVal = 1106;
  int octVal = 02122;
  int hexVal = 0x452;
</code></pre></div>        </div>
      </li>
      <li>위의 값들을 println으로 출력하면 모두 10진수로 출력됨(1106)</li>
      <li>
        <p>Java 7부터는 2진수 표현이 추가됨. 숫자 앞에 0b를 추가</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int binaryVal = 0b10001010010;
</code></pre></div>        </div>
      </li>
      <li>또한 숫자 단위에 구분자 _ 를 추가할 수 있음. _는 무조건 숫자 사이에만 넣어줄 수 있음
        <ul>
          <li>숫자 사이면 가능하므로 진수 표현 접두사를 예시로 들면
            <ul>
              <li>0b_101010 -&gt; 불가능</li>
              <li>0_101010 -&gt; 가능</li>
            </ul>
          </li>
        </ul>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int binary = 0b100_0101_0010;
  int million = 1_000_000;
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>switch 문에서 String 사용 가능
    <ul>
      <li>Java 6까지는 switch-case 문장에 정수형만 사용 가능했는데, 7부터는 String도 사용가능</li>
      <li>String 을 사용할 경우 문자열이 null이면 NullPointerException 발생하므로 null 체크 필수</li>
    </ul>
  </li>
  <li>제네릭을 쉽게 사용할 수 있는 Diamond &lt;&gt;
    <ul>
      <li>
        <p>이전까지는 제네릭을 사용할 때 생성자에도 해당 타입들을 상세하게 명시했어야 했음</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  HashMap&lt;String, Integer&gt; map = HashMap&lt;String, Integer&gt;();
</code></pre></div>        </div>
      </li>
      <li>
        <p>Java 7부터는 &lt;&gt;를 쓰면 변수 선언에 명시된 타입으로 자동으로 채워짐</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  HashMap&lt;String, Integer&gt; map = HashMap&lt;&gt;();
</code></pre></div>        </div>
      </li>
      <li>
        <p>유의할 점</p>
        <ul>
          <li>
            <p>아래와 같이 &lt;&gt; 없이 모두 명시적으로 지정하면 당연히 문제가 없음. 생성자에 &lt;&gt;를 빼먹어도 경고가 발생하긴 하지만 실행엔 큰 문제가 없음</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class GenericClass &lt;X&gt; {
      private X x;
      private Object o;
      public &lt;T&gt; GenericClass (T t){
          this.o=t;
          System.out.println("T type="+t.getClass().getName());
      }
                
      public void setValue(X x){
          this.x = x;
          System.out.println("X type="+x.getClass().getName());
      }
  }

  public void makeObjects3(){
      GenericClass&lt;Integer&gt; generic1 = new &lt;String&gt; GenericClass&lt;Integer&gt;("String");  // &lt;&gt; 없이 모두 명시
      GenericClass&lt;Integer&gt; generic2 = new &lt;String&gt; GenericClass("String");   // 생성자에 &lt;&gt; 빼먹음
      GenericClass&lt;Integer&gt; generic3 = new &lt;String&gt; GenericClass&lt;&gt;("String"); // 에러
      generic1.setValue(999);
  }
</code></pre></div>            </div>
          </li>
          <li>
            <p>단, 생성자에 있는 new와 클래스 이름 사이에 타입 이름을 명시적으로 두려면 &lt;&gt;를 사용하면 안됨. 따라서 generic3 생성자 부분은 에러가 발생함</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>@SafeVarargs 어노테이션
    <ul>
      <li>제네릭 사용 시 발생 가능한 문제 중 하나로 reifiable 하지 않은 가변 매개변수(varargs) 타입이 있음</li>
      <li>reifiable 하다는 건 런타임에도 타입 정보가 남아있는 타입. int 같은 기본형, String, List, List&lt;?&gt; 같은 타입이 해당함</li>
      <li>non reifiable은 컴파일 시 타입 정보가 손실되는 타입으로 List<String> 같은 제네릭이 해당함</String></li>
      <li>
        <p>Collections.addAll() 메소드는 가변 매개 변수를 사용하는데, 매개 변수로 제네릭 타입 객체를 넘기면 경고가 발생함. 제네릭 매개 변수가 내부적으로는 Object 배열로 처리되기 때문</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // api 문서 상의 addAll
  public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements)

  // 내부적으로는 Object 배열로 처리
  public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, java.lang.Object[] elements)
</code></pre></div>        </div>
      </li>
      <li>제네릭 <T>은 한 가지 타입인데 Object 배열로 매개변수를 받게되며 여러 타입 객체들이 들어가게 될 수 있으므로, 잠재적으로 문제가 발생할 수 있음</T></li>
      <li>이러한 경고를 없애려면 @SafeVarargs 어노테이션을 메소드 선언부에 추가하면 됨. 컴파일러에게 이 메서드는 가변 제네릭 매개변수 배열을 안전하게 다룬다고 알려주는 것</li>
      <li>@SafeVarargs는 아래의 조건일 때 사용 가능
        <ul>
          <li>가변 매개 변수를 사용하고</li>
          <li>final이나 static 또는 private(이건 Java 9부터)로 선언되어 있음
            <ul>
              <li>부모 메서드에 안전하다는 의미로 @SafeVarargs를 붙여도 자식 클래스에서 오버라이딩하면서 heap pollution이 발생할 수 있음</li>
              <li>해당 메소드를 오바라이딩 할 수 없게 해야함</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>단, @SafeVarargs 어노테이션을 사용해도 가변 매개 변수가 reifiable 타입이고 메소드 내에서 매개 변수를 다른 변수에 대입하는 작업을 수행할 경우 경고가 발생함</li>
    </ul>
  </li>
  <li>예외 처리 시 다중 처리 기능
    <ul>
      <li>
        <p>Java 7부터 catch 블록에서 처리하는 방식이 동일하다면 아래와 같이 파이프(<code class="language-plaintext highlighter-rouge">|</code>) 로 묶을 수 있음</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Scanner scanner = null;
  try {
      scanner = new Scanner(new File(fileName), encoding);
      System.out.println(scanner.nextLine());
  } catch(IllegalArgumentException | FileNotFoundException | NullPointer Exception exception){
      exception.printStackTrace();
  } finally {
      ...
  }
</code></pre></div>        </div>
      </li>
      <li>AutoCloseable 인터페이스가 추가됨. java.io.Closable 인터페이스를 구현한 클래스 중 이 인터페이스를 구현한 클래스는 별도의 close() 호출이 필요없는 try-with-resource 사용 가능</li>
      <li>try-with-resource를 사용하여 위의 예제를 아래와 같이 단순화
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  try (Scanner scanner=new Scanner(new File(fileName), encoding)){
      System.out.println(scanner.nextLine());
  } catch(IllegalArgumentException | FileNotFoundException | NullPointer Exception exception){
      exception.printStackTrace();
  } 
</code></pre></div>        </div>
      </li>
      <li>finally 문장에서 close()를 처리하기 위해 선언문을 try 위로 올려 가독성을 떨어뜨릴 필요가 없어짐</li>
      <li>try의 소괄호 내에서 2개 객체를 생성할 필요가 있으면 세미콜론(;)으로 구분하여 같이 생성해주면 됨</li>
    </ul>
  </li>
</ul>

<h3 id="92-java-7에서-추가된-것들">9.2 Java 7에서 추가된 것들</h3>

<h4 id="921-work-stealing">9.2.1 Work Stealing</h4>
<ul>
  <li>Work Stealing은 다중 스레드 환경에서 각 스레드가 자신의 작업 큐(Deque)를 가지고 작업을 처리하다가, 작업이 부족한 스레드가 다른 스레드의 Deque에서 남은 작업을 반대쪽 끝(top)에서 가져가는 방식
    <ul>
      <li>Deque는 양방향 큐로 양쪽 끝에서 삽입/삭제 가능</li>
    </ul>
  </li>
  <li>각 스레드는 자신의 Deque의 bottom에서 작업을 꺼내 처리하며, 다른 스레드가 훔쳐갈 때는 top에서 가져가므로 경합을 최소화할 수 있음</li>
  <li>자바에서 Fork/Join을 사용하면 해당 라이브러리에서 Work steal 작업을 알아서 수행함</li>
  <li>Fork는 작업을 여러 개로 나누어 여러 스레드에서 실행되게 하고, Join은 여러 스레드에서 수행한 결과를 모으는 것</li>
  <li>
    <p>Fork/Join 작업의 기본 수행 개념은 아래와 같음</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if(작업의 단위가 충분히 작을 경우){
      해당 작업을 수행 (연산을 수행)
  } else {
      작업을 반으로 쪼개어 두 개의 작업으로 나눔 &lt;- 시작와 끝 값을 반으로 쪼개 해당 함수를 다시 실행해야함 (Recursive)
      두 작업을 동시 실행시키고, 두 작업이 끝날 때까지 결과를 기다림
  }
</code></pre></div>    </div>
  </li>
  <li>위와 같은 방식으로 Fork/Join이 실행되기 때문에 이 연산은 Recursive하게 수행될 때 많이 사용됨</li>
  <li>Fork/Join 기능은 java.util.concurrent 패키지의 RecursiveAction과 RecursiveTask라는 abstract 클래스를 사용해야 함
    <ul>
      <li>public abstract class RecursiveAction extends ForkJoinTask&lt;Void&gt;</li>
      <li>public abstract class RecursiveTask&lt;V&gt; extends ForkJoinTask&lt;V&gt;</li>
    </ul>
  </li>
  <li>두 클래스가 확장한 ForkJoinTask이라는 abstract 클래스는 Future라는 인터페이스를 구현했는데, 비동기적인 요청을 하고 응답을 기다릴 때 사용되는 인터페이스임</li>
  <li>Fork/Join 작업을 수행하려면 RecursiveAction 또는 RecursiveTask 클래스를 확장하여 연산을 처리하는 compute() 메소드 구현</li>
  <li>
    <p>작업을 수행하는 클래스는 ForkJoinPool 클래스를 사용하여 시작되게 함</p>

    <table>
      <thead>
        <tr>
          <th> </th>
          <th>Fork/Join 클라이언트 밖에서 호출</th>
          <th>Fork/Join 클라이언트 내에서 호출</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>비동기적 호출 수행</td>
          <td>execute(ForkJoinTask)</td>
          <td>ForkJoinTask.fork()</td>
        </tr>
        <tr>
          <td>호출 후 결과 대기(동기)</td>
          <td>invoke(ForkJoinTask)</td>
          <td>ForkJoinTask.invoke()</td>
        </tr>
        <tr>
          <td>호출 후 Future 객체 수신</td>
          <td>submit(ForkJoinTask)</td>
          <td>ForkJoinTask.fork()</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>아래는 0부터 10까지 더하는 연산을 Fork/Join으로 작업하는 예제</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class GetSum2 extends RecursiveTask&lt;Long&gt; {
      long from, to;

      public GetSum2(long from, long to) {
          this.from = from;
          this.to = to;
      }

      @Override
      public Long compute() {
          long gap = to - from;

          // Sleep for logging clarity
          try {
              Thread.sleep(1000);
          } catch (Exception e) {
              e.printStackTrace();
          }

          log("From=" + from + " To=" + to);

          // Base condition: small range -&gt; direct computation
          if (gap &lt;= 3) {
              long tempSum = 0;
              for (long loop = from; loop &lt;= to; loop++) {
                  tempSum += loop;
              }
              log("Return !! " + from + " ~ " + to + " = " + tempSum);
              return tempSum;
          }

          long middle = (from + to) / 2;

          // First half
          GetSum2 sumPre = new GetSum2(from, middle);
          log("Pre  From=" + from + " To=" + middle);
          sumPre.fork();  // async

          // Second half
          GetSum2 sumPost = new GetSum2(middle + 1, to);
          log("Post From=" + (middle + 1) + " To=" + to);

          // Combine result
          return sumPost.compute() + sumPre.join();
      }

      public void log(String message) {
          String threadName = Thread.currentThread().getName();
          System.out.println("[" + threadName + "] " + message);
      }
  }
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class ForkJoinSample2 {
      static final ForkJoinPool mainPool = new ForkJoinPool();

      public static void main(String[] args) {
          ForkJoinSample2 sample = new ForkJoinSample2();
          sample.calculate();
      }

      public void calculate() {
          long from = 0;
          long to = 10;

          GetSum2 sum = new GetSum2(from, to);
          Long result = mainPool.invoke(sum);

          System.out.println("Fork Join: Total sum of " + from + " ~ " + to + " = " + result);
      }
  }
</code></pre></div>    </div>

    <ul>
      <li>작업이 빠르게 처리되어 출력이 안정적으로 되지 않을 수 있어 Thread.sleep(1000)로 지연 추가</li>
      <li>.compute()는 작업을 즉시 수행하고 .fork()는 비동기 작업 수행이므로 작업을 대기큐에 쌓아둠. 따라서 .compute()로 수행한 작업이 더 먼저 시작됨</li>
      <li>동시 실행을 위해 .compute()로 현재 스레드에서 작업을 처리하는 동시에 .join()으로 다른 쪽의 작업 완료를 기다림</li>
      <li>
        <p>직접 실행했을 때 결과는 아래와 같이 출력됨. 출력 순서는 실행 시마다 조금씩 달라질 수 있음</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [ForkJoinPool-1-worker-1] From=0 To=10
  [ForkJoinPool-1-worker-1] Pre  From=0 To=5
  [ForkJoinPool-1-worker-1] Post From=6 To=10
  [ForkJoinPool-1-worker-1] From=6 To=10
  [ForkJoinPool-1-worker-2] From=0 To=5
  [ForkJoinPool-1-worker-1] Pre  From=6 To=8
  [ForkJoinPool-1-worker-2] Pre  From=0 To=2
  [ForkJoinPool-1-worker-1] Post From=9 To=10
  [ForkJoinPool-1-worker-2] Post From=3 To=5
  [ForkJoinPool-1-worker-2] From=3 To=5
  [ForkJoinPool-1-worker-4] From=0 To=2
  [ForkJoinPool-1-worker-1] From=9 To=10
  [ForkJoinPool-1-worker-3] From=6 To=8
  [ForkJoinPool-1-worker-3] Return !! 6 ~ 8 = 21
  [ForkJoinPool-1-worker-2] Return !! 3 ~ 5 = 12
  [ForkJoinPool-1-worker-4] Return !! 0 ~ 2 = 3
  [ForkJoinPool-1-worker-1] Return !! 9 ~ 10 = 19
  Fork Join: Total sum of 0 ~ 10 = 55
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="922-nio2">9.2.2 NIO2</h4>
<ul>
  <li>Java 7부터 제공되는 NIO2는 java.io 패키지의 File 클래스의 미흡한 부분을 보완하기 위해 나왔으며 NIO와 이름은 비슷하지만 크게 관련은 없음. 패키지도 java.io인 NIO와 달리 java.nio</li>
  <li>이전에 지원하지 않았던 파일의 속성, 심볼릭 링크 처리, 파일의 권한을 처리할 수 있고 파일을 삭제하는 delete() 메소드가 실패 시에도 아무런 예외를 발생시키지 않던 문제 보완. 또한 파일이 변경되었는지 여부를 연계된 클래스가 많아 성능상 지장을 주던 lastModified() 메소드를 호출하지 않고도 확인할 수 있게 함</li>
  <li>NIO2에서 File 클래스를 대체하는 클래스
    <ul>
      <li>Paths
        <ul>
          <li>생성자가 없지만 대신 get()이라는 static 메소드로 Path 인터페이스 객체 생성 가능
            <ul>
              <li>static Path get(String first, String… more)</li>
              <li>static Path get(URI uri)</li>
              <li>Java 7부터 java.io 패키지의 File 클래스의 toPath() 메소드를 통해서도 얻을 수 있음</li>
            </ul>
          </li>
          <li>Path는 파일과 경로에 대한 정보를 가짐</li>
        </ul>
      </li>
      <li>Files</li>
      <li>FileSystems
        <ul>
          <li>현재 사용중인 파일 시스템에 대한 정보를 처리하는 메소드들 제공. getDefault() 메소드로 FileSystem 인터페이스 객체를 얻을 수 있음</li>
        </ul>
      </li>
      <li>FileStore
        <ul>
          <li>파일을 저장하는 디바이스, 파티션, 볼륨 등에 대한 정보 확인</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>아래는 Path의 메소드를 확인할 수 있는 예제</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class PathsAndFiles {
      public static void main(String[] args) {
          PathsAndFiles sample = new PathsAndFiles();

          String dir = "C:\\godofjava\\nio\\nio2";
          String dir2 = "C:\\WINDOWS";

          sample.checkPath2(dir, dir2);
      }

      public void checkPath(String dir) {
          Path path = Paths.get(dir);
          System.out.println(path.toString());      // C:\godofjava\nio\nio2
          System.out.println(path.getFileName());   // nio2
          System.out.println(path.getNameCount());  // 3
          System.out.println(path.getParent());     // C:\godofjava\nio
          System.out.println(path.getRoot());       // C:\         
      }

      public void checkPath2(String dir1, String dir2) {
          Path path1 = Paths.get(dir1);
          Path path2 = Paths.get(dir2);

          // 상대 경로 계산 ..\..\..\WINDOWS
          Path relativized = path1.relativize(path2);

                   
          System.out.println("relativized path = " + relativized);

          // 절대 경로 C:\godofjava\..\..\..\WINDOWS
          Path absolute = relativized.toAbsolutePath();
          System.out.println("toAbsolutePath path = " + absolute);

          // 정규화 C:\WINDOWS
          Path normalized = absolute.normalize();
          System.out.println("normalized path = " + normalized);

          // 경로 결합 C:\godofjava\nio\nio2\godofjava
          Path resolved = path1.resolve("godofjava");
          System.out.println("resolved path = " + resolved);
      }
  }
</code></pre></div>    </div>
  </li>
  <li>Files 클래스 주요 기능
    <ul>
      <li>파일, 디렉터리 등 생성 : createDirectory(), createFile(), createSymbolicLink().. 및 기타 등등</li>
      <li>삭제 : delete(), deleteIfExists()
        <ul>
          <li>실패 시 지우지 않고 예외 발생</li>
        </ul>
      </li>
      <li>읽기와 쓰기 : readAllBytes(), readAllLines(), readAttributes(), write().. 및 기타 등등
        <ul>
          <li>write() 메소드는 두가지
            <ul>
              <li>public static Path write(Path path, byte[] bytes, OpenOption… options)</li>
              <li>public static Path write(Path path, Iterable&lt;? extends CharSequence&gt; lines, Charset cs, OpenOption… options)</li>
            </ul>
          </li>
          <li>readAllLines()는 크기가 큰 파일에 사용하면 OutOfMemoryError가 발생할 수 있음</li>
          <li>Iterable&lt;? extends CharSequence&gt; lines 매개변수에는 Iterable을 구현한 ArrayList, 제네릭으로 String 같은 값이 들어갈 수 있음 (ArrayList&lt;String&gt;)</li>
          <li>OpenOption은 파일을 열 때의 조건으로 StandardOpenOption이라는 Enum 클래스 값이 들어갈 수 있음. 선언된 항목은 아래와 같음
            <ul>
              <li>APPEND</li>
              <li>CREATE : 파일이 존재하지 않으면 새로 생성</li>
              <li>CREATE_NEW</li>
              <li>DELETE_ON_CLOSE</li>
              <li>DSYNC</li>
              <li>READ</li>
              <li>SPARSE</li>
              <li>SYNC</li>
              <li>TRUNCATE_EXISTING</li>
              <li>WRITE</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>복사 및 이동 : copy(), move()
        <ul>
          <li>아래는 copy() 메소드 매개변수로 들어가는 StandardCopyOption Enum 클래스 항목들
            <ul>
              <li>ATOMIC_MOVE</li>
              <li>COPY_ATTRIBUTES</li>
              <li>REPLACE_EXISTING</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Stream 및 객체 생성
        <ul>
          <li>위의 읽기와 쓰기 메소드를 사용할 때보다 코드가 길어질 수 있지만, 여러 번에 걸쳐 파일에 데이터를 쓰거나, 버퍼 제어나 flush 제어 등 세밀한 조정 가능</li>
          <li>newBufferedReader(), newBufferedWriter(), newInputStream.. 및 기타 등등</li>
        </ul>
      </li>
      <li>각종 확인 : get으로 시작하는 메소드와 is로 시작하는 메소드들로 파일의 상태를 확인</li>
      <li>임시 디렉터리, 파일 생성
        <ul>
          <li>createTempDirectory(), createTempFile()</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>WatchService 클래스
    <ul>
      <li>이전에는 파일이 변경되었는지 확인하기 위해 성능상 비효율적인 lastModified() 함수를 호출하여 기존에 저장된 시간과 비교해야 했으나, 주기적으로 호출해야한다는 단점 존재</li>
      <li>
        <p>Java 7부터는 WatchService 인터페이스를 사용하여 파일 생성, 수정, 삭제 작업 모니터링 가능</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class WatcherSample extends Thread {
      String dirName;

      public static void main(String args[]) throws Exception {
          String dirName = "C:\\godofjava";
          String fileName = "WatcherSample.txt";

          WatcherSample sample = new WatcherSample(dirName);
          sample.setDaemon(true);
          sample.start(); // 스레드 시작

          Thread.sleep(1000);

          for (int loop = 0; loop &lt; 10; loop++) {
              sample.fileWriteDelete(dirName, fileName + loop);
          }
      }

      public WatcherSample(String dirName) {
          this.dirName = dirName;
      }

      @Override
      public void run() {
          System.out.println("### Watcher thread is started ###");
          System.out.format("Dir=%s\n", dirName);
          addWatcher();
      }

      public void addWatcher() {
          try {
              Path dir = Paths.get(dirName);
              WatchService watcher = FileSystems.getDefault().newWatchService();

              // 디렉토리에 watcher 등록
              WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);

              while (true) {
                  System.out.println("Watcher waiting for events...");

                  // 이벤트 발생까지 대기 (blocking)
                  key = watcher.take();

                  // 발생한 이벤트 목록 가져오기
                  List&lt;WatchEvent&lt;?&gt;&gt; eventList = key.pollEvents();

                  for (WatchEvent&lt;?&gt; event : eventList) {
                      Kind&lt;?&gt; kind = event.kind();
                      Path name = (Path) event.context();

                      if (kind == ENTRY_CREATE) {
                          System.out.format("%s created%n", name);
                      } else if (kind == ENTRY_DELETE) {
                          System.out.format("%s deleted%n", name);
                      } else if (kind == ENTRY_MODIFY) {
                          System.out.format("%s modified%n", name);
                      }
                  }

                  // 다시 감시하도록 reset
                  key.reset();
              }

          } catch (IOException | InterruptedException e) {
              e.printStackTrace();
          }
      }
      ...
  }
</code></pre></div>        </div>

        <ul>
          <li>WatchService 객체를 얻는 가장 쉬운 방법은 FileSystems.getDefault()로 기본 파일 시스템 객체를 얻은 후 newWatchService() 호출하여 얻는 것</li>
          <li>register() 메소드로 어떤 작업에 대해 감시할지 지정. 위의 예제에선 Path와 관련된 StandardWatchEventKinds 클래스의 상수 3가지를 지정함
            <ul>
              <li>public WatchKey register(WatchService watcher, WatchEvent.Kind&lt;?&gt;… events)</li>
              <li>public WatchKey register(WatchService watcher, WatchEvent.Kind&lt;?&gt;[] events, WatchEvent.Modifier… modifiers)</li>
            </ul>
          </li>
          <li>WatchEvent 인터페이스에 선언된 context() 메소드 호출하면 객체 선언 시 선언했던 제네릭 타입 객체를 리턴하는데, 일반적으로 dir.register(…)로 Path dir을 등록하므로 Path 객체가 리턴됨</li>
          <li>데몬 스레드로 실행했으므로 메인스레드에서 while 메소드가 종료되지 않아도 프로그램이 자동으로 멈추며, 데몬 스레드는 다른 모든 일반스레드가 종료되어 JVM이 종료될 때 끝남</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="10-java-8">10. Java 8</h2>

<h3 id="101-java-8에서-추가된-것들">10.1 Java 8에서 추가된 것들</h3>
<ul>
  <li>Optional
    <ul>
      <li>NullPointerException을 방지하고 null 처리를 간편하게 하기 위해 만들어진 클래스</li>
      <li>public final class Optional&lt;T&gt; extends Object로, final 클래스이므로 확장이 불가능</li>
      <li>생성자로 객체를 생성하지 않고 대신 Optional 객체를 리턴하는 아래의 메소드 사용
        <ul>
          <li>empty() : 데이터가 없는 Optional 객체 생성</li>
          <li>ofNullable() : value가 null일 수도, 아닐 수도 있는 경우 사용</li>
          <li>of() : null이 아닌 값을 담은 Optional 객체를 생성</li>
        </ul>
      </li>
      <li>Optional 객체가 비어있는지는 isPresent() 메소드로 확인</li>
      <li>값을 꺼내는 메소드
        <ul>
          <li>get()</li>
          <li>orElse() : 값이 없을 경우 매개변수의 데이터로 기본값 지정</li>
          <li>orElseGeta() : 매개변수에 Supplier&lt;T&gt;라는 Functional 인터페이스를 활용. Supplier&lt;T&gt;의 get 메소드에서 기본값을 리턴하도록 구현</li>
          <li>orElseThrow() : 데이터가 없을 경우 예외를 발생. Supplier&lt;T&gt;의 get 메소드가 예외를 리턴하도록 구현</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Default method
    <ul>
      <li>인터페이스에 아래와 같이 default를 붙인 구현된 메소드를 추가할 수 있게 됨
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public interface DefaultStaticInterface {
      default String getEmail(){
          return "@godofjava.com";
      }
  }
</code></pre></div>        </div>
      </li>
      <li>전세계 사람들이 사용하는 오픈 소스 코드가 있을 때, 해당 인터페이스에 새로운 메소드를 추가해야 할 경우 사용중인 사람들은 모두 오류가 발생하여 코드를 고쳐야 하는 일이 발생할 수 있음. default 메소드는 새로 구현할 필요가 없기때문에 그런 위험을 방지함</li>
    </ul>
  </li>
  <li>날짜 관련 클래스들
    <ul>
      <li>이전에 사용하던 Date나 SimpleDateFormatter 클래스는 스레드에 안전하지 않으며, 불변객체가 아니어서 지속적으로 값 변경이 가능. 또한 API 구성이 복잡하게 되어있어 달은 1, 일은 0부터 시작함</li>
      <li>이러한 이슈때문에 Java 8에서는 java.time이라는 패키지를 만듦</li>
    </ul>
    <table border="1" cellspacing="0" cellpadding="6">
  <tr>
      <th>내용</th>
      <th>버전</th>
      <th>패키지</th>
      <th>설명</th>
  </tr>
  <tr>
      <td rowspan="2">값 유지</td>
      <td>예전 버전</td>
      <td>java.util.Date<br />java.util.Calendar</td>
      <td>
      Date 클래스는 날짜 계산을 할 수 없다.<br />
      Calendar 클래스는 불변 객체가 아니므로 연산시 객체 자체가 변경되었다.
      </td>
  </tr>
  <tr>
      <td>Java 8</td>
      <td>java.time.ZonedDateTime<br />java.time.LocalDate</td>
      <td>
      ZonedDateTime과 LocalDate 등은 불변 객체이다.<br />
      모든 클래스가 연산용의 메소드를 갖고 있으며,<br />
      연산시 새로운 불변 객체를 돌려 준다.<br />
      그리고 스레드에 안전하다.
      </td>
  </tr>
  <tr>
      <td rowspan="2">변경</td>
      <td>예전 버전</td>
      <td>java.text.SimpleDateFormat</td>
      <td>
      SimpleDateFormat는 스레드 안전하지도 않고 느리다.
      </td>
  </tr>
  <tr>
      <td>Java 8</td>
      <td>java.time.format.DateTimeFormatter</td>
      <td>
      DateTimeFormatter는 스레드 안전하며 빠르다.
      </td>
  </tr>
  <tr>
      <td rowspan="2">시간대</td>
      <td>예전 버전</td>
      <td>java.util.TimeZone</td>
      <td>
      "Asia/Seoul"이나 "+09:00" 같은 정보를 가진다.
      </td>
  </tr>
  <tr>
      <td>Java 8</td>
      <td>
          java.time.ZoneId
          java.time.ZoneOffset
      </td>
      <td>
      ZoneId는 "Asia/Seoul"라는 정보를 갖고 있고,<br />
      ZoneOffset는 "+09:00" 라는 정보를 가지고있다.
      </td>
  </tr>
  <tr>
      <td rowspan="3">속성 관련</td>
      <td>예전 버전</td>
      <td>java.util.Calendar</td>
      <td>
      Calendar.YEAR<br />
      Calendar.MONTH<br />
      Calendar.DATE (Calendar.DAY_OF_MONTH)<br />
      등 이들은 정수(int)이다.
      </td>
  </tr>
  <tr>
      <td rowspan="2">Java 8</td>
      <td>java.time.temporal.ChronoField</td>
      <td>
      ChronoField.YEAR<br />
      ChronoField.MONTH_OF_YEAR<br />
      ChronoField.DAY_OF_MONTH<br />
      등이 enum 타입이다.
      </td>
  </tr>
  <tr>
      <td>java.time.temporal.ChronoUnit</td>
      <td>
      ChronoUnit.YEARS (연수)<br />
      ChronoUnit.MONTHS (개월)<br />
      ChronoUnit.DAYS (일)<br />
      등이 enum 타입이다.
      </td>
  </tr>
  </table>

    <ul>
      <li>시간을 나타내는 3가지 계열의 클래스들이 추가됨
        <ul>
          <li>Local : 타임존 없이 날짜와 시간만 표현</li>
          <li>Offset : UTC 기준 고정 오프셋을 숫자로 설정 (+09:00 → ZoneOffset.ofHours(9) 등)</li>
          <li>Zoned : 타임존 이름(ZoneId) 사용하여 시간 설정 (“Asia/Seoul”, “America/New_York”)</li>
        </ul>
      </li>
      <li>
        <p>요일을 더 편하게 표현할 수 있는 DayOfWeek enum 클래스 추가됨. DayOfWeek는 MONDAY 부터 SUNDAY까지의 상수를 가짐</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  private void printDayOfWeek(){

      // DayOfWeek enum의 모든 값을 배열로 가져옴
      DayOfWeek[] dayOfWeeks = DayOfWeek.values();

      // 시스템의 기본 로케일을 가져옴 (한국 시스템이면 Locale.KOREA)
      // locale에 따라 언어가 달라짐
      Locale locale = locale.getDefault();

      for(DayOfWeek day : daayOfWeeks){
          System.out.println(day.getDisplayName(TextStyle.FULL, locale)+ " ");
          System.out.println(day.getDisplayName(TextStyle.SHORT, locale)+ " ");
          System.out.println(day.getDisplayName(TextStyle.NARROW, locale)+ " ");
      }
  }
</code></pre></div>        </div>
      </li>
      <li>getDisplayName(TextStyle.FULL, locale)은 요일 이름을 지정된 스타일과 로케일에 맞게 출력
        <ul>
          <li>TextStyle 옵션:
            <ul>
              <li>FULL → “Monday”, “Tuesday” (전체 이름)</li>
              <li>SHORT → “Mon”, “Tue” (줄임말)</li>
              <li>NARROW → “M”, “T” (한 글자 표기)</li>
            </ul>
          </li>
          <li>한국은 SHORT와 NARROW의 차이가 없음</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>배열을 병렬로 정렬하는 메소드
    <ul>
      <li>배열을 정렬하려면 java.util.Array의 sort() 메소드를 사용하면 간편함</li>
      <li>하지만 더 빠른 처리를 원한다면 Java 8에서 추가된  parallelSort() 메소드를 사용할 수 있음. Fork-Join 프레임워크를 이용하여 배열 정렬을 여러 스레드로 처리함</li>
      <li>크기가 큰 배열에서는 parallelSort() 메소드가 sort()보다 더 빠름</li>
    </ul>
  </li>
  <li>StringJoiner
    <ul>
      <li>여러 문자열을 구분자를 넣어 이어 붙일 때 사용</li>
      <li>
        <p>선택 사항으로 시작과 끝 지정 가능</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  StringJoiner sj = new StringJoiner(", ", "[", "]"); // 구분자, 시작, 끝
  sj.add("Red");
  sj.add("Green");
  sj.add("Blue");

  System.out.println(sj.toString());
</code></pre></div>        </div>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [Red, Green, Blue]  //출력 결과
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="102-java-8에서-변경된-것들">10.2 Java 8에서 변경된 것들</h3>
<ul>
  <li>Lamda 표현식
    <ul>
      <li>메소드가 하나인 인터페이스를 간단하게 표현하는 방식. 메소드가 하나인 인터페이스를 Functional 인터페이스라고 함</li>
      <li>람다 클래스는 익명 클래스로 전환이 가능하며, 메소드가 하나일 경우 그 역도 성립함</li>
      <li>Java에 정의된 하나의 메소드를 가진 많은 인터페이스들을 Lamda 표현식으로 전환 가능. 대표적으로 Runnable과 Comparator이 있음</li>
      <li>(매개 변수 목록) -&gt; 처리식으로 람다를 표현하며, 처리식이 한 줄 이상일 때는 처리식을 중괄호로 묶을 수 있음</li>
      <li>다른 사람이 Functional 인터페이스에 메소드를 더 추가하게 되면 이미 람다 표현식을 사용중일 경우 에러가 발생하므로, 인터페이스 위에 @FunctionalInterface를 사용하여 하나의 메소드만 정의되도록 강제할 수 있음</li>
      <li>아래는 Java 8에서 제공하는 주요 Functional 인터페이스
        <ul>
          <li>Predicate
            <ul>
              <li>
                <p>boolean을 리턴하는 test() 메소드가 있으며 추가로 and(), negate(), or()이라는 default 메소드가 있음. default 메소드와 함께 사용하려면 아래와 같이 사용</p>

                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String godOfJava = "GodOfJava";

  Predicate&lt;String&gt; predicateLength5 = (a) -&gt; a.length() &gt; 5;
  Predicate&lt;String&gt; predicateContains = (a) -&gt; a.contains("God");

  predicateLength5.and(predicateContains).test(godOfJava);
</code></pre></div>                </div>
              </li>
            </ul>
          </li>
          <li>Supplier
            <ul>
              <li>generic으로 선언된 타입을 리턴하는 get() 메소드가 있음</li>
            </ul>
          </li>
          <li>Consumer
            <ul>
              <li>리턴값이 없는 accept() 라는 매개변수를 하나 갖는 메소드가 있으며 출력처럼 리턴이 필요 없는 작업에 사용. 추가로 andThen()이라는 default 메소드가 있으며 순차적인 작업을 할 때 사용</li>
            </ul>
          </li>
          <li>Function
            <ul>
              <li>하나의 매개 변수를 갖는 apply() 메소드가 있음. Function&lt;T, R&gt;로 apply()에 대한 매개변수 타입, 리턴 타입이 되는 2개 Generic 타입을 가짐. 변환을 할 때 사용</li>
            </ul>
          </li>
          <li>UnaryOperator
            <ul>
              <li>하나의 generic 타입으로 매개변수(1개)와 리턴값의 타입이 같은 apply() 메소드를 가짐</li>
            </ul>
          </li>
          <li>BinaryOperator
            <ul>
              <li>UnaryOperator와 유사하나 매개변수가 2개이며, generic은 마찬가지로 하나이므로 2개 매개변수와 리턴값의 타입이 같음</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>stream
    <ul>
      <li>스트림은 연속된 정보를 처리할 때 사용. 가장 기본적인 건 배열과 컬렉션인데, Collection에는 Stream 인터페이스 객체를 생성하는 stream() 메소드가 정의되어 있지만 배열에는 따로 없으므로 변환이 필요함</li>
      <li>
        <p>배열을 List 컬렉션으로 변환하는 방법도 있지만 아래와 같이 배열을 다루기 위한 유틸리티 클래스 Arrays의 stream()의 매개변수로 넣어도 됨</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  List&lt;Integer&gt; list = Arrays.stream(배열변수).종단연산  // Stream 객체 리턴
</code></pre></div>        </div>
      </li>
      <li>
        <p>스트림은 아래와 같은 구조를 가짐</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Collection객체.stream().중개연산.종단연산
</code></pre></div>        </div>
      </li>
      <li>중개 연산은 데이터를 가공할 때 사용되며 연산 결과로 Stream 타입을 리턴. 따라서 0개 또는 여러 개의 중개연산이 존재할 수 있음</li>
      <li>종단 연산은 중개 연산에서 작업된 내용을 바탕으로 결과를 리턴. 1개만 존재하며, forEach()처럼 리턴 타입이 void인 연산도 있음</li>
      <li>stream()은 컬렉션의 연속된 요소를 순차적으로 데이터를 처리함. 보다 빠른 처리가 필요하면 병렬로 처리하는 parallelStream()을 대신 사용할 수 있으나 CPU 사용량도 많고 몇개 스레드를 사용할지 보장되지 않아 권장되진 않음</li>
      <li>스트림에서 제공하는 중개연산과 종단연산의 종류는 다양하지만 잘 알려진 건 아래와 같음
        <ul>
          <li>중개연산
            <ul>
              <li>filter(Predicate&lt;T&gt; predicate)</li>
              <li>map(Function&lt;T, R&gt; mapper)</li>
            </ul>
          </li>
          <li>종단연산
            <ul>
              <li>forEach(Consumer&lt;T&gt; action)</li>
              <li>collect(Collector&lt;? super T, A, R&gt; collector)</li>
              <li>Optional<T> reduce(BinaryOperator\<T> accumulator)</T></T></li>
              <li>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</li>
              <li>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>Functional 인터페이스는 람다식으로 전환 가능하므로, map()과 forEach()는 아래와 같이 사용가능</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class StudentDTO {
      private String name;
      private int age;
      private int scoreMath;
      private int scoreEnglish;

      public StudentDTO(String name, int age, int scoreMath, int scoreEnglish) {
          this.name = name;
          this.age = age;
          this.scoreMath = scoreMath;
          this.scoreEnglish = scoreEnglish;
      }
      ...
  }
</code></pre></div>        </div>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class StudentForEachSample {
      public static void main(String[] args) {
          StudentForEachSample sample = new StudentForEachSample();
          List&lt;StudentDTO&gt; studentList = new ArrayList&lt;&gt;();

          studentList.add(new StudentDTO("A", 43, 99, 10));
          studentList.add(new StudentDTO("B", 30, 71, 85));
          studentList.add(new StudentDTO("C", 32, 81, 75));

          sample.printStudentNames(studentList);
      }

      public void printStudentNames(List&lt;StudentDTO&gt; studentList) {
          studentList.stream()
                  .map(student -&gt; student.getName())  // Function 람다식
                  .forEach(name -&gt; System.out.println); // Consumer 람다식
      }
      ...
  }
</code></pre></div>        </div>
      </li>
      <li>map()은 데이터를 특정 데이터로 변환함. 여기서 변환한다는 것은 인터페이스에 있는 단일 함수에서 매개변수로 받은 데이터와 다른 데이터를 리턴한다는 것</li>
      <li>위 예제의 map()에서는 StudentDTO 객체를 받아 String 타입의 name으로 리턴하고 있음. 따라서 이후부터는 List&lt;StudentDTO&gt;의 스트림이 아닌 List&lt;String&gt;의 스트림을 처리하게 됨</li>
      <li>
        <p>filter()와 collect()는 아래와 같이 사용가능</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  List&lt;StudentDTO&gt; passedStudents = studentList.stream()
      .filter(s -&gt; s.getScoreMath() &gt;= 70)  // 중개연산
      .collect(Collectors.toList());        // 종단연산
</code></pre></div>        </div>

        <ul>
          <li>filter()는 스트림 내에서 필요한 데이터를 걸러서 처리할 때 사용</li>
          <li>collect()에 전달되는 Collector 인터페이스는 Functional 인터페이스가 아님. 주로 Collector 인터페이스를 리턴하는 Collectors 클래스의 메소드를 전달함. Collectors는 스트림 연산의 최종 결과를 모으는 방법을 제공하는 유틸리티 클래스</li>
          <li>Collectors.toList()는 새 List를 만들고 요소를 담아 합치는 방법을 정의한 설계도 객체(Collector)를 리턴하는 메서드</li>
        </ul>
      </li>
      <li>
        <p>reduce()는 스트림 안의 요소들을 하나의 값으로 합쳐서 축약할 때 사용</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)의 경우

  Optional&lt;Integer&gt; sum = list.stream()
      .reduce((a, b) -&gt; a + b);       // 누적 합. 초기값은 list의 첫번째 요소
</code></pre></div>        </div>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)의 경우

  int sum = list.stream()
      .reduce(0, (a, b) -&gt; a + b);    // 누적 합. 초기값은 첫번째 인자인 0
</code></pre></div>        </div>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // &lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)의 경우 (잘 사용되지 않음)

  int totalLength = list.stream()
      .reduce(0,
          (len, str) -&gt; len + str.length(),   // 누적 로직
          (a, b) -&gt; a + b);                   // 이건 병렬 스트림일 때만 사용되므로 일반적으로 호출되지 않음
</code></pre></div>        </div>
      </li>
      <li>메소드 참조(::)를 사용하여 람다식을 더 짧게 줄일 수 있음. 스트림에 사용하기도 더 간단해짐</li>
      <li>메소드 참조의 종류는 4가지
        <ul>
          <li>static 메소드 참조
            <ul>
              <li>클래스명::static메소드명</li>
            </ul>
          </li>
          <li>특정 객체의 인스턴스 메소드 참조
            <ul>
              <li>
                <p>객체명::객체의_인스턴스_메소드명</p>

                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Arrays.asList(stringArray).stream().forEach(System.out::println);                
</code></pre></div>                </div>
              </li>
            </ul>
          </li>
          <li>특정 유형의 임의의 객체에 대한 인스턴스 메소드 참조
            <ul>
              <li>
                <p>클래스명::인스턴스_메소드명(static 아님)</p>

                <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Arrays.sort(stringArray, String::compareToIgnoreCase);
</code></pre></div>                </div>

                <ul>
                  <li>
                    <p>Arrays 클래스는 아래와 같은 메소드를 갖고 있음</p>

                    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c)
</code></pre></div>                    </div>
                  </li>
                  <li>
                    <p>sort()의 두번째 매개변수인 Comparator는 int compare(T o1, T o2)라는 하나의 메소드를 가진 Functional 인터페이스이므로 아래와 같이 표현될 수 있음</p>

                    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Comparator&lt;String&gt; compare = (s1, s2) -&gt; s1.compareToIgnoreCase(s2);
</code></pre></div>                    </div>
                  </li>
                  <li>
                    <p>compareToIgnoreCase는 String 클래스의 인스턴스 메소드이므로 String::compareToIgnoreCase으로 표현할 수 있음</p>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>생성자 참조
            <ul>
              <li>클래스명::new</li>
              <li>() -&gt; new 클래스명()의 간결한 표현</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="11-java-9에서-변경된-것들">11. Java 9에서 변경된 것들</h2>
<ul>
  <li>3~5년 주기로 업그레이드되던 Java는 9버전 부터 6개월마다 업그레이드되므로, 6개월 주기로 어떤 기능들이 추가되는지 확인하는게 좋음
    <ul>
      <li>openjdk 버전 별 기능 정리한 페이지 확인 (https://openjdk.org/projects/jdk/12/)</li>
    </ul>
  </li>
  <li>아래 이미지 처럼 Features에서 괄호 안에 Experimental, Preview, Incubator 등 3가지 단어가 올 수 있음
  <img src="/assets/images/jdk12_features.png" alt="jdk12_features" />
    <ul>
      <li>Experimental : 실험적인 기능으로, 옵션을 켜지 않으면 사용불가</li>
      <li>Preview : 추후에 JDK에 포함될 기능</li>
      <li>Incubator : 완전하지 않아 언제든 변경되거나 사라질 수 있는 기능</li>
    </ul>
  </li>
  <li>String 클래스의 변화
    <ul>
      <li>String 내부에 있는 값들을 char 배열에서 byte 배열로 변경</li>
      <li>숫자, 영문, 키보드에 있는 특수문자들은 모두 1byte로 표현가능한 반면 한글이나 한자같은 다양한 문자들은 2byte를 사용해야 함. 문자열이 가장 많이 다뤄지므로 영문이 사용된 프로그램의 성능과 메모리 효율이 많이 향상됨</li>
    </ul>
  </li>
  <li>Interface에 private 메소드 추가 가능
    <ul>
      <li>해당 인터페이스를 구현하는 개발자에게 노출되지 않는 인터페이스 내부에서만 사용 가능한 메소드 생성</li>
      <li>인터페이스 내에서 구현된 메소드(default, private static일 경우 static 메소드도 가능)에서만 사용 가능</li>
      <li>private로만 선언해야 하며 abstract이 붙을 수 없음. static은 가능</li>
      <li>당연히 static 메소드가 아니면 같은 클래스 안이라도 static 메소드에서 사용 불가</li>
    </ul>
  </li>
  <li>HttpClient
    <ul>
      <li>예전에 HTTP 호출을 하려면 URL, HTTPURLConnection 클래스를 활용하여 요청하고 BufferedReader를 사용하여 결과를 받는 식으로 처리했는데, 코드가 복잡해짐</li>
      <li>일반적인 오픈소스 라이브러리처럼 제공되는 HttpClient를 사용하여 대신 처리할 수 있음. 보낼 때 HttpRequest 클래스에 데이터를 넣고 받을 때는 HTtpResponse 클래스를 사용하여 응답 처리</li>
      <li>
        <p>서버에 붙을 수 없거나 응답이 없을 때 요청을 끊을 수 있도록 HttpClient, HttpRequest 객체 생성 시 아래와 같이 타임아웃을 지정할 수 있음</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  HttpClient client = HttpClient.newBuilder()
          .connectTimeout(Duration.ofSeconds(5))  // 서버에 붙을 수 없거나 응답이 없을 경우 타임아웃
          .build();

  HttpRequest request = HttpRequest.newBuilder()
          .uri(URI.create("https://www.google.com"))
          .timeout(Duration.ofSeconds(10))        // 서버는 연결되었으나 응답이 없을 때 타임아웃
          .GET()
          .build();

  HttpResponse&lt;String&gt; response = client.send(request, ...);
</code></pre></div>        </div>
      </li>
      <li>위와 같은 타임아웃은 반드시 지정해서 사용하는 것이 좋음</li>
    </ul>
  </li>
  <li>Publish-Subscribe 프레임워크
    <ul>
      <li>이메일을 보내는 경우 받는 사람의 입장에서 polling과 pulling 두가지 방식이 있음</li>
      <li>polling은 주기적으로 요청을 해서 변경된 것이 있는지 확인하고 없으면 아무것도 안함. outlook 프로그램은 새로운 메일이 있는지 주기적으로 서버에 요청을 해서 확인</li>
      <li>
        <p>pulling은 필요시 데이터를 처리하도록 요청하는 것으로 Publish-Subscribe라는 개념이 있음. Java 9에서 이 프레임워크가 추가됨</p>

        <p><img src="/assets/images/publish-subscribescheme.png" alt="processor" /></p>
      </li>
      <li>펍섭 프레임워크는 아래와 같은 인터페이스들을 제공함
        <ul>
          <li>
            <p>Publisher</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public static interface Publisher&lt;T&gt; {
      public void subscribe(Subscriber&lt;? super T&gt; subscriber);
  }
</code></pre></div>            </div>

            <ul>
              <li>subscribe()에서 Subscriber에게 item 전달</li>
            </ul>
          </li>
          <li>
            <p>Subscriber</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public static interface Subscriber&lt;T&gt; {
      public void onSubscribe(Subscription subscription);
      public void onNext(T item);
      public void onError(Throwable throwable);
      public void onComplete();
  }
</code></pre></div>            </div>

            <ul>
              <li>onSubscribe()에서 Subscription의 request()를 호출해 받을 item 개수를 서버에 보내고, 서버에서 온 item은 onNext()에서 받음. onError()와 onComplete()는 각각 에러가 발생했을 때, 완료되었을 때 호출됨</li>
            </ul>
          </li>
          <li>
            <p>Subscription (Publisher가 Subscriber에게 주는 item)</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public static interface Subscription {
      public void request(long n);
      public void cancel();
  }
</code></pre></div>            </div>

            <ul>
              <li>Subscription은 Subscriber가 사용하며, request()는 Subscriber가 Publisher에게 얼마나 많은 아이템을 받을지 알려주기 위해 사용</li>
              <li>requst() 취소하려면 cancel() 사용</li>
            </ul>
          </li>
          <li>
            <p>Processor (중개자가 필요한 경우)</p>
            <ul>
              <li>
                <p>Processor가 낄 경우 아래와 같이 동작함</p>

                <p><img src="/assets/images/processor.png" alt="processor" /></p>
              </li>
            </ul>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public static interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {}
</code></pre></div>            </div>

            <ul>
              <li>Subscriber이자 Publisher이므로 둘다 확장</li>
              <li>인터페이스 간의 상속이므로 extends 사용. 클래스가 인터페이스를 구현하면 implements</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>Publisher-Subscriber 예제. Publisher는 JDK에 포함된 SubmissionPublisher 구현 클래스 사용</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class ReactiveStreamSubscriber implements Subscriber&lt;Integer&gt; {

      private Subscription subscription;
      private String name;
      private boolean completed;

      public ReactiveStreamSubscriber(String name) {
          this.name = name;
          this.completed = false;
      }

      @Override
      public void onSubscribe(Subscription subscription) {
          this.subscription = subscription;
          subscription.request(1); // 첫 아이템 요청
      }

      @Override
      public void onNext(Integer item) {
          Random random = new Random();
          int randomTime = random.nextInt(1000);
          sleep(randomTime);

          System.out.println("[" + name + "] Received item: " + item);

          subscription.request(1); // 다음 아이템 요청
      }

      @Override
      public void onError(Throwable error) {
          System.out.println("[" + name + "] Error occurred: " + error.getMessage());
      }

      @Override
      public void onComplete() {
          completed = true;
          System.out.println("[" + name + "] ReactiveStreamSubscriber is complete");
      }

      public boolean isCompleted() {
          return completed;
      }

      private void sleep(int time) {
          try {
              Thread.sleep(time);
          } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
          }
      }
  }
</code></pre></div>        </div>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class ReactiveStreamMain {

      public static void main(String[] args) throws InterruptedException {

          SubmissionPublisher&lt;Integer&gt; publisher = new SubmissionPublisher&lt;&gt;();

          ReactiveStreamSubscriber subscriber1 = new ReactiveStreamSubscriber("subscriber1");
          ReactiveStreamSubscriber subscriber2 = new ReactiveStreamSubscriber("subscriber2");

          publisher.subscribe(subscriber1);
          publisher.subscribe(subscriber2);

          System.out.println("Submitting items...");
          for (int i = 0; i &lt; 5; i++) {
              publisher.submit(i);
              System.out.println("Published: " + i);
          }

          publisher.close();

          // 모든 Subscriber가 완료될 때까지 대기
          while (true) {
              if (subscriber1.isCompleted() &amp;&amp; subscriber2.isCompleted()) {
                  break;
              }
              Thread.sleep(100);
          }

          System.out.println("All subscribers completed.");
      }
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>모듈화-직소 프로젝트
    <ul>
      <li>
        <p>자바 패키지 최상단에 module-info.java 파일 추가</p>

        <p><img src="/assets/images/모듈구조축소.png" alt="processor" /></p>
      </li>
      <li>
        <p>module-info.java에 exports로 외부에 노출할 패키지 지정 가능</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  module GODOfJavaModule1 {
      exports f.java9.module1;
  }
</code></pre></div>        </div>
      </li>
      <li>
        <p>동일한 모듈에 있어도 module-info.java에 exports된 패키지에 정의된 클래스가 아니라면 다른 모듈의 클래스에서 import하거나 참조할 수 없음</p>
        <ul>
          <li>
            <p>위의 폴더구조 이미지에 있는 HiddenClass 클래스는 f.java9.module0 패키지에 정의됨</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  package f.java9.module0;

  public class HiddenClass {
      public boid showMeTheHidden(){
          ...
      }
  }
</code></pre></div>            </div>
          </li>
          <li>
            <p>HiddenClass 클래스는 같은 모듈에 있는 PrintData 클래스에서는 사용할 수 있으나 chapterF.06.Module2에 있는 UtilizeData 클래스에서는 import하거나 참조할 수 없음</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="12-java-10에서-달라진-것들">12. Java 10에서 달라진 것들</h2>
<ul>
  <li>var 타입 사용 가능
    <ul>
      <li>javaScript에서 사용하는 var를 유사하게 자바에서 사용 가능</li>
      <li>
        <p>누가 봐도 명시적인 타입을 지정할 대는 var를 사용하여 변수를 선언할 수 있음. 아래와 같이 배열에 서로 다른 타입의 값을 넣어도 컴파일 오류는 나지 않으나, 이런 제네릭은 없으므로 이런 방식의 사용은 자제해야 함</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  var hello = "aaaaaa";
  var list = new ArrayList&lt;&gt;();
  list.add(hello);
  list.add(1);
  System.out.println(list)
</code></pre></div>        </div>
      </li>
      <li>var list = ArrayList&lt;String&gt;();처럼 제네릭에 타입을 명시하면 숫자를 넣을 때 컴파일 에러가 발생함</li>
      <li>누가봐도 우측항의 타입이 명시적이면 var를 사용해도 되지만, 그렇지 않으면 컴파일 오류가 발생</li>
    </ul>
  </li>
  <li>Immutable Collection
    <ul>
      <li>수정 불가능한 List Collection을 만드는 List.of()가 추가됨</li>
      <li>
        <p>List.of()는 내부적으로 ImmutableCollections.ListN 객체를 반환함. 상속구조는 아래와 같음</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Object
      └─ AbstractCollection&lt;E&gt;
          └─ AbstractImmutableList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Serializable
              └─ ListN&lt;E&gt;
</code></pre></div>        </div>
      </li>
      <li>
        <p>아래의 fruits에 새로운 요소를 추가하려하면 오류 발생</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  var fruits = List.of("Apple", "Pineapple", "Grapes");
</code></pre></div>        </div>
      </li>
      <li>
        <p>이미 선언된 List를 수정 불가능한 목록으로 만드려면 Collectors 클래스의 toUnmodifiableList() 사용</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  List&lt;String&gt; changedFruits = fruits.stream().collect(Collectors.toUnmodifiableList());
</code></pre></div>        </div>
      </li>
      <li>
        <p>참고로 Java 16부터는 stream.of()로도 만들 수 있음</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  var fruits = Stream.of("Apple", "Pineapple", "Grapes").toList();
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="13-java-11에서-달라진-것들">13. Java 11에서 달라진 것들</h2>
<ul>
  <li>컴파일 없이 java 파일 실행
    <ul>
      <li>
        <p>원래는 javac 명령어로 .java 파일 컴파일 후 java 명령어로 실행 가능한데, 컴파일 없이 실행할 수 있게됨</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  $ java NoCompileWithArgs.java God of java
</code></pre></div>        </div>
      </li>
      <li>위처럼 매개변수도 문제없이 전달 가능</li>
      <li>
        <p>코드 최상단에 #!java –source 자바버전(숫자)를 추가하면 ./자바파일 만으로 실행할 수 있음</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  #!java --source 11
  public class NoCompile{
      public static void main(String args[]){
          System.out.println("script of java !!!");
      }
  }
</code></pre></div>        </div>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  $ chmod 755 likescript  // 파일명은 클래스명과 일치하지 않아도 됨
  $ ./likescript
  script of java !!!
</code></pre></div>        </div>
      </li>
      <li>이런 파일을 셔빙 파일이라 하며, #!으로 시작하여 실행파일(java)가 정의되어 있어야 함. –source로 버전도 반드시 명시해 줘야 함</li>
      <li>이렇게 하면 자바 11 이상이 설치된 환경에서는 쉘 스크립트 공부할 필요 없이 자바로 쉘 스크립트 같이 필요한 기능을 만들어 사용할 수 있음. 단, 성능은 쉘 스크립트보다 떨어질 수 있다는 점은 고려해야 함</li>
    </ul>
  </li>
  <li>Lamda에서 var 사용
    <ul>
      <li>var 예약어는 제약이 많았는데 Lamda에서는 var을 사용하는게 불가능 했음</li>
      <li>
        <p>Java 11에선 아래와 같이 Lamda 매개변수에 var 사용가능</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);

  // numbers.stream()은 Stream&lt;Integer&gt;으로, 이미 컴파일러가 타입을 알고 있음
  int sum = numbers.stream().reduce(0, (var x, var y) -&gt; x + y);
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="14-java-1217-버전">14. Java 12~17 버전</h2>
<ul>
  <li>더 간결하게 표현 가능한 switch-case 문
    <ul>
      <li>
        <p>Java 12 부터는 switch 앞에 값을 할당할 변수를 적어주고, case 뒤에 : 대신 -&gt; 사용하여 값을 할당할 수 있음</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int days;
  days = switch(month) {
      case 1 -&gt; 31;
      case 3 -&gt; 31;
      ...
      case 4 -&gt; 30;
      ...
      default -&gt; 0;
  }
</code></pre></div>        </div>
      </li>
      <li>-&gt; 문법에서는 오직 해당 case 한 번만 실행되기 때문에 break 불필요</li>
      <li>
        <p>case 뒤에 콤마를 붙여 여러 케이스에 하나의 값을 할당해야하는 경우 아래와 같이 표현</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int days;
  days = switch(month) {
      case 1, 3, 5, 7, 8, 12 -&gt; 31;
      case 4, 6, 9, 11 -&gt; 30;
      default -&gt; 0;
  }        
</code></pre></div>        </div>
      </li>
      <li>
        <p>Java 14부터 정식으로 switch-case 문에서 사용 가능한 yield 예약어가 추가됨. yield는 : 또는 -&gt; 와 함께 사용 가능한데, 한 switch-case 문에서 두 방식을 같이 쓸 순 없음</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int days;
  days = switch(month) {
      case 1, 3, 5, 7, 8, 12 : 
          yield 31;
      case 4, 6, 9, 11 : 
          yield 30;
      default :
          yield 0;
  }           
</code></pre></div>        </div>
      </li>
      <li>
        <p>yield와 -&gt;를 함께 사용할 땐 중괄호로 묶어줘야 함. yield는 return 처럼 동작</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int days;
  days = switch(month) {
      case 1, 3, 5, 7, 8, 12 -&gt; 31;
      case 4, 6, 9, 11 -&gt; 30;
      default -&gt; {
          System.println.out("Not assigned")
          yield 0;
      }
  }           
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>text 블록
    <ul>
      <li>Java 15부터는 정식으로 텍스트 블록을 사용할 수 있음. String을 두 줄 이상 작성할 때 +, \n을 사용할 필요가 없어짐</li>
      <li>
        <p>단, 블록의 시작과 끝 “"”에는 공백이나 줄바꿈만 가능하며 다른 문자(문자열 내용 포함)를 바로 붙이면 안됨</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String text = """   // 다른 문자 없음
      Hello,
            
        This is a text block example.
      Multiple lines are preserved.
      """;            // 다른 문자 없음
</code></pre></div>        </div>
      </li>
      <li>
        <p>text 블록은 여러 줄의 공통된 맨 앞 공백을 기준으로 제거하고, 그 이후 남은 공백과 내용은 그대로 문자열에 포함시킴. 따라서 위 예제는 아래와 같이 출력됨</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Hello,
    This is a text block example.
  Multiple lines are preserved.
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>record 클래스
    <ul>
      <li>Java 16에서 정식으로 추가된 record 클래스는 아래와 같은 특징이 있음
        <ul>
          <li>한번 지정한 값은 수정 불가능 (모든 필드가 final)</li>
          <li>추가 인스턴스 필드를 선언할 수 없으며 (static은 가능) 상속도 안됨</li>
          <li>전체 변수가 포함된 생성자를 자동으로 만들어줌</li>
          <li>equals()나 hashCode, toString() 메소드를 자동으로 만들어줌</li>
          <li>각 변수명으로 생성된 메소드가 제공되며, 변수의 값을 확인하는데 사용됨 (getter)</li>
        </ul>
      </li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  //괄호 안의 name, writer, category 인스턴스 필드만 존재. 추가 필드 선언 불가
  public record BookOfKoreanRecord(String name, String writer, String category) {

      // Static 필드 — OK
      public static final String BOOK_LANGUAGE = "Korean Book";

      // 생성자에 괄호가 없으면 전체변수 생성자
      // 전체변수 생성자는 자동으로 값이 매핑됨. 매핑된 후 Objects.requireNonNull()을 호출하여 null일 경우 예외 발생
      public BookOfKoreanRecord {
          Objects.requireNonNull(name);
          Objects.requireNonNull(writer);
      }

      // 전체변수 생성자가 아니면 괄호로 매개변수 지정
      public BookOfKoreanRecord(String name, String writer) {
          this(name, writer, "IT");
      }
  }
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  private void testBookRecord() {
      BookOfKoreanRecord godOfJava1 = new BookOfKoreanRecord("GodOfJava", "Sangmin,Lee", "IT");

      // record의 자동 생성 toString()과 getter 메서드 호출
      System.out.println(godOfJava1);
      System.out.println(godOfJava1.name());
      System.out.println(godOfJava1.writer());
      System.out.println(godOfJava1.category());

      BookOfKoreanRecord godOfJava2 = new BookOfKoreanRecord("GodOfJava", "Sangmin,Lee", "IT");

      // record는 equals()와 hashCode()를 필드 값 기준으로 자동 생성
      System.out.println("Two same value objects equals = " + godOfJava1.equals(godOfJava2));
      System.out.println("godOfJava1 hashCode = " + godOfJava1.hashCode());
      System.out.println("godOfJava2 hashCode = " + godOfJava2.hashCode());
  }
</code></pre></div>    </div>

    <ul>
      <li>출력 결과는 아래와 같음</li>
    </ul>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  BookOfKoreanRecord[name=godOfJava2, writer=Sangmin,Lee, category=IT]
  GodOfJava
  Sangmin,Lee
  IT
  Two same value object equals=true 
  godOfJava1 hashCode=-67549099 
  godOfJava2 hashCode=-67549099
</code></pre></div>    </div>

    <ul>
      <li>record 클래스는 DB에서 조회한 데이터를 확인하는 등 변하지 않는 데이터를 처리할 때 유용함. 값 변경이 필요하다면 record가 아닌 DTO를 만들어 사용하는 게 좋음</li>
    </ul>
  </li>
  <li>sealed 클래스
    <ul>
      <li>Java 17부터 사용 가능. 상속을 허용하기 위한 용도로 사용됨</li>
      <li>class 앞에 sealed가 붙어야 하고, permits 뒤에 상속을 허용할 클래스명을 나열함. permits로 허용한 클래스 외에는 상속이 허용되지 않음</li>
      <li>상속이 허용된 클래스들에 대하여 아래와 같은 제약사항이 있음
        <ul>
          <li>허용된 서브 클래스들은 반드시 같은 모듈에 존재해야 함</li>
          <li>허용된 서브 클래스들은 반드시 명시적으로 부모 클래스를 확장해야 함</li>
          <li>허용된 서브 클래스들은 다음 중 하나로 선언되어야 함 : final, sealed, non-sealed</li>
        </ul>
      </li>
      <li>
        <p>sealed</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public sealed class Sealed FordCar permits Sealed Mustang, Sealed Explorer {
      public static String BRAND_NAME="FORD";
      public SealedFordCar() {
          System.out.println("SealedFordCar initiated. BRAND_NAME="+BRAND_NAME);
      }
  }
</code></pre></div>        </div>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public sealed class SealedMustang extends Sealed FordCar permits SealedMustangShelby{
      public SealedMustang() {
          System.out.println("SealedMustang initiated.BRAND_NAME="+BRAND_NAME);
      }
      public boolean isSportsCar(){
          return true;
      }
  }
</code></pre></div>        </div>
      </li>
      <li>final
        <ul>
          <li>
            <p>더이상 상속을 허용할 클래스가 없다면 final로 상속을 막음</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public final class Sealed MustangShelby extends SealedMustang {
      public SealedMustangShelby() {
          System.out.println("SealedMustangShelby initiated.BRAND_NAME="+BRAND_NAME);
      }
  }
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>non-sealed
        <ul>
          <li>
            <p>해당 클래스의 자식 클래스에 대한 제약 삭제. 해당 클래스를 아무 클래스가 확장할 수 있게 됨</p>

            <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public non-sealed class SealedExplorer extends FordCar {
      public SealedExplorer() {
          System.out.println("SealedExplorer initiated. BRAND_NAME=" + BRAND_NAME);
      }
      public boolean isSUV() {
          return true;
      }
  }
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>sealed 클래스는 컴파일러가 해당 타입의 가능한 모든 서브클래스를 알고 있으므로 타입 누락 실수를 방지할 수 있음
        <ul>
          <li>switch 패턴 매칭에서 누락한 클래스가 있을 경우 경고를 줄 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>Toyo</name></author><category term="CS" /><category term="java" /><summary type="html"><![CDATA[1. 자바 역사와 JVM]]></summary></entry><entry><title type="html">자바로 배우는 핵심 자료구조와 알고리즘</title><link href="/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html" rel="alternate" type="text/html" title="자바로 배우는 핵심 자료구조와 알고리즘" /><published>2025-09-11T00:00:00+00:00</published><updated>2025-09-11T00:00:00+00:00</updated><id>/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%ED%95%B5%EC%8B%AC%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98</id><content type="html" xml:base="/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"><![CDATA[<h2 id="1-인터페이스-프로그래밍">1. 인터페이스 프로그래밍</h2>
<ul>
  <li>java.util.List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List 인터페이스에 정의된 메소드는 ArrayList와 LinkedList 또는 List 인터페이스를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨</li>
  <li>라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨</li>
</ul>

<h2 id="2-빅오-표기법">2. 빅오 표기법</h2>
<ul>
  <li>알고리즘의 성능(시간 혹은 공간 복잡도)을 입력 크기 n에 따라 표현하는 수학적 표기법</li>
  <li>전체 코드 구현 이전에 컴퓨터의 성능에 구애받지 않고 알고리즘의 소요 시간을 정량화하기 위해 입력 크기에 따른 증가율을 비교함</li>
  <li>입력 크기가 커질수록 알고리즘 간 성능 차이가 커지므로, 분석은 대규모 입력에 초점을 맞춰야 함. 빅오 표기법은 이러한 상황에서 알고리즘의 최악의 실행 시간을 표현하여 성능을 평가하는 데 사용</li>
  <li>실행 속도 O(1) &lt; O(log N) &lt; O(N) &lt; O(N log N) &lt; O(N^2) &lt; O(2^N)</li>
</ul>

<h2 id="3-arraylist">3. ArrayList</h2>
<ul>
  <li>java.util.ArrayList 클래스는 java.util.List 인터페이스의 구현 클래스 중 하나. List 인터페이스 문서에 정의된 add, gets, rem, set, indexOf, equals 메소드 규칙을 참고하여 ArrayList 클래스와 유사한 MyArrayList 클래스를 작성해보면 아래와 같음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MyArrayList&lt;T&gt; implements List&lt;T&gt; {
      int size;
      private T[] array;

      @Override
      public boolean add(T element) {
          if (size &gt;= array.length) {
              // 배열의 전체 크기보다 더 많은 값이 삽입되면 크기가 그 2배인 배열을 다시 생성, 기존값 복사
              // 자바에선 타입 파라미터(T)로 배열을 초기화할 수 없으므로 Object 배열 생성 후 형변환
              E[] bigger = (T[]) new Object[array.length * 2];
              System.arraycopy(array, 0, bigger, 0, array.length);
              array = bigger;
          }
          array[size] = element;
          size++;
          return true;
      }

      @Override
      public void add(int index, T element) {
          if (index &lt; 0 || index &gt; size) {
              throw new IndexOutOfBoundsException();
          }
          add(element);

          // shift the elements
          for (int i=size-1; i&gt;index; i--) {
              array[i] = array[i-1];
          }
          // put the new one in the right place
          array[index] = element;
      }

      @Override
      public T get(int index) {
          if (index &lt; 0 || index &gt;= size) {
              throw new IndexOutOfBoundsException();
          }
          return array[index];
      }

      @Override
      public T set(int index, T element) {
          E old = get(index);
          array[index] = element;
          return old;
      }

      @Override
      public int indexOf(Object target) {
          for (int i = 0; i &lt; size; i++) {
              if (equals(target, array[i])) return i;
          }
          return -1;
      }

      private boolean equals(Object target, Object element) {
          if (target == null) {
              return element == null;
          } else {
              //Object 객체의 equals 메소드를 호출하여 실제 객체에서 재정의한 equals 메소드가 호출됨 
              return target.equals(element);
          }
      }

      @Override
      public boolean remove(Object obj) {
          int index = indexOf(obj);
          if (index == -1) {
              return false;
          }
          remove(index);
          return true;
      }

      @Override
      public T remove(int index) {
          E element = get(index);
          for (int i=index; i &lt; size-1; i++) {
              array[i] = array[i+1];
          }
          size--;
          return element;
      }

      ...

</code></pre></div>    </div>
  </li>
  <li>get, set, indexOf, equals, remove 메소드의 시간 복잡도는 각각 상수, 상수, 선형, 상수, 선형임</li>
  <li>add(T element) 메소드의 시간 복잡도를 계산하기 위해 크기가 2인 배열에 n개 요소를 추가할 때의 평균 연산 횟수를 고려하면
    <ul>
      <li>1~2번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장</li>
      <li>3번째 호출 : 기존의 2배 크기(=4)를 가진 배열을 생성하여 기존 요소 2개를 복사하고 요소 저장</li>
      <li>4번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장</li>
      <li>5번째 호출 : 기존의 2배 크기(=8)를 가진 배열을 생성하여 기존 요소 4개를 복사하고 요소 저장</li>
      <li>6~8번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장</li>
      <li>위의 패턴 반복</li>
    </ul>
  </li>
  <li>결과적으로 n번 추가하면 요소 총 n개를 저장하고 총 n-2개를 복사함. 따라서 총 연산 횟수는 2n-2이고, 평균 횟수는 n으로 나누어 2-2/n이 됨</li>
  <li>n이 커질수록 두 번째 항인 2/n는 작아지므로 add(T element) 메소드는 상수 시간으로 간주됨</li>
  <li>일련의 호출에서 평균 시간을 계산하는 알고리즘 분류 방법을 <strong>분할 상환 분석</strong>이라고 함. 핵심 개념은 배열의 크기를 조정할 때마다 배열의 길이가 2배로 늘어나 각 요소를 복사하는 횟수를 제한한다는 것. 매번 고정된 양을 더해서 크기를 늘리는 대신 곱하여 연산 횟수를 더 제한함</li>
  <li>이어서 removeAll 메소드를 구현하면 아래와 같음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  @Override
  public boolean removeAll(Collection&lt;?&gt; collection) {
      boolean flag = true;
      for (Object obj: collection) {
          flag &amp;= remove(obj);
      }
      return flag;
  }
</code></pre></div>    </div>
  </li>
  <li>반복문을 돌리며 선형인 remove 메소드를 호출하고 있지만 collection 크기가 n에 비례하지 않는다면 이차가 아님</li>
</ul>

<h2 id="4-단일-연결-리스트-linkedlist">4. 단일 연결 리스트 (LinkedList)</h2>
<ul>
  <li>연결 리스트에서 각 노드는 리스트의 다음 노드에 대한 참조를 포함. 연결 구조의 다른 예로는 트리와 그래프가 있음</li>
  <li>java.util.List 인터페이스를 상속받아 MyLinkedList를 직접 구현
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MyLinkedList&lt;E&gt; implements List&lt;E&gt; {

      private class Node {
          public E data;
          public Node next;

          public Node(E data) {
              this.data = data;
              this.next = null;
          }
      }

      private int size;            // 요소 더하거나 제거할 때마다 갱신
      private Node head;           // 리스트의 첫 번째 노드 참조. 빈 리스트이면 null

      public MyLinkedList() {
          head = null;
          size = 0;
      }

      @Override
      public boolean add(E element) {
          if (head == null) {
              head = new Node(element);
          } else {
              Node node = head;
              for ( ; node.next != null; node = node.next) {}
              node.next = new Node(element);
          }
          size++;
          return true;
      }

      @Override
      public void clear() {
          head = null;
          size = 0;
      }
</code></pre></div>    </div>
  </li>
  <li>LinkedList는 ArrayList와 달리 리스트 자체가 파괴되지 않아도 요소를 제거하면 리스트 크기가 줄어들고 사용하지 않는 노드는 즉시 가비지 컬렉션이 될 수 있다는 장점이 있음</li>
  <li>add 메소드는 리스트의 끝까지 이동해야 하므로 선형 증가차수를 가짐</li>
  <li>clear 메소드로 LinkedList의 첫 번째 노드 참조를 제거할 경우에는 순차적으로 연결리스트의 각 노드들에 대한 참조가 사라지게 되어 가비지 컬렉션이 선형이 됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      private boolean equals(Object target, Object element) {
          if (target == null) {
              return element == null;
          } else {
              return target.equals(element);  //Object를 오버라이드 한 target의 실제 equals 메소드 호출
          }
      }

      @Override
      public int indexOf(Object target) {
          Node node = head;
          for (int i=0; i &lt; size; i++){
              if (equals(target, node.data)) {
                  return i;
              }
              node = node.next;
          }
          return -1;
      }

      private Node getNode(int index) {
          if (index &lt; 0 || index &gt;= size) {
              throw new IndexOutOfBoundsException();
          }
          Node node = head;
          for (int i=0; i&lt;index; i++) {
              node = node.next;
          }
          return node;
      }

      @Override
      public E get(int index) {
          Node node = getNode(index);
          return node.data;
      }

      @Override
      public void add(int index, E element) {
          if (index == 0) {
              head = new Node(element, head);
          } else {
              Node node = getNode(index - 1);
              node.next = new Node(element, node.next);
          }
          size++;
      }

      @Override
      public E remove(int index) {
          E element = get(index);
          if (index == 0) {
              head = head.next;
          } else {
              Node node = getNode(index-1);
              node.next = node.next.next;
          }
          size--;
          return element;
      }
</code></pre></div>    </div>
  </li>
  <li>indexOf는 선형, remove와 add(int index, E element)도 index가 0인 특별한 경우를 제외하고 getNode가 선형이므로 선형</li>
  <li>MyArrayList 클래스는 끝에 추가하고 끝에서 제거할 때와 get/set 메서드 연산에 이점이 있으며, MyLinkedList 클래스는 시작에 추가하고 시작에서 제거하는 연산에 이점이 있음. 다른 연산에서는 증가 차수가 같음</li>
  <li>ArrayList 끝에 새로운 요소를 추가하는 실행 시간 측정 테스트
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public static void profileArrayListAddEnd() {
      Timeable timeable = new Timeable() {
          List&lt;String&gt; list;

          // 초기 설정: ArrayList 사용
          public void setup(int n) {
              list = new ArrayList&lt;String&gt;();
          }

          // 테스트 내용: 리스트 맨 앞에 n개의 요소를 추가
          public void timeMe(int n) {
              for (int i = 0; i &lt; n; i++) {
                  list.add("a string");
              }
          }
      };
      int startN = 4000;  // 몇 번 추가할지에 대한 n값
      int endMillis = 1000;   // timingLoop 테스트 실행시간
      runProfiler("ArrayList add first", timeable, startN, endMillis);
  }

  private static void runProfiler(String title, Timeable timeable, int startN, int endMillis) {
      Profiler profiler = new Profiler(title, timeable);
      XYSeries series = profiler.timingLoop(startN, endMillis);
      profiler.plotResults(series);
  }
</code></pre></div>    </div>
    <ul>
      <li>리스트 맨 앞에 n개의 요소를 추가하는 시간 측정 테스트 수행. 테스트에 사용되는 Profiler, Timeable 클래스는 교재의 별도 코드 참고</li>
      <li>테스트 결과 : endMillis 동안 루프를 돌며 2배식 증가되는 startN과, 해당 startN에서 10회 씩 timeMe를 수행한 총 소요 시간 출력
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  4000, 3
  8000, 0
  16000, 1
  32000, 2
  64000, 3
  128000, 6
  256000, 18
  512000, 30
  1024000, 8
  2048000, 185
  4096000, 242
  8192000, 544
  16384000, 1325
</code></pre></div>        </div>
      </li>
      <li>테스트 수행 결과 그래프가 a + bn (직선)이 되는 것 확인 가능. a는 Y 절편, b는 기울기</li>
      <li>plotResults 메소드는 테스트 수행 결과를 그래프로 출력</li>
      <li>측정에 잡음이 많으면 그래프 차이를 확인하기 어려우므로 이차 이상은 log-log 스케일을 적용해 직선 그래프 간의 기울기의 차이를 확인할 수 있음. 기울기가 1에 가까우면 선형, 2에 가까우면 이차로 봐야함</li>
      <li>timeMe 메소드를 ArrayList 맨 앞에 n개의 새로운 요소를 추가하도록 수정하면 전체시간은 이차가 되며, log-log 스케일을 적용했을때 기울기가 2에 가까워짐</li>
      <li>MyLinkedList 클래스를 이용하여 시작과 끝에 n개의 새로운 요소를 추가하도록 수정하면 둘다 1에 가까운 기울기가 출력됨</li>
    </ul>
  </li>
</ul>

<h2 id="5-이중-연결-리스트">5. 이중 연결 리스트</h2>
<ul>
  <li>앞서 구현한 단일 연결 리스트인 MyLinkedList와 달리 java.util.LinkedList 클래스는 이중 연결 리스트로 아래와 같은 특징이 있음
    <ul>
      <li>각 노드는 다음 노드와 이전 노드의 참조를 포함</li>
      <li>LinkedList 객체는 첫번째와 마지막 요소에 대한 참조를 포함</li>
    </ul>
  </li>
  <li>
    <p>ArrayList, 단일 연결 리스트, 이중 연결 리스트 성능 비교</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">구분</th>
          <th style="text-align: center">ArrayList</th>
          <th style="text-align: center">MyLinkedList</th>
          <th style="text-align: center">LinkedList</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">add(끝)</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">add(시작)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">add(일반적으로)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
        <tr>
          <td style="text-align: left">get/set</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
        <tr>
          <td style="text-align: left">indexOf/lastIndexOf</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
        <tr>
          <td style="text-align: left">isEmpty/size</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">remove(끝)</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">remove(시작)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">remove(일반적으로)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>ArrayList 클래스는 get/set 메서드에서 유일하게 연결 리스트보다 나은 성능을 보임</li>
  <li>반대로 실행시간이 시작이나 끝 근처에 요소를 추가하거나 제거하는 연산에 의존한다면 LinkedList 클래스가 좋음</li>
  <li>단, 이러한 연산이 프로그램의 실행시간에 뚜렷한 영향을 미치지 않는다면 List 구현에 대한 선택은 큰 의미가 없음</li>
  <li>또한 리스트가 충분히 크지 않으면 위의 성능표에 있는 성능차이는 해당되지 않으며 공간면에서는 ArrayList가 참조가 차지하는 공간이 적어 연결리스트보다 효율이 높음</li>
</ul>

<h2 id="6-트리-순회">6. 트리 순회</h2>

<h3 id="61-웹-크롤러-구현을-위한-dfs-트리-순회">6.1 웹 크롤러 구현을 위한 DFS 트리 순회</h3>
<ul>
  <li>웹 크롤러가 HTML 페이지를 다운로드하고 파싱해 본문과 링크를 추출하도록 하기 위해 jsoup 라이브러리를 사용</li>
  <li>jsoup은 HTML 문서를 노드 기반 연결 자료구조인 DOM 트리 형태로 표현하며, 이 트리 구조는 깊이 우선 탐색(DFS)을 수행하기에 적합함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class WikiNodeExample {
      public static void main(String[] args) throws IOException {
          String url = "https://en.wikipedia.org/wiki/Java_(programming_language)";
            
          //String 타입의 URL을 인자로 받아 웹 서버에 접속
          Connection conn = Jsoup.connect(url);
          //get 메소드는 HTML 을 다운로드하여 파싱하고 DOM 트리를 나타내는 Document 객체를 반환
          Document doc = conn.get();
            
          Element content = doc.getElementById("mw-content-text");
          Elements paras = content.select("p");
          Element firstPara = paras.get(0);
		
          //재귀적 방법을 사용한 DOM 트리 깊이 우선 탐색
          recursiveDFS(firstPara);
          System.out.println();

          //반복적 방법을 사용한 DOM 트리 깊이 우선 탐색
          iterativeDFS(firstPara);
          System.out.println();
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="62-dfs로-트리를-순회하는-2가지-방법">6.2 DFS로 트리를 순회하는 2가지 방법</h3>

<h4 id="621-재귀적-방법을-사용한-트리-순회">6.2.1 재귀적 방법을 사용한 트리 순회</h4>
<ul>
  <li>자식 노드를 탐색하기에 앞서 각 TextNode의 내용을 출력하는 전위 순회 방식
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  private static void recursiveDFS(Node node) {
      if (node instanceof TextNode) {
          System.out.print(node);
      }
      for (Node child: node.childNodes()) {
          recursiveDFS(child);
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="622-반복적-방법을-사용한-트리-순회--스택-사용">6.2.2 반복적 방법을 사용한 트리 순회 : 스택 사용</h4>
<ul>
  <li>스택 자료구조는 push, pop, peek, isEmpty 등 List의 일부 기능만 제공하지만 단순하여 코드 가독성을 높이고 오류 발생 가능성을 줄임. 또한 API가 적으면 효율적으로 구현하기가 더 쉬워짐</li>
  <li>자바로 스택 구현 시 기존 ArrayList나 LinkedList 클래스를 사용하면 잘못된 위치에 추가하거나 잘못된 순서로 제거하는 실수가 발생할 수 있고, 자바의 Stack 클래스는 오래된 버전이라 최근 JCF와 일치하지 않으므로 ArrayDeque같은 Deque 인터페이스를 구현한 클래스를 사용하는 편이 좋음</li>
  <li>Deque는 양쪽에 끝이 있는 큐로, 자바에서 Deque 인터페이스는 push 와 pop, peek, isEmpty 메서드를 제공하므로 스택으로 구현할 수 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  private static void iterativeDFS(Node root) {
      Deque&lt;Node&gt; stack = new ArrayDeque&lt;Node&gt;();
      stack.push(root);

      while (!stack.isEmpty()) {
          Node node = stack.pop();
          if (node instanceof TextNode) {
              System.out.print(node);
          }

          // 후입선출이므로 역순으로 삽입
          List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(node.childNodes());
          Collections.reverse(nodes);
			
          for (Node child: nodes) {
              stack.push(child);
          }
      }
  }
</code></pre></div>    </div>
  </li>
  <li>반복적 DFS가 재귀적 DFS보다 Iterator 인터페이스(hasNext(), next())로 래핑하기가 용이해 외부에서 순회 제어하기가 더 쉬움</li>
  <li>웹 크롤러를 이용한 철학으로 가는 길 예제 (교재 확인 시 참고용)
    <ul>
      <li>ArrayDeque 스택을 가지고 DOM 트리를 탐색하는 Iterable 구현 클래스 WikiNodeIterable</li>
      <li>jsoup 라이브러리를 활용하여 위키피디아 페이지를 다운로드하는 WikiFetcher 클래스</li>
      <li>WikiNodeIterable을 사용해 페이지의 첫 번째 유효링크를 파싱하는 WikiParser 클래스</li>
      <li>WikiParser와 WikiFetcher을 사용하여 주어진 위키피디아 페이지에서 시작해 첫 번째 링크를 따라가며 목표 페이지에 도달하거나 제한 횟수·사이클·막다른 길에 걸릴 때까지 탐색하는 WikiPhilosophy 클래스</li>
    </ul>
  </li>
</ul>

<h2 id="7-map">7. Map</h2>

<h3 id="71-map-set과-인덱서">7.1 Map, Set과 인덱서</h3>
<ul>
  <li>인덱서는 검색어를 바탕으로 관련 페이지를 찾을 수 있게 하는 자료구조. 검색어가 각 페이지에 몇 번씩 등장하는지를 기록해 가장 관련성이 높은 페이지 식별</li>
  <li>List<Page> 같은 페이지의 컬렉션 형태보다는 키에 해당하는 값을 빠르게 찾을 수 있는 Map이 더 적절함</Page></li>
  <li>검색어와 검색어가 등장하는 페이지의 컬렉션을 매핑하는 Index 라는 클래스, 해당 페이지의 단어 별 등장 횟수를 매핑하는 Termcounter 클래스 구현</li>
  <li>검색어별로 등장하는 페이지를 모아두면, 여러 검색어를 동시에 찾을 때는 교집합 연산으로 공통 페이지를 구해야 함</li>
  <li>Set은 기본적으로 중복 없는 집합 구조로, TermCounter의 equals()와 hashCode() 메소드를 label로 비교하도록 재정의할 경우 페이지 별로 유일하며 교집합 같은 연산을 효율적으로 구현할 수 있는 메소드를 제공해 페이지 별 데이터를 저장하는데 적합함</li>
  <li>Index 클래스는 단어 문자열을 key, TermCounter 객체들의 Set을 value로 가지는 Map을 보유하여 특정 검색어에 대한 페이지별 등장횟수(TermCounter)를 제공
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class Index {
      private Map&lt;String, Set&lt;TermCounter&gt;&gt; index = new HashMap&lt;String, Set&lt;TermCounter&gt;&gt;();
      ...
  }
</code></pre></div>    </div>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class TermCounter {

      private Map&lt;String, Integer&gt; map; //해당 페이지에서 해당 단어가 등장하는 횟수 매핑
      private String label; //페이지의 url

      public TermCounter(String label) {
          this.label = label;
          this.map = new HashMap&lt;String, Integer&gt;();
      }
        
      public void processElements(Elements paragraphs) {
          for (Node node: paragraphs) {
              processTree(node);
          }
      }

      public void processTree(Node root) {
          // NOTE: we could use select to find the TextNodes, but since
          // we already have a tree iterator, let's use it.
          for (Node node: new WikiNodeIterable(root)) {
              if (node instanceof TextNode) {
                  processText(((TextNode) node).text());
              }
          }
      }

      public void processText(String text) {
          // replace punctuation with spaces, convert to lower case, and split on whitespace
          String[] array = text.replaceAll("\\pP", " ").
                              toLowerCase().
                              split("\\s+");
            
          for (int i=0; i&lt;array.length; i++) {
              String term = array[i];
              incrementTermCount(term);
          }
      }

      public void incrementTermCount(String term) {
          // System.out.println(term);
          put(term, get(term) + 1);
      }

      public void put(String term, int count) {
          map.put(term, count);
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>TermCounter는 jsoup 라이브러리의 Element 객체 컬렉션인 Elements 객체를 쪼개 단어별 등장 횟수를 카운트하는 processElement, processTree, processText 메소드 제공. processTree는 Element 객체의 DOM 트리를 탐색하기 위해 앞서 정의된 WikiNodeIterable 클래스를 사용함</li>
  <li>자바 Map 인터페이스 구현 클래스로는 HashMap, TreeMap 클래스, Set 인터페이스 구현 클래스로는 HashSet과 TreeSet 클래스가 있음</li>
</ul>

<h3 id="72-map-인터페이스-구현">7.2 Map 인터페이스 구현</h3>
<ul>
  <li>java.util.Map 인터페이스 문서의 메소드 정의를 참고하여 해당 인터페이스를 구현한 MyLinearMap 클래스 작성
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MyLinearMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

      private List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;();

      public class Entry implements Map.Entry&lt;K, V&gt; {
          private K key;
          private V value;

          public Entry(K key, V value) {
              this.key = key;
              this.value = value;
          }
      }

      private Entry findEntry(Object target) {
          for (Entry entry: entries) {
              if (equals(target, entry.getKey())) {
                  return entry;
              }
          }
          return null;
      }

      private boolean equals(Object target, Object obj) {
          if (target == null) {
              return obj == null;
          }
          return target.equals(obj);
      }

      @Override
      public V get(Object key) {
          Entry entry = findEntry(key);
          if (entry == null) return null;
          return entry.getValue();
      }

      @Override
      public V put(K key, V value) {
          Entry entry = findEntry (key)
          if (entry == null){
              entries.add(new Entry(key, value));
          } else {
              V oldValue = entry.getValue();
              entry.setValue(value);
              return oldValue;
          }
      }

      @Override
      public V remove(Object key) {
          Entry entry = findEntry(key);
          if (entry == null) {
              return null;
          } else {
              V value = entry.getValue();
              entries.remove(entry);
              return value;
          }
      }

      @Override
      public void clear() {
          entries.clear();
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>Entry 클래스는 단지 키와 값의 컨테이너로 이 정의는 MyLinearMap 클래스에 중첩되어 있으므로 같은 타입 파라미터인 K와 V를 사용</li>
  <li>equals는 상수시간, findEntry가 선형이므로 put과 get도 선형, remove는 ArrayList 시작이나 중간에서 삭제할경우 요소를 이동해야하지만 2번의 선형 연산이므로 마찬가지로 선형</li>
  <li>해시코드를 사용하면 Map의 증가차수를 더 개선할 수 있음</li>
</ul>

<h3 id="73-hashmap">7.3 HashMap</h3>
<ul>
  <li>Entry 대신 MyLinearMap(Entry List)의 List 컬랙션 사용</li>
  <li>키를 확인하여 어느 내장 Map에 투입할지 결정하기 위해 해시 함수 chooseMap 사용. 이 함수는 0bject 객체를 인자로
받아 해시 코드라는 정수를 반환하는데, 중요한 점은 같은 0bject 객체에 대해서는 항상 같은 해시 코드를 반환해야 함</li>
  <li>자바에서 모든 0bject 객체는 hashCode 라는 메소드를 제공하여 해시 함수를 계산하며, 메서드의 구현은 객체의 종류에 따라 달라짐</li>
  <li>하나의 Map이 여러 MyLinearMap으로 쪼개지는 만큼 탐색해야 하는 각 맵의 엔트리 개수는 더 줄어드므로 FindEntry 메서드와 그것을 호출하는 메서드의 속도가 더 빨라짐
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MyBetterMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

      protected List&lt;MyLinearMap&lt;K, V&gt;&gt; maps;

      public MyBetterMap() {
          makeMaps(2);
      }

      protected void makeMaps(int k) {
          maps = new ArrayList&lt;MyLinearMap&lt;K, V&gt;&gt;(k);
          for (int i=0; i&lt;k; i++) {
              maps.add(new MyLinearMap&lt;K, V&gt;());
          }
      }

      protected MyLinearMap&lt;K, V&gt; chooseMap(Object key) {
          //ath.abs 메서드를 호출하여 절대값을 만들고 %를 사용하여 결과가 0 에서 map.size()-1 사이에 있음을 보장
          int index = key==null ? 0 : Math.abs(key.hashCode()) % maps.size();
          return maps.get(index);
      }

      @Override
      public V get(Object key) {
          MyLinearMap&lt;K, V&gt; map = chooseMap(key);
          return map.get(key);
      }

      @Override
      public V put(K key, V value) {
          MyLinearMap&lt;K, V&gt; map = chooseMap(key);
          return map.put(key, value);
      }

      @Override
      public int size() {
          // add up the sizes of the sub-maps
          int total = 0;
          for (MyLinearMap&lt;K, V&gt; map: maps) {
              total += map.size();
          }
          return total;
      }

      @Override
      public void clear() {
          // clear the sub-maps
          for (int i=0; i&lt;maps.size(); i++) {
              maps.get(i).clear();
          }
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>탐색해야 할 Map 당 Entry가 n/k개로 줄어들지만 chooseMap을 호출하는 get, put 메소드의 성능은 여전히 n에 비례함</li>
  <li>하지만 n과 함께 k를 늘려간다면 n/k의 크기를 제한할 수 있음. 3. ArrayList의 분할상환방식에서 확인한 것처럼 매번 n이 k를 초과할 때 k를 두 배로 늘린다면 put을 상수시간으로 줄일 수 있음. 또한 하위 맵당 엔트리의 개수가 일정하면 단일 하위 맵은 상수 시간으로 검색할 수 있음</li>
  <li>MyBetterMap에서 각 맵의 크기는 ArrayList에 의존하여 자동으로 증가하므로 FACTOR 값만큼 맵 당 최대 엔트리 개수를 제한하고 요소가 새로 추가되면 내장 Map을 새로 생성</li>
  <li>앞서 정의한 MyBetterMap을 상속받아 HashMap 정의
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MyHashMap&lt;K, V&gt; extends MyBetterMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

      protected static final double FACTOR = 1.0; //하위 맵당 최대 엔트리 개수

      @Override
      public V put(K key, V value) {
          V oldValue = super.put(key, value);

          //size() : 엔트리의 전체 개수인 n
          //maps.size() : 내장된 map의 개수인 k
          if (size() &gt; maps.size() * FACTOR) {
              rehash();
          }
          return oldValue;
      }
  }
</code></pre></div>    </div>
  </li>
  <li>put 메소드만 새로 재정의하여 MyBetterMap의 put 메소드를 호출하고 재해시가 필요한지 확인</li>
  <li>n 〉 k * FACTOR면 하위 맵당 엔트리의 개수가 임계치를 초과함을 의미하므로 rehash 메서드를 호출. rehash 메서드가 호출될 때마다 내장된 맵의 개수 k는 두 배가 됨</li>
  <li>맵 당 엔트리 개수가 제한됨으로서 get, containsKey, remove 메소드는 자동으로 상수시간이 됨</li>
  <li>그러나 size 메소드가 여전히 선형이므로 대신 size 인스턴스 변수를 추가하여 put, remove 메소드에서 관리
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ...
  private int size = 0;

  @Override
  public V remove(Object key) {
      MyLinearMap&lt;K, V&gt; map = chooseMap(key);
      size -= map.size();
      V oldValue = map.remove(key);
      size += map.size();
      return oldValue;
  }

  @Override
  public V put(K key, V value) {
      MyLinearMap&lt;K, V› map = chooseMap(key);
      size -= map.size();
      V oldValue = map.put(key, value);
      size += map.size();
      if (size() 〉 maps.size() * FACTOR) {
          size = 0;
          rehash();
      }
      return oldValue;
  }

  @Override
  public int size() {
      return size;
  }

  @Override
  public void clear() {
      super.clear();
      size = 0;
  }
  ...
</code></pre></div>    </div>
  </li>
  <li>size 메소드가 상수시간이 되어 put 메소드도 자동으로 상수시간이 됨</li>
  <li>MyBetterMap에서 clear 메소드는 오히려 선형이 되었지만 자주 사용되지 않는 함수라 감안할 만함</li>
  <li>많은 객체가 동일한 해시 코드를 갖는다면 결국 같은 하위 맵으로 몰리게 되고, k개의 하위 맵으로 인한 성능 향상은 k보다 줄어들게 됨. 따라서 해시 함수는 해시코드를 균등하게 분배해야 함</li>
  <li>해싱을 사용하는 자료구조에서 가변 객체를 키로 사용하는 것은 위험함. 키가 맵에 있는 동안 키 값이 변경되면 해당 값을 찾지 못하게 됨</li>
  <li>equals()가 true인 객체들은 반드시 hashCode() 결과값이 동일해야 해시 기반 컬렉션에서 올바르게 동작함</li>
</ul>

<h3 id="74-treemap">7.4 TreeMap</h3>
<ul>
  <li>HashMap은 널리 사용되지만 상수시간이라도 상수가 상당히 커지거나, 하위 맵에 고르게 키를 분배하는 좋은 해시 함수를 설계하는게 어렵거나, 저장되는 데이터에 순서가 없다는 문제점이 있음</li>
  <li>TreeMap은 해싱을 사용하지 않으며 이진 탐색 트리에 키를 저장하므로 키를 선형 시간으로 순서대로 조회할 수 있음. 또한 핵심 메소드의 실행시간이 log n에 비례하여 쓸만함</li>
  <li>이진 탐색 트리는 아래와 같은 속성이 있음
    <ul>
      <li>노드 왼쪽에 자식이 있다면 왼쪽 하위 트리의 모든 키는 노드에 있는 키보다 작음</li>
      <li>노드 오른쪽에 자식이 있다면 오른쪽 하위 트리의 모든 키는 노드에 있는 키보다 큼</li>
      <li>따라서 검색할 때 트리 전체를 탐색할 필요 없이 트리의 각 수준에서 한개의 자식노드만 찾으면 됨. 이는 트리의 높이인 log n에 비례함
        <ul>
          <li>이진 트리의 높이 별 총 노드 개수는 n = 2^h - 1이므로, log를 씌우면 log n ≈ h</li>
        </ul>
      </li>
      <li>위의 조건들을 만족할 뿐 기본적으로는 균형있는 이진트리를 보장하진 않음</li>
    </ul>
  </li>
  <li>이진 탐색 트리로 Map 인터페이스를 구현하면 아래와 같음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MyTreeMap&lt;K, V&gt; implements Map&lt;K, V&gt; {
      private int size = 0;
      private Node root = null;

      protected class Node {
          public K key;
          public V value;
          public Node left = null;
          public Node right = null;

          public Node(K key, V value) {
              this.key = key;
              this.value = value;
          }
      }

      @Override
      public void clear() {
          size = 0;
          root = null;
      }

      @Override
      public boolean containsKey(Object target) {
          return findNode(target) != null;
      }

      private Node findNode(Object target) {
          if (target == null) {
              throw new IllegalArgumentException();
          }

          // key와 비교하기 위해 Object -&gt; Key 타입으로 형변환
          // Map 인터페이스 규약에 따르면 containsKey의 파라미터 타입은 Object
          @SuppressWarnings("unchecked")
          Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) target;

          Node node = root;
          while (node != null)
          {
              int cmp = k.compareTo(node.key);
              if (cmp &lt; 0)
                  node = node.left;
              else if (cmp &gt; 0)
                  node = node.right;
              else
                  return node;
          }
          return null;
      }

      private boolean equals(Object target, Object obj) {
          if (target == null) {
              return obj == null;
          }
          return target.equals(obj);
      }

      @Override
      public boolean containsValue(Object target) {
          return containsValueHelper(root, target);
      }

      private boolean containsValueHelper(Node node, Object target) {
          if (node == null) {
              return false;
          }
          if (equals(target, node.value)) {
              return true;
          }
          if (containsValueHelper(node.left, target)) {
              return true;
          }
          if (containsValueHelper(node.right, target)) {
              return true;
          }
          return false;
      }

      @Override
      public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {
          throw new UnsupportedOperationException();
      }

      @Override
      public V get(Object key) {
          Node node = findNode(key);
          if (node == null) {
              return null;
          }
          return node.value;
      }

      @Override
      public Set&lt;K&gt; keySet() {
          Set&lt;K&gt; set = new LinkedHashSet&lt;K&gt;();
          addInOrder(root, set);
          return set;
      }

      private void addInOrder(Node node, Set&lt;K&gt; set) {
          if(node == null) return;
          addInOrder(node.left, set);
          set.add(node.key);
          addInOrder(node.right, set);
      }

      @Override
      public V put(K key, V value) {
          if (key == null) {
              throw new NullPointerException();
          }
          if (root == null) {
              root = new Node(key, value);
              size++;
              return null;
          }
          return putHelper(root, key, value);
      }

      private V putHelper(Node node, K key, V value) {
          Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
          int cmp = k.compareTo(node.key);

          //리프 노드를 찾아서 키를 비교하여 크기에 따라 오른쪽/왼쪽 자식 노드로 추가
          if (cmp &lt; 0) {
              if (node.left == null) {
                  node.left = new Node(key, value);
                  size++;
                  return null;
              }
              else {
                  return putHelper(node.left, key, value);
              }
          }
          if (cmp &gt; 0) {
              if (node.right == null) {
                  node.right = new Node(key, value);
                  size++;
                  return null;
              }
              else {
                  return putHelper(node.right, key, value);
              }
          }
          V oldValue = node.value;
          node.value = value;
          return oldValue;
      }

      @Override
      public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
          for (Map.Entry&lt;? extends K, ? extends V&gt; entry: map.entrySet()) {
              put(entry.getKey(), entry.getValue());
          }
      }

      @Override
      public V remove(Object key) {
          if (root == null) throw new UnsupportedOperationException();

          Node deletedNode = new Node(null, null);
          root = removeHelper(root, (Comparable&lt;? super K&gt;) key, deletedNode);
          if (deletedNode.value != null) size--;
            
          return deletedNode.value;
      }

      public Node removeHelper(Node node, Comparable&lt;? super K&gt; key, Node deletedNode) {
          int cmp = key.compareTo(node.key);

          if (cmp &lt; 0) {
              node.left = removeHelper(node.left, key, deletedNode);
          } else if (cmp &gt; 0) {
              node.right = removeHelper(node.right, key, deletedNode);
          } else {
              // 삭제할 노드 찾음
              if(deletedNode != null) deletedNode.value = node.value;

              // (1) 리프 노드
              if (node.left == null &amp;&amp; node.right == null) return null;

              // (2) 자식 하나
              if (node.left == null) return node.right;
              if (node.right == null) return node.left;

              // (3) 자식 둘
              Node successor = findMin(node.right);  // 오른쪽 서브트리에서 가장 작은 값
              node.key = successor.key;
              node.value = successor.value;
              node.right = removeHelper(node.right, (Comparable&lt;? super K&gt;) successor.key, null);
          }
          return node;
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>clear는 root가 null이 될 시 자식 노드들을 수거하므로 선형시간임을 고려해야함</li>
  <li>findNode, put, remove는 key를 사용하기 때문에 트리의 높이에 비례하나 containsValue, keySet은 트리 전체를 검색하므로 n에 비례함</li>
  <li>트리의 모든 노드를 방문하는 방식으로 전위/중위/후위 순회가 있는데 containsValueHelper는 순서 상관없이 value를 확인하므로 전위 순회, addInorder는 오름차순으로 key 값을 정렬해야 하므로 중위 순회를 함</li>
  <li>위 코드에서 put 메소드를 확인해보면 순차적으로 증가하는 값들을 put 할 경우 오른쪽 자식에만 쏠린 불균형 트리가 됨</li>
  <li>불균형 트리를 해결하기 위해서는 Map에 키를 순서대로 넣지 않거나, put을 수정하여 트리가 불균형해질 때 노드를 재배열하는 로직을 추가해야 함(=자가 균형 트리)</li>
  <li>일반적인 자가 균형 트리로는 AVL 트리, 레드 블랙 트리가 있음</li>
  <li>java.util.TreeMap은 내부적으로 레드 블랙 트리로 구현되어 있어 순차적인 데이터가 삽입되어도 균형을 유지함</li>
  <li>remove 메소드는 삭제할 노드가 리프 노드인지, 자식 하나인지, 둘인지에 따라 다르게 동작함. 삭제할 노드의 자식이 둘일 경우 왼쪽 서브트리에서 가장 큰 값 또는 오른쪽 서브트리에서 가장 작은 값을 찾아 대체해야 함. 이는 트리의 균형을 다시 맞추는 작업과 유사한 연산을 거침</li>
</ul>

<h2 id="8-영속성">8. 영속성</h2>

<h3 id="81-redis">8.1 Redis</h3>
<ul>
  <li>앞의 7.1에서 두 가지 자료구조를 이용하여 인덱스를 저장했는데, 이러한 자료구조는 실행 중인 자바 프로그램의 메모리에 저장되어 프로그램이 멈추면 모두 사라짐</li>
  <li>레디스는 자바 자료구조와 유사한 영속적인 자료구조를 제공함. 기본적으로 String 타입의 키와 다양한 데이터 타입 중 하나를 값으로 넣을 수 있는 맵 구조를 가지며, 주요 자료구조는 아래와 같음
    <ul>
      <li>문자열 String</li>
      <li>자바 Set과 유사한 문자열 집합</li>
      <li>자바 List와 유사한 문자열 리스트</li>
      <li>자바 Map 과 유사한 해시
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public static void main(String[] args) throws IOException {

  Jedis jedis = make();

  // String
  jedis.set("mykey", "myvalue");
  String value = jedis.get("mykey");
  System.out.println("Got value: " + value);

  // Set
  jedis.sadd("myset", "element1", "element2", "element3");
  System.out.println("element2 is member: " + jedis.sismember("myset", "element2"));  // Jedis.sismember 메서드는 요소가 set에 있는지 검사

  // List
  jedis.rpush("mylist", "element1", "element2", "element3");                  // 리스트의 오른쪽 끝에 요소 추가
  System.out.println("element at index 1: " + jedis.lindex("mylist", 1));     // jedis.lindex는 정수 인덱스를 받아 list의 지정된 요소를 반환

  // Hash
  jedis.hset("myhash", "word1", Integer.toString(2));     // 키와 값은 모두 string이므로 Integer를 저장하려면 hset 메서드를 호출하기 전에 String 타입으로 변환해야 함
  jedis.hincrBy("myhash", "word2", 1);                    // word2 필드의 현재 값(존재하지 않으면 0)을 가져와서 1만큼 증가
  System.out.println("frequency of word1: " + jedis.hget("myhash", "word1"));
  System.out.println("frequency of word2: " + jedis.hget("myhash", "word2"));

  jedis.close();
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>자바 코드에서 Redis와 통신할 수 있게 해주는 클라이언트 라이브러리 Jedis를 만들고 서버에 연결하여 레디스 명령 실행</li>
  <li>Jedis.sismember, jedis.lindex, jedis.hincrBy 모두 상수시간 연산</li>
  <li>jedis.hset에서 첫번째 키는 특정 hash를 식별하고, 두번째 키(=필드)는 hash 안의 값을 식별함</li>
  <li>hash 안의 값의 정수인 경우가 많아 hincrby 같은 특별한 메서드가 제공됨. 이 메서드는 값을 정수로 취급함</li>
</ul>

<h2 id="9-위키피디아-크롤링과-검색-알고리즘">9. 위키피디아 크롤링과 검색 알고리즘</h2>

<h3 id="91-redis-기반의-인덱서-구현">9.1 Redis 기반의 인덱서 구현</h3>
<ul>
  <li>7.1에서 정의한 Index, TermCounter 클래스를 레디스로 이동</li>
  <li>레디스 데이터베이스에서 각 객체는 string 형의 유일한 키로만 식별되므로 두 종류 이상의 객체(Index, TermCounter)를 Redis에 넣는다면 이 둘을 구분할 수 있는 접두사를 추가해야 함
    <ul>
      <li>Index
        <ul>
          <li>Set에 키를 “URLSet : 단어”, 값을 url 주소로 저장</li>
          <li>해당 단어를 포함하는 url들의 Set</li>
        </ul>
      </li>
      <li>TermCounter
        <ul>
          <li>Hash에 첫번째 키를 “TermCounter : url 주소”, 두번째 키를 단어, 값을 단어 등장 횟수로 저장</li>
          <li>특정 url 주소 별 각 단어 등장 횟수 Map</li>
        </ul>
      </li>
      <li>기존 Index 객체에서는 단어 별 TermCounter들의 집합을 인스턴스로 가졌으나 TermCounter는 각 페이지 별 단어들과 단어 등장횟수를 저장하므로 Index 객체에 의존할 필요가 없음
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class JedisIndex {

  private Jedis jedis;

  public JedisIndex(Jedis jedis) {
      this.jedis = jedis;
  }

  private String urlSetKey(String term) {
      return "URLSet:" + term;
  }

  private String termCounterKey(String url) {
      return "TermCounter:" + url;
  }

  public void add(String term, TermCounter tc) {
      jedis.sadd(urlSetKey(term), tc.getLabel());
  }

  public boolean isIndexed(String url) {
      String redisKey = termCounterKey(url);
      return jedis.exists(redisKey);
  }

  public Map&lt;String, Integer&gt; getCounts(String term) {
      Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
      Set&lt;String&gt; urls = getURLs(term);
      for (String url : urls) {
          Integer count = getCount(url, term);
          map.put(url, count);
      }
      return map;
  }

  public Set&lt;String&gt; getURLs(String term) {
      Set&lt;String&gt; set = jedis.smembers(urlSetKey(term));
      return set;
  }

  public Integer getCount(String url, String term) {
      String redisKey = termCounterKey(url);
      String count = jedis.hget(redisKey, term);
      return new Integer(count);
  }

  public void indexPage(String url, Elements paragraphs) {
      System.out.println("Indexing " + url);
      // Termcounter 객체를 만들어 단락에 있는 검색어 개수를 셉니다
      TermCounter tc = new TermCounter(url);
      tc.processElements(paragraphs);
      // TermCounter의 내용을 레디스에 푸시합니다
      pushTermCounterToRedis(tc);
  }

  // url 별 term 등장횟수를 담은 TermCounter를 레디스의 Set 형태로 전환하여 레디스에 푸시
  public List&lt;Object&gt; pushTermCounterToRedis(TermCounter tc) {
      // jedis.multi()는 Jedis 객체의 모든 메서드를 제공하는 Transaction 객체를 반환
      Transaction t = jedis.multi();
      String url = tc.getLabel();
      String hashname = termCounterKey(url); // TermCounter : url
      // 페이지가 이미 인덱싱되어 있다면 기존 해시를 제거합니다
      t.del(hashname);
      // 각 검색어에 대해 TermCounter 에 엔트리와 인덱스의 새 멤버를 추가합니다.
      for (String term: tc.keySet()) {
          Integer count = tc.get(term);
          t.hset(hashname, term, count.toString()); //redis의 hash 자료구조에 추가
          t.sadd(urlSetKey(term), url); //redis의 set 자료구조에 추가 "URLSet: term"
      }
      List&lt;Object&gt; res = t.exec();    // 매번 서버와 통신하면 시간이 더 소요되므로 Transaction 동작을 모아뒀다 한꺼번에 적용
      return res;
  }
        
  // 인덱스 테스트를 위해 호출
  private static void loadIndex(JedisIndex index) throws IOException {
      WikiFetcher wf = new WikiFetcher();

      String url = "https://en.wikipedia.org/wiki/Java_(programming_language)";
      Elements paragraphs = wf.readWikipedia(url);
      index.indexPage(url, paragraphs);

      url = "https://en.wikipedia.org/wiki/Programming_language";
      paragraphs = wf.readWikipedia(url);
      index.indexPage(url, paragraphs);
  }
  ...
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>조회 성능 분석 : n개의 페이지 인덱싱 후 m개의 고유한 검색어를 검색 할 때 소요되는 시간 (getCounts)
    <ol>
      <li>HashMap을 생성</li>
      <li>getURL 메소드 호출하여 해당 단어를 포함한 URL 집합을 가져옴
        <ul>
          <li>getURL 메소드의 jedis.smembers는 Redis의 Set 자료구조에서 모든 요소를 가져오는 메서드로 단어에 해당하는 url들을 모두 순회함</li>
        </ul>
      </li>
      <li>집합에 있는 각 URL에 대해 getCount 메소드 호출하여 HashMap에 엔트리 추가
        <ul>
          <li>반복문 안에서 해당 단어가 등장하는 url 개수만큼 getCount를 호출하는데, 상수시간 연산이라 전체 복잡도는 최악의 상황에 n이 됨. 하지만 실제로 검색어를 포함한 페이지의 개수는 n보다 작은 경우가 많음</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>인덱싱 성능 분석 : 한 페이지를 인덱싱하는데 소요되는 시간 (indexPage)
    <ol>
      <li>해당 url 페이지의 DOM 트리를 순회하고 모든 TextNode 객체를 찾고 문자열을 검색어로 쪼갬</li>
      <li>각 검색어에 대해 HashMap 에 있는 카운터를 증가 (7.1의 TermCounter 클래스 processElements 함수 참고)</li>
      <li>pushTermCounterToRedis을 호출하여 검색어 별로 레디스에 해당 페이지에 대한 Index, TermCounter 저장</li>
      <li>1, 2번 동작은 페이지에 있는 단어 개수에 비례하고 3번 동작은 고유한 단어 개수에 비례하므로, 전체 복잡도는 페이지에 있는 단어 개수에 비례</li>
      <li>이론상 한 페이지가 인덱스의 모든 검색어를 포함할 경우 성능은 O(M)이지만 대부분의 검색 엔진은 관련 페이지를 식별하는데 도움되지 않는 일반적인 단어는 인덱싱하지 않음</li>
    </ol>
  </li>
</ul>

<h3 id="92-redis-기반-인덱스를-활용한-웹-크롤러-구현">9.2 Redis 기반 인덱스를 활용한 웹 크롤러 구현</h3>
<ul>
  <li>6.2.2에서 언급한 WikiPhilosophy 클래스에서는 Wikipedia 페이지를 순회하며 링크를 따라가는 크롤링 작업을 수행했는데, 각 페이지의 첫 번째 유효 링크만 따라갔던 WikiPhilosophy와 다르게 Wikipedia 전체를 인덱싱하기 위한 웹 크롤러 WikiCrawler 구현</li>
  <li>보통 아래와 같은 동작을 할 때 웹 크롤러라고 함
    <ul>
      <li>시작 페이지를 로드하고 내용을 인덱싱합니다.</li>
      <li>페이지에 있는 모든 링크를 찾고 연결된 URL 들을 컬렉션에 추가합니다.</li>
      <li>컬렉션을 반복하며 페이지를 로딩하고 이 페이지를 인덱싱하고 새로운 URL 을 추가합니다.</li>
      <li>이미 인덱싱된 URL 을 찾으면 건너뜁니다.</li>
    </ul>
  </li>
  <li>웹은 일종의 그래프와 같음. 각 페이지가 노드, 각 링크는 한 노드에서 다른 노드로의 단반향 선이 됨. 그래프를 탐색하기 위해 큐(queue)를 사용해 내부 링크를 순서대로 넓게 탐색함</li>
  <li>URL을 저장한 컬렉션에 따라 크롤러가 수행할 순회 방식이 결정되는데, 큐(FIFO)라면 너비 우선 탐색을, 스택(LIFO)이라면 크롤러는 깊이 우선 탐색을 함. 컬렉션에 있는 엔트리에 우선순위를 부여하여 오랫동안 인덱싱 되지 않은 페이지에 더 높은 우선순위를 주기도 함</li>
  <li>소스 노드에서 시작해 도달할 수 있는 노드를 한번 씩 방문하면서 각 Wikipedia 페이지의 단어 인덱스를 생성하는데, 한 페이지라도 새로 인덱싱되면 종료하고 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class WikiCrawler {

      @SuppressWarnings("unused")
      private final String source;

      private JedisIndex index;

      // queue of URLs to be indexed
      private Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();

      // fetcher used to get pages from Wikipedia
      final static WikiFetcher wf = new WikiFetcher();

      public WikiCrawler(String source, JedisIndex index) {
          this.source = source;
          this.index = index;
          queue.offer(source);
      }

      public int queueSize() {
          return queue.size();
      }

      public String crawl(boolean testing) throws IOException {
          if (queue.isEmpty()) {
              return null;
          }
          //큐에서 첫 번째 요소를 꺼내 반환하고 제거. 큐가 비어 있다면 null을 반환함
          String url = queue.poll();
          System.out.println("Crawling " + url);

          if (testing==false &amp;&amp; index.isIndexed(url)) {
              System.out.println("Already indexed.");
              return null;
          }
            
          Elements paragraphs;
          if (testing) {
              // 코드 저장소에 포함된 페이지의 캐시된 사본을 읽음
              paragraphs = wf.readWikipedia(url);
          } else {
              // 웹에 실제로 있는 최신 내용을 읽음
              paragraphs = wf.fetchWikipedia(url);
          }
          index.indexPage(url, paragraphs);
          // 큐에 페이지에 있는 링크들을 추가
          queueInternalLinks(paragraphs);		
          return url;
      }

      void queueInternalLinks(Elements paragraphs) {
          for (Element paragraph: paragraphs) {
              queueInternalLinks(paragraph);
          }
      }
        
      private void queueInternalLinks(Element paragraph) {
          Elements elts = paragraph.select("a[href]");
          for (Element elt: elts) {
              String relURL = elt.attr("href");
                
              if (relURL.startsWith("/wiki/")) {
                  String absURL = "https://en.wikipedia.org" + relURL;
                  //System.out.println(absURL);
                  queue.offer(absURL);
              }
          }
      }
        
      public static void main(String[] args) throws IOException {
          // make a WikiCrawler
          Jedis jedis = JedisMaker.make();
          JedisIndex index = new JedisIndex(jedis);
          String source = "https://en.wikipedia.org/wiki/Java_(programming_language)";
          WikiCrawler wc = new WikiCrawler(source, index);
            
          // source 주소를 주고 해당 페이지의 링크들을 큐에 추가
          Elements paragraphs = wf.fetchWikipedia(source);
          wc.queueInternalLinks(paragraphs);

          // loop until we index a new page
          String res;
          do {
              // test 용으로 돌릴 때만 true
              res = wc.crawl(false);
          } while (res == null);
            
          // "the"라는 단어를 인덱스에서 검색, 페이지 별 등장 횟수 출력
          Map&lt;String, Integer&gt; map = index.getCounts("the");
          for (Entry&lt;String, Integer&gt; entry: map.entrySet()) {
              System.out.println(entry);
          }
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="93-불리언-검색으로-검색-결과-조합하기">9.3 불리언 검색으로 검색 결과 조합하기</h3>
<ul>
  <li>검색 엔진 기능을 구현하려면 각 검색어를 포함하는 페이지를 반환하는 조회 기능(9.1, 9.2) 다음으로 불리언 로직을 사용하여 다수의 검색어로부터의 결과를 조합하는 불리언 검색이 필요함
    <ul>
      <li>검색어에 따라 AND, OR, -(차집합) 등</li>
      <li>예시
        <ul>
          <li>java AND programming</li>
          <li>java OR programming</li>
          <li>java -indonesia</li>
        </ul>
      </li>
      <li>예시와 같이 검색어와 연산을 함께 포함한 표현을 쿼리라 함
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class WikiSearch {

  // map from URLs that contain the term(s) to relevance score
  private Map&lt;String, Integer&gt; map;

  public WikiSearch(Map&lt;String, Integer&gt; map) {
      this.map = map;
  }

  public Integer getRelevance(String url) {
      Integer relevance = map.get(url);
      return relevance==null ? 0: relevance;
  }

  private  void print() {
      List&lt;Entry&lt;String, Integer&gt;&gt; entries = sort();
      for (Entry&lt;String, Integer&gt; entry: entries) {
          System.out.println(entry);
      }
  }

  public WikiSearch or(WikiSearch that) {
      Map&lt;String, Integer&gt; union = new HashMap&lt;String, Integer&gt;(map);
      for (String term: that.map.keySet()) {
          int relevance = totalRelevance(this.getRelevance(term), that.getRelevance(term));
          union.put(term, relevance);
      }
      return new WikiSearch(union);
  }

  public WikiSearch and(WikiSearch that) {
      Map&lt;String, Integer&gt; intersection = new HashMap&lt;String, Integer&gt;();
      for (String term: map.keySet()) {
          if (that.map.containsKey(term)) {
              int relevance = totalRelevance(this.map.get(term), that.map.get(term));
              intersection.put(term, relevance);
          }
      }
      return new WikiSearch(intersection);
  }

  public WikiSearch minus(WikiSearch that) {
      Map&lt;String, Integer&gt; difference = new HashMap&lt;String, Integer&gt;(map);
      for (String term: that.map.keySet()) {
          difference.remove(term);
      }
      return new WikiSearch(difference);
  }

  protected int totalRelevance(Integer rel1, Integer rel2) {
      // simple starting place: relevance is the sum of the term frequencies.
      return rel1 + rel2;
  }

  public List&lt;Entry&lt;String, Integer&gt;&gt; sort() {

      // entrySet()은 이 key-value 쌍들을 모아서 Set&lt;Map.Entry&lt;K,V&gt;&gt; 형태로 반환
      // Set은 순서가 보장되지 않으므로 정렬을 위해 List 형태로 복사
      List&lt;Entry&lt;String, Integer&gt;&gt; entries = 
              new LinkedList&lt;Entry&lt;String, Integer&gt;&gt;(map.entrySet());
            
      // make a Comparator object for sorting
      Comparator&lt;Entry&lt;String, Integer&gt;&gt; comparator = new Comparator&lt;Entry&lt;String, Integer&gt;&gt;() {
          @Override
          public int compare(Entry&lt;String, Integer&gt; e1, Entry&lt;String, Integer&gt; e2) {
              return e1.getValue().compareTo(e2.getValue());
          }
      };
            
      // sort and return the entries
      Collections.sort(entries, comparator);
      return entries;
  }

  public static WikiSearch search(String term, JedisIndex index) {
      Map&lt;String, Integer&gt; map = index.getCounts(term);
      return new WikiSearch(map);
  }

  public static void main(String[] args) throws IOException {

      // make a JedisIndex
      Jedis jedis = JedisMaker.make();
      JedisIndex index = new JedisIndex(jedis);

      // search for the first term
      String term1 = "java";
      System.out.println("Query: " + term1);
      WikiSearch search1 = search(term1, index);
      search1.print();

      // search for the second term
      String term2 = "programming";
      System.out.println("Query: " + term2);
      WikiSearch search2 = search(term2, index);
      search2.print();

      // compute the intersection of the searches
      System.out.println("Query: " + term1 + " AND " + term2);
      WikiSearch intersection = search1.and(search2);
      intersection.print();
  }
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>WikiSearch의 map은 URL과 해당 페이지의 관련성 점수까지 포함. 관련성 점수는 쿼리에서 추론한 사용자의 요구를 페이지가 얼마나 잘 반영하였는지를 나타낸 수치로, 여기선 해당 페이지에 검색어가 몇 번이나 등장했는지에 대한 TF(term frequency)에 기반을 둠</li>
  <li>다수의 검색어일 때 페이지의 관련성은 TF의 합이 됨</li>
  <li>sort 메서드의 내용을 채워서 관련성이 높은 순서로 결과를 반환. 어떤 종류의 List 객체를 정렬할 때는 java.util.Collections 클래스의 sort 메서드를 사용함</li>
  <li>Collections.sort 메서드를 사용하려면 인자로 받는 리스트의 요소 자체가 Comparable를 구현하거나, Comparator 객체를 리스트와 함께 인자로 전달해야 함</li>
</ul>

<h4 id="931-comparable과-comparator">9.3.1 Comparable과 Comparator</h4>
<ul>
  <li>Comparable
    <ul>
      <li>Comparable 인터페이스의 compareTo() 메소드 명세에는 this가 that 보다 작으면 음수를 반환하고, this가 더 크면 양수를 반환하고, 두 개가 같으면 0 을 반환하게 되어 있음
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class Card implements Comparable&lt;Card&gt; {

      private final int rank:
      private final int suit;

      public int compareTo(Card that) {
          if (this.suit &lt; that.suit) {
              return -1;
          }
          if (this.suit &gt; that.suit) {
              return 1;
          }
          if (this.rank &lt; that.rank) {
              return -1;
          }
          if (this.rank &gt; that.rank) {
              return 1;
          }
          return 0;
      }
      ...
  }
</code></pre></div>        </div>
      </li>
      <li>아래의 sort 메서드는 객체 자체에서 순서를 결정하므로 자연 순서로 요소를 정렬
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Collections.sort(cards);
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>Comparator
    <ul>
      <li>Comparator 객체를 주입하여 다른 순서로 정렬할 수도 있음. 예를 들면 카드 게임에서는 기본적으로 에이스가 가장 낮은 등급이지만, 어떤 카드 게임에서는 가장 높은 등급이 되기도 함. 아래와 같이 에이스를 최상에 놓는 Comparator 객체를 정의할 수 있음
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Comparator&lt;Card&gt; comparator = new Comparator&lt;Card&gt;() {
      @Override
      public int compare(Card card1, Card card2) {
          if (card1.getSuit() &lt; card2.getSuit()) {
              return -1;
          }
          if (card1.getSuit() &gt; card2.getSuit()) {
              return 1;
          }
          int rank1 = getRankAceHigh(card1);
          int rank2 = getRankAceHigh(card2);

          if (rank1 &lt; rank2) {
              return -1;
          }
          if (rank1 &gt; rank2) {
              return 1;
          }
          return 0;
      }

      private int getRankAceHigh(Card card) {
          int rank = card.getRank();
          if (rank == 1) {
              return 14;
          } else {
              return rank;
          }
      }
  };    
</code></pre></div>        </div>
      </li>
      <li>아래와 같이 호출 가능
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Collections.sort(cards, comparator);
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="10-정렬">10. 정렬</h2>

<h3 id="101-삽입-정렬">10.1 삽입 정렬</h3>
<ul>
  <li>예제
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void insertionSort(List&lt;T&gt; list, Comparator&lt;T&gt; comparator) {
	
      for (int i=1; i &lt; list.size(); i++) {
          T elt_i = list.get(i);
          int j = i;
          while (j &gt; 0) {
              T elt_j = list.get(j-1);
              if (comparator.compare(elt_i, elt_j) &gt;= 0) {
                  break;
              }
              list.set(j, elt_j);
              j--;
          }
          list.set(j, elt_i);
      }
  }    
</code></pre></div>    </div>
  </li>
  <li>이중 루프를 돌려 리스트의 앞부분부터 차례대로 정렬된 부분을 확장해 감</li>
  <li>elt_i에 정렬해야 할 값을 복사해 넣고 그 앞의 이미 정렬된 리스트에서 끼워 넣을 올바른 위치를 찾을 때까지 앞의 요소들을 한 칸씩 오른쪽으로 이동시킴</li>
  <li>외부 반복문은 1부터 list.size()까지 반복하고 내부 반복문은 i에서 0까지 반복하므로 총 실행 횟수는 이차가 됨</li>
  <li>단, 요소가 이미 어느정도 정렬되어 있으면 삽입 정렬은 선형이 됨. 또한 실행시간이 an^2 이지만 구현이 단순해 최대 차수의 계수인 a가 작음</li>
</ul>

<h3 id="102-병합-정렬">10.2 병합 정렬</h3>
<ul>
  <li>예제
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void mergeSortInPlace(List&lt;T&gt; list, Comparator&lt;T&gt; comparator) {
      List&lt;T&gt; sorted = mergeSort(list, comparator);
      list.clear();
      list.addAll(sorted);
  }

  public List&lt;T&gt; mergeSort(List&lt;T&gt; list, Comparator&lt;T&gt; comparator) {
      int size = list.size();
      if (size &lt;= 1) {
          return list;
      }
      // make two lists with half the elements each.
      List&lt;T&gt; first = mergeSort(new LinkedList&lt;T&gt;(list.subList(0, size/2)), comparator);
      List&lt;T&gt; second = mergeSort(new LinkedList&lt;T&gt;(list.subList(size/2, size)), comparator);
		
      return merge(first, second, comparator);
  }

  private List&lt;T&gt; merge(List&lt;T&gt; first, List&lt;T&gt; second, Comparator&lt;T&gt; comparator) {

      List&lt;T&gt; result = new LinkedList&lt;T&gt;();
      int total = first.size() + second.size();
      for (int i=0; i&lt;total; i++) {
          List&lt;T&gt; winner = pickWinner(first, second, comparator);
          result.add(winner.remove(0));
      }
      return result;
  }

  private List&lt;T&gt; pickWinner(List&lt;T&gt; first, List&lt;T&gt; second, Comparator&lt;T&gt; comparator) {
      if (first.size() == 0) {
          return second;
      }
      if (second.size() == 0) {
          return first;
      }
      int res = comparator.compare(first.get(0), second.get(0));
      if (res &lt; 0) {
          return first;
      }
      if (res &gt; 0) {
          return second;
      }
      return first;
  }
</code></pre></div>    </div>
  </li>
  <li>맨 앞에서 요소를 제거(remove(0))하는 연산이 O(1)인 LinkedList 사용</li>
  <li>크기가 1이 될 때까지 list를 쪼갠 다음, merge 할때 양쪽 리스트는 각각 오름차순 정렬이 되어있으므로 양쪽 리스트의 가장 앞에서부터 비교하여 더 작은 값부터 반환할 리스트에 추가</li>
  <li>크기가 1이 될 때까지 n을 반으로 나누는 횟수는 log n, 1에서 n으로 돌아가기 위해서도 log n번 병합이 필요하고 병합하는 과정에서 n번 이하로 루프를 돌리므로 전체 시간은 O(n log n)이 됨</li>
  <li>O(n log n)은 비교 정렬 알고리즘의 이론적 하한선으로 알려져 있음</li>
</ul>

<h3 id="103-기수-정렬">10.3 기수 정렬</h3>
<ul>
  <li>비교하지 않는 정렬. 32bit 정수 또는 20 캐릭터 문자열과 같이 요소의 크기가 제한된 경우에 동작함</li>
  <li>정수나 문자열 등의 자리수(digit) 단위로 나누어 정렬
    <ul>
      <li>먼저 일의 자리, 그 다음 십의 자리, 마지막으로 백의 자리 순으로 정렬</li>
    </ul>
  </li>
  <li>각 자리수를 정렬할 때 카운팅 정렬(알파벳 또는 제한된 숫자 순)을 사용하므로 단어 정렬에서 알파벳 26자를 k, 리스트에 있는 단어의 개수를 n, 단어의 최대 자릿수를 d라고 하면 시간복잡도는 O(d×(n+k))가 됨 =&gt; 선형
    <ul>
      <li>순서
        <ol>
          <li>카운트 배열 count[] 초기화
            <ul>
              <li>각 자릿수의 가능한 값(예: 알파벳 26개)에 대해 등장 횟수를 저장할 배열 생성</li>
              <li>배열 크기 = 26, 모든 값 0으로 초기화</li>
            </ul>
          </li>
          <li>원소 세기 (count 업데이트)
            <ul>
              <li>리스트의 각 원소를 확인하며 해당 값에 1씩 더함</li>
              <li>예: “cat” → 첫 글자 ‘c’에 해당하는 count 증가</li>
            </ul>
          </li>
          <li>누적합으로 count[] 업데이트
            <ul>
              <li>count[i] = 현재 값 i가 들어갈 끝 위치</li>
              <li>이 정보를 이용하면 원소를 정렬된 위치에 바로 배치 가능</li>
            </ul>
          </li>
          <li>새 배열에 배치
            <ul>
              <li>리스트를 순회하며, count를 참고해 각 원소를 새 배열에 넣음</li>
              <li>count[i]는 값 i가 들어갈 마지막 인덱스를 의미하므로, 배치 후 count[i]–로 다음 동일 값이 올 위치를 조정</li>
            </ul>
          </li>
        </ol>
      </li>
      <li>2, 3번은 n, 1, 4번은 k만큼 소요되므로 2n+2k이 됨. 상수를 제거하면 n+k</li>
    </ul>
  </li>
</ul>

<h3 id="104-힙-정렬">10.4 힙 정렬</h3>
<ul>
  <li>힙을 이용해 최대값(또는 최소값)을 반복적으로 제거하며 정렬하는 알고리즘</li>
  <li>힙은 이진 탐색 트리와 유사한 자료구조이지만 다른 규칙을 가짐
    <ul>
      <li>이진 탐색트리의 각 노드는 왼쪽 하위 트리보다 크고 오른쪽 하위 트리보다 작은 값을 갖지만, 최소 힙에서 각 노드의 양쪽 하위트리는 모두 부모 노드의 값보다 큼</li>
    </ul>
  </li>
  <li>힙은 요소를 추가하거나 제거하면 트리의 균형을 맞추는 작업을 추가로 하므로 균형 이진 탐색트리와 비슷함</li>
  <li>힙에서 최대값(또는 최소값)는 항상 루트에 있고 상수 시간으로 찾을 수 있음. 힙에서 요소를 추가하거나 제거하는 시간은 트리의 높이인 h 에 비례하며, 균형을 유지하기 때문에 h는 log n에 비례함</li>
  <li>자바의 PriorityQueue 클래스는 힙으로 구현되어 있으며 Queue 인터페이스에 정의된 offer와 poll 메서드를 제공함
    <ul>
      <li>offer : 큐에 요소를 추가하며 모든 노드가 힙 속성을 갖도록 힙을 갱신. 실행시간은 log n</li>
      <li>poll : 루트로부터 큐에서 가장 작은 요소(최소 힙의 경우)를 제거하고 힙을 갱신. 실행시간은 log n</li>
    </ul>
  </li>
  <li>PriorityQueue는 이진 힙 자료구조로 되어있으며, 내부적으로는 배열로 저장됨. 기본적으로 최소 힙으로 동작하나 Comparator를 지정하여 최대 힙이나 사용자 정의 순서로 변경할 수 있음</li>
  <li>PriorityQueue 객체가 주어지면 offer 메소드로 컬렉션의 모든 요소를 추가한 다음, poll 메소드로 큐에서 요소들을 제거하며 List에 요소들을 추가하여 정렬을 쉽게 할 수 있음. poll 메서드는 루트에 있는 요소를 반환하므로 최소 힙의 경우 요소는 오름차순으로 List에 추가됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void heapSort(List&lt;T&gt; list, Comparator&lt;T&gt; comparator) {
      // comparator는 단순 Integer 값을 비교함
      PriorityQueue&lt;T&gt; heap = new PriorityQueue&lt;T&gt;(list.size(), comparator);
      heap.addAll(list);
      list.clear();
      while (!heap.isEmpty()) {
          list.add(heap.poll());
      }
  }
</code></pre></div>    </div>
  </li>
  <li>큐에 n개의 요소를 추가하거나 제거 시 n log n 시간이 걸림. 따라서 힙 정렬의 실행시간은 O(n log n) 이 됨</li>
</ul>

<h4 id="1041-제한된-힙-정렬">10.4.1 제한된 힙 정렬</h4>
<ul>
  <li>최대 k개의 요소만 담을 수 있는 힙. 상위 k개의 요소를 추적하기 위해 최소 힙을 사용하여 힙이 가득찰 경우 새로 추가할 요소가 힙에서 가장 작은 요소보다 클 때만 해당 요소를 대체하도록 함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public List&lt;T&gt; topK(int k, List&lt;T&gt; list, Comparator&lt;T&gt; comparator) {
      PriorityQueue&lt;T&gt; heap = new PriorityQueue&lt;T&gt;(list.size(), comparator);
      for (T element: list) {
          // 힙이 가득차지 않았으면 새로 추가
          if (heap.size() &lt; k) {
              heap.offer(element);
              continue;
          }
          // heap.peek()은 힙의 루트를 반환
          int cmp = comparator.compare(element, heap.peek());
          // element가 루트보다 우선순위가 높을 경우 루트를 제거하고 element 삽입
          if (cmp &gt; 0) {
              heap.poll();
              heap.offer(element);
          }
      }
      List&lt;T&gt; res = new ArrayList&lt;T&gt;();
      while (!heap.isEmpty()) {
          res.add(heap.poll());
      }
      return res;
  }
</code></pre></div>    </div>
  </li>
  <li>성능 분석
    <ul>
      <li>힙에서 가장 작은 요소를 찾는 것은 O(1), comparator.compare도 단순 Integer 비교로 O(1)</li>
      <li>가장 작은 요소를 제거하는 것은 O(log k)이며 최악의 상황에서 요소가 오름차순으로 정렬되었을 경우 새로 추가하는 것도 O(log k)
        <ul>
          <li>입력 리스트가 아래와 같은 경우 새로 추가될 값이 항상 기존 힙의 루트보다 크지만, 이런 상황에서도 새 요소를 추가하거나 교체하는 데는 O(log k)가 걸림
            <ul>
              <li>[1, 2, 3, 4, 5, 6, 7, 8, 9 … n]</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>따라서 위의 예제에서 n개 요소를 정렬하는 총 시간은 O(n log k)이고 n에 선형임</li>
    </ul>
  </li>
</ul>

<h2 id="11-공간-복잡도">11. 공간 복잡도</h2>
<ul>
  <li>대부분 응용 프로그램에서 가능한 공간보다는 실행시간에 좀 더 많은 관심을 두지만 대규모 데이터셋일 때는 공간 복잡도 역시 고려해야 함
    <ul>
      <li>데이터셋을 단일 프로그램의 메모리에 모두 담을 수 없다면 실행시간은 급격히 늘어나거나 아예 실행할 수가 없게 되는데, 적은 공간이 필요한 알고리즘을 선택하여 메모리에서 계산할 수 있게 만들면 실행 속도는 훨씬 빨라짐. 또한 적은 공간을 사용하는 프로그램은 CPU 캐시를 더 잘 활용하고 더 빠르게 실행할 수 있음</li>
    </ul>
  </li>
  <li>병합 정렬의 단점 중 하나는 데이터의 복사본을 만든다는 것인데, 앞의 구현에서 할당하는 총 공간은 O(n log n)이나 좀 더 개선하면 공간 요구사항을 O(n)까지 낮출 수 있음
    <ul>
      <li>mergeSort() 메소드의 아래 부분에서 subList로 list의 노드를 first, second에 복사하는 대신 노드를 재활용하면 공간 복잡도를 O(n)으로 개선 가능
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  List&lt;T&gt; first = mergeSort(new LinkedList&lt;T&gt;(list.subList(0, size/2)), comparator);
  List&lt;T&gt; second = mergeSort(new LinkedList&lt;T&gt;(list.subList(size/2, size)), comparator);
</code></pre></div>        </div>
      </li>
      <li>새 리스트 생성 없이 완전히 노드 연결만 재배치하게 변경할 경우 O(log n)까지도 개선할 수 있다고 함</li>
    </ul>
  </li>
  <li>삽입 정렬은 병합 정렬과 달리 그 자리에서 바로 요소를 정렬하기 때문에 공간적으로 개수의 크기(n)에 의존하지 않는다는 장점이 있음</li>
  <li>힙 정렬 구현은 요소를 저장하고자 새로운 PriorityQueue 객체를 생성하므로 공간은 O(n)이나, 리스트를 그 자리에서 바로 정렬하면 O(1)로 줄일 수 있음. 제한된 힙 정렬에서는 k에 비례하는 공간만 필요해짐
    <ul>
      <li>PriorityQueue 같은 별도 자료구조를 사용하지 않고, ArrayList 자체를 배열처럼 다뤄서 힙 기능을 구현</li>
    </ul>
  </li>
</ul>]]></content><author><name>Toyo</name></author><category term="CS" /><category term="java" /><category term="자료구조" /><category term="알고리즘" /><summary type="html"><![CDATA[1. 인터페이스 프로그래밍 java.util.List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List 인터페이스에 정의된 메소드는 ArrayList와 LinkedList 또는 List 인터페이스를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨 라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨]]></summary></entry><entry><title type="html">자바 기초 정리1 (자바의 신 vol.1)</title><link href="/cs/2025/07/22/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-(%EC%9E%90%EB%B0%94%EC%9D%98-%EC%8B%A0-vol.1).html" rel="alternate" type="text/html" title="자바 기초 정리1 (자바의 신 vol.1)" /><published>2025-07-22T00:00:00+00:00</published><updated>2025-07-22T00:00:00+00:00</updated><id>/cs/2025/07/22/%EC%9E%90%EB%B0%94%20%EA%B8%B0%EC%B4%88%20%EC%A0%95%EB%A6%AC%20(%EC%9E%90%EB%B0%94%EC%9D%98%20%EC%8B%A0%20vol.1)</id><content type="html" xml:base="/cs/2025/07/22/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-(%EC%9E%90%EB%B0%94%EC%9D%98-%EC%8B%A0-vol.1).html"><![CDATA[<h2 id="1-자바-변수와-자료형">1. 자바 변수와 자료형</h2>

<h3 id="11-변수의-종류">1.1 변수의 종류</h3>

<ul>
  <li>자바의 변수는 생명주기에 따라 4가지 종류로 나뉜다.
    <ul>
      <li>지역 변수
        <ul>
          <li>중괄호 내에서 선언된 변수</li>
          <li>생명주기도 해당 중괄호 내에서만 유효함</li>
          <li>자바에선 재선언이 허용되지 않으므로 해당 중괄호 내에서 동일한 이름을 갖는 지역 변수를 선언하면 컴파일 에러가 발생함</li>
        </ul>
      </li>
      <li>매개 변수
        <ul>
          <li>메소드에 넘겨주는 변수</li>
          <li>메소드가 호출될 대 생명이 시작되어 메소드가 끝나면 소멸</li>
        </ul>
      </li>
      <li>인스턴스 변수
        <ul>
          <li>메소드 밖, 클래스 안에 선언된 변수</li>
          <li>객체가 생성될 때 생명이 시작되며, 그 객체를 참조하고 있는 다른 객체가 없으면 소멸됨</li>
        </ul>
      </li>
      <li>클래스 변수
        <ul>
          <li>static 예약어가 붙은 인스턴스 변수</li>
          <li>클래스가 처음 로드될 때 생명이 시작되고, 자바 프로그램이 끝날 때 소멸됨</li>
          <li>클래스는 객체를 처음 생성하거나, 해당 클래스 변수에 접근하거나, 동적으로 로드하거나, 해당 클래스의 자식 클래스가 로드될 때 같이 로드됨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="12-자료형의-종류">1.2 자료형의 종류</h3>

<ul>
  <li>기본 자료형
    <ul>
      <li>바로 값을 넣어 초기화가 가능</li>
      <li>자료형의 첫 비트는 부호를 표시하는데 사용되며 음수의 범위가 양수의 범위보다 하나 더 큼. 부호비트가 1이고 나머지 비트가 0일 경우를 해당 타입의 최소값으로 사용하기 때문 (-2^n ~ -2^n-1)</li>
      <li>따라서 어떤 자료형에 최소값을 넣고 1을 빼면 최대값이, 최대값을 넣고 1을 더하면 최소값이 됨 (최소값이 10000000 이면 최대값은 01111111이기 때문)</li>
      <li>소수형 타입은 부동 소수점 연산을 사용하므로 값이 범위를 넘어서면 정확성이 보장되지 않음 -&gt; 대신 java.match.BigDemical이라는 클래스를 사용</li>
      <li>자바의 모든 자료형은 값을 지정하지 않으면 기본값 사용. 기본 자료형은 각자의 기본값을 가지고 참조형은 null. 그러나 지역 변수일 경우는 기본값이 자동 적용되지 않음</li>
      <li>자바는 계산 시 두 피연산자가 정수형일 때 결과 값도 정수형으로 취급하므로 결과가 소수값이어도 소수형으로 결과가 나오진 않음. 소수점 아래까지의 결과를 원하면 두 피연산자를 소수형으로 할 필요가 있음</li>
      <li>종류
        <ul>
          <li>정수형
            <ul>
              <li>byte  (-2^7 ~ 2^7-1)</li>
              <li>short (-2^15 ~ 2^15-1)</li>
              <li>int   (-2^31 ~ 2^31-1)</li>
              <li>long  (-2^63 ~ 2^63-1)
                <ul>
                  <li>long 자료형 초기화 시 L을 붙이지 않고 int 범위를 초과하는 값을 넣으면 에러 발생. 자바에서 기본적으로 숫자를 명시하면 int라고 생각하기 때문에 선언 시 L을 붙여주지 않으면 int로 인식됨</li>
                </ul>
              </li>
              <li>char
                <ul>
                  <li>정수형 중 유일하게 부호가 없음</li>
                  <li>내부적으로 아스키/유니코드에 대응하는 숫자값을 저장하는 정수형 타입이지만 데이터 처리 방식에는 차이가 있음</li>
                  <li>‘a’와 같은 문자를 저장할 수 있으므로 char 같은 정수형인 다른 자료형들도 가능한 범위일 경우 해당 문자 저장 가능</li>
                  <li>‘a’같은 문자와 \u + 4자리의 16진수 값을 넣는 것이 대표적. 해당 값의 유니코드 번호를 지정해도 초기화 가능</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>소수형
            <ul>
              <li>float</li>
              <li>double</li>
            </ul>
          </li>
          <li>boolean</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>참조 자료형
    <ul>
      <li>new 키워드를 사용해서 초기화 가능</li>
      <li>String 만은 예외적으로 new을 사용하지 않고도 초기화 가능</li>
    </ul>
  </li>
</ul>

<h2 id="2-연산자와-형변환">2. 연산자와 형변환</h2>

<h3 id="21-연산자">2.1 연산자</h3>

<ul>
  <li>연산자는 단항연산자   &gt;   *, /, %   &gt;   +, -   순으로 우선순위가 높다</li>
  <li>단항연산자 중 ~(틸드)는 2진수로 되어 있는 비트 값을 전부 거꾸로 바꾸는 데 사용</li>
  <li>등가 비교 연산자 (==, !=)는 같은 종류(정수형과 소수형도 같은 종류)끼리 비교가 가능하며 자바의 모든 기본 자료형과 참조 자료형에서 사용 가능. 참조 자료형은 주소값을 비교함</li>
  <li>자바의 연산자들은 타입별로 사용 가능한 연산자가 정해져 있음. douable, float는 소수형이므로 비트 연산이 불가능함</li>
  <li><code class="language-plaintext highlighter-rouge">&amp;</code>, <code class="language-plaintext highlighter-rouge">|</code>, <code class="language-plaintext highlighter-rouge">^</code>(값이 서로 다르면 true, 같으면 false) 연산자는 숫자에 사용하면 비트 연산을, boolean 타입 사이에 사용하면 논리 연산을 수행</li>
  <li>참조 자료형은 + 이항 연산자만 사용 가능. 사용 시 해당 클래스에 있는 toString() 메소드 결과끼리 더함</li>
</ul>

<h3 id="22-형변환">2.2 형변환</h3>

<ul>
  <li>기본 자료형 중 boolean 타입은 숫자로 변환할 수 없기 때문에 형변환 불가능</li>
  <li>더 범위가 넓은 타입으로 변환할 때는 문제가 없으나, 더 범위가 작은 타입으로 변환할 때는 소괄호 안에 타입을 명시해주어야 하며 예상치 못한 값이 나올수도 있음</li>
</ul>

<h2 id="3-조건문과-반복문">3. 조건문과 반복문</h2>

<h3 id="31-조건문">3.1 조건문</h3>
<ul>
  <li>switch 문
    <ul>
      <li>한번 case 조건을 만족시켜 줬다면 그다음 break가 올때까지 모든 case 통과하여 실행문 실행</li>
      <li>case문으로 이루어진 switch 문의 끝에는 default 문이 올 수 있으며 앞에 있는 조건에 맞지 않는 경우 실행됨. case문에서 한번이라도 걸렸으면 실행안됨</li>
      <li>switch() 괄호 안의 비교 대상 변수는 정수형만 사용 가능 했으나 JDK7부터 String도 사용 가능해짐</li>
    </ul>
  </li>
</ul>

<h3 id="32-반복문">3.2 반복문</h3>
<ul>
  <li>do-while 문 : 한 번은 꼭 실행시키고 싶을 때 사용. 마지막 while의 소괄호 뒤에 반드시 세미콜론을 입력해야 함</li>
  <li>label : 반복문에 이름을 부여하여(라벨명 : 반복문 형태로 정의) 특정 시점에 해당 반복문을 빠져나오거나(break 라벨명) 위로 돌아가도록 (continue 라벨명)할 수 있음</li>
</ul>

<h2 id="4-배열">4. 배열</h2>

<h3 id="41-배열의-선언과-기본값">4.1 배열의 선언과 기본값</h3>
<ul>
  <li>배열 선언 시 대괄호는 타입과 변수 사이에 또는 변수명 뒤에 빈 상태로 위치해야함</li>
  <li>참조 자료형이므로 new 키워드를 사용해 생성하거나, 중괄호를 사용해서 한번에 선언 및 초기화</li>
  <li>지역변수는 원래 기본값이 없으나, 배열에서는 지역 변수라고 해도 배열 크기만 정해주면 초기화 안해도 각 배열의 기본값이 할당됨</li>
  <li>기본 자료형 배열의 기본값은 각 자료형의 기본값과 동일
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  byteArray[0]=0
  shortArray[0]=0
  intArray[0]=0
  longArray[0]=0
  floatArray[0]=0.0
  doubleArray[0]=0.0
  charArray[0]=[ ]    //기본값은 ₩u0000으로 화면에 출력될 때에는 한 칸의 공백으로 보임
  booleanArray[0]=false
</code></pre></div>    </div>
  </li>
  <li>모든 참조자료형은 초기화 하지 않으면 null값을 기본적으로 가짐</li>
  <li>참고 : 초기화한 객체를 출력하면, 객체가 기본으로 가지는 toString() 메소드가 해당 객체의 클래스이름@메모리주소기반으로 생성된 16진수 해시코드를 반환하는 걸 확인할 수 있음
    <ul>
      <li>배열의 경우 [L클래스이름;@해당 배열의 고유번호. L은 해당 배열이 배열이라는 것을, L은 참조 자료형임을 의미</li>
      <li>boolean: Z, byte : b, char : C, double : D, float : F, int : I, long : J, short : S</li>
    </ul>
  </li>
</ul>

<h3 id="42-2차원-배열">4.2 2차원 배열</h3>
<ul>
  <li>아래와 같이 선언 및 초기화
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int [] twoDim[]; 
  int twoDim[][];

  twoDim = new int[2][3];
</code></pre></div>    </div>
  </li>
  <li>크기를 지정할 경우에는 반드시 한번에 설정하던지 1차원만 설정해야 함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  twoDim = new int[2][3];
  twoDim = new int[2][];
</code></pre></div>    </div>
  </li>
  <li>2차원은 1차원 크기 설정 뒤에도 설정가능. 2차원 방 크기는 서로 다를 수 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  twoDim = new int[2][];
  twoDim[0] = new int[3];
  twoDim[1] = new int[2];
</code></pre></div>    </div>
  </li>
  <li>
    <p>중괄호를 사용해서 한번에 선언 및 초기화 가능.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int [][]twoDim = {{1, 2, 3}, {4, 5, 6}};
</code></pre></div>    </div>
  </li>
  <li>2차원 배열에서 .length로 배열 크기를 확인할 때 1차원, 2차원 배열에 각각 .length를 붙여서 알아내야 하며, twoDim[0][0]는 배열 객체가 아닌 값이 들어있는 공간을 나타내기 때문에 실행 시 오류 발생
    <ul>
      <li>점(.)은 참조 자료형에서만 찍을 수 있으며 기본 자료형에서는 사용 불가
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  for(int i=0; i&lt;twoDim.length; i++){
  for(int j=0; j &lt;twoDim[i].length; j++){
      ...
  }
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>다만 위와 같이 .length를 사용하여 for 루프가 수행될 때마다 길이를 얻어오는 건 성능상 좋지 않으므로 아래와 같이 사용
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  int iLength = twoDim.length;
  for(int i = 0; i &lt; iLength; i++){
      int jLength = twoDim[i].length;
      for(int j = 0; j &lt; jLength; j++){
          ...
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="43-배열을-위한-for-루프">4.3 배열을 위한 for 루프</h3>
<ul>
  <li>
    <p>자바에서 제공되는 Collection이라는 자료구조를 처리할 때 for 루프를 보다 쉽게 사용 가능. JDK5부터 지원됨</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  for(타입이름 임시 변수명 : 반복대상객체){

  }

  //사용 예시
  int [][]twoDim= {{1, 2, 3}, {4, 5, 6}};
  for(int[] dimArray : twoDim){
      for(int data : dimArray){
          System.out.println(data);
      }
  }
</code></pre></div>    </div>
  </li>
  <li>
    <p>반복대상객체로는 Collection의 일부 클래스 사용 가능. 단, 이 루프 사용시 배열의 현재 인덱스는 따로 계산해야 함</p>
  </li>
</ul>

<h3 id="44-main-메소드의-배열-인자">4.4 main 메소드의 배열 인자</h3>
<ul>
  <li>main 메소드의 배열 인자 String ars[]에 아래와 같이 값을 전달할 수 있음 ([“a”, “b”, “c”, “d”] 배열 전달)
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class ArrayMain {
      public static void main(String args[]){
          ...
      }
  }
</code></pre></div>    </div>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  $ javac ArrayMain.java
  $ java ArrayMain a b c d
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="5-참조-자료형">5. 참조 자료형</h2>

<h3 id="51-this-예약어">5.1 this 예약어</h3>
<ul>
  <li>‘이 객체’를 의미. 생성자와 메소드 안에서 사용 가능.</li>
  <li>객체의 변수와 매개 변수의 이름이 동일할 때 서로 구분하기 위해서 사용</li>
</ul>

<h3 id="52-메소드-overloading">5.2 메소드 overloading</h3>
<ul>
  <li>자바에서는 타입이 다르면 다른 메소드로, 타입이 같고 변수 이름이 같으면 같은 메소드로 인식됨</li>
  <li>메소드의 이름을 같게 하고, 매개 변수만을 다르게 하는것을 overloading이라고 함. 만약 이름, 매개변수가 같은데 리턴 타입이 다르면 컴파일러가 메소드 호출 시 어느 쪽을 호출해야 할지 알 수 없게 되기 때문에 컴파일 오류가 발생</li>
  <li>리턴 타입은 overloading 기준은 아니므로 메소드명만 동일하고 매개변수, 리턴 타입이 달라도 overloading에 해당함</li>
  <li>같은 역할을 하는 메소드는 (매개변수가 달라지더라도) 같은 메소드 이름을 가져야 한다는 모토로 사용하는 것</li>
</ul>

<h3 id="53-static-메소드">5.3 static 메소드</h3>
<ul>
  <li>객체를 생성하지 않아도 호출 가능한 메소드. 단, 해당 메소드 안에서는 클래스(static) 변수만 사용 가능
    <ul>
      <li>단지 static 메소드에서 사용하기 위해 변수를 static으로 선언하는것은 지양해야 함. 인스턴스 변수에 static을 붙이면 해당 클래스의 모든 인스턴스 객체에서 하나의 값을 바라보게 됨</li>
    </ul>
  </li>
</ul>

<h3 id="54-static-블록">5.4 static 블록</h3>
<ul>
  <li>해당 클래스의 인스턴스 객체를 여러개 생성해야하지만, 한번만 호출되어야 하는 코드가 있을 경우 사용</li>
  <li>선언 위치 상관없이 무조건 생성자보다 먼저 실행되며 메소드가 아닌 클래스 내에 선언되어야 함</li>
  <li>static 메소드와 마찬가지로 static 블록 안에서는 static한 것들만 호출 가능</li>
  <li>생성자가 불리지 않아도 해당 클래스에 대한 참조가 발생하자마자 호출되므로 static 인스턴스 변수의 기본값을 덮어 씌움
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class StaticBlock {
      static int data = 1;
      public StaticBlock(){
          ...
      }

      static {
          data = 3;
      }

      static {
          data = 5;
      }

      public static int getData(){
          return data;
      }
  }

  pulic void ddd() {
      // StaticBlock 클래스에 대한 참조 발생
      // data=5 출력됨
      System.out.println("data=" + StaticBlock.getData()); 
      StaticBlock block1 = new StaticBlock();
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="55-pass-by-value-pass-by-reference">5.5 Pass by Value, Pass by Reference</h3>
<ul>
  <li>모든 기본 자료형은 Pass by Value, 참조 자료형은 값이 아닌 참조가 전달되는 Pass by Reference</li>
  <li>String b = “z”와 String b = new String(“z”)는 동일하게 new를 사용하여 객체를 생성한 것과 같기 때문에, 호출하는 함수에 인자로 String 변수를 전달해도 참조가 아닌 객체가 새로 생성(복사)되어 넘어간 것이 됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ...
  String a = "a";
  passByValue(b);
  public void passByValue(String b){
      b = "b";    // 여전히 a 변수의 값은 "a"로 유지됨
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="56-매개변수를-임의의-개수만큼-전달하기">5.6 매개변수를 임의의 개수만큼 전달하기</h3>
<ul>
  <li>함수로 넘길 매개 변수의 수를 정하기 애매한 경우 아래와 같이 사용할 수 있으나 넘길 숫자들을 직접 배열로 만든 후 넘겨줘야 한다는 단점이 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ...
 varargs.calculateNumbersWithArray(new int[]{1, 2, 3, 4, 5});
 public void calculateNumbersWithArray(int []numbers){
     ...
 }
</code></pre></div>    </div>
  </li>
  <li>아래와 같이 “타입…변수명”으로 선언해도 마찬가지로 numbers는 배열로 인식되며, 함수 호출 시 필요한만큼 매개변수를 바로 넘길 수 있어 편리함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ...
  varargs.calculateNumbers(1, 2, 3, 4, 5);
  public void calculateNumbers(int...numbers){
      ...
  }
</code></pre></div>    </div>
    <ul>
      <li>해당 방식은 하나의 메소드에서 한 번만 사용 가능하고, 여러 매개 변수가 있다면 가장 마지막에 선언해야 함
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public void arbitrary(String message, int...numbers){   //해당 매개변수 마지막으로
      ...
  }
</code></pre></div>        </div>
      </li>
      <li>System.out.printf() 메소드는 아래와 같이 정의되어 가장 앞에 출력하는 포맷을 선언하고, 뒤에는 Object라는 타입의 args를 임의의 개수만큼 받을 수 있음
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  printf(String format, Object...args)   //format 문자열에 정의한 포맷 수만큼 args로 전달하여 출력할 수 있음
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="6-패키지">6. 패키지</h2>

<h3 id="61-패키지-선언-시-규칙">6.1 패키지 선언 시 규칙</h3>
<ul>
  <li>소스의 가장 첫 줄에 있어야 함</li>
  <li>패키지 선언은 소스 하나에 하나만 있어야 함</li>
  <li>package 선언과 파일 시스템의 디렉토리 구조가 일치해야 컴파일 또는 실행 시 해당 소스 또는 클래스 파일을 찾을 수 있음</li>
  <li>컴파일 시 javac 명령에 package 구조에 맞는 소스 파일 경로를 줘야 함. 따라서 패키지 루트 디렉토리(package com.example로 정의한 경우 com이 패키지 루트 디렉토리)의 디렉토리나 그 상위 디렉토리에선 컴파일 가능하지만 하위 디렉토리에선 안됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  # Main.java에 package com.example로 선언 시

  cd src
  javac com/example/Main.java
  # 현재 디렉토리(src)가 패키지 루트
  # 클래스 파일도 com/example 밑에 Main.class로 생성됨

  # 또는
  javac -d out src/com/example/Main.java
  # 패키지 루트 디렉토리의 상위 디렉토리에서 컴파일하지만 package 구조에 맞는 소스 파일 경로를 포함함
  # -d out: out이 클래스파일 기준 패키지 루트. 사용 시 클래스 파일 기준 패키지 루트와 소스 파일 기준 패키지 루트가 달라짐. 소스 파일 경로와 클래스 파일 경로를 다르게 하고 싶을 때 사용
  # out 폴더 밑에 package 선언과 동일하게 디렉토리 구조 생성됨(com/example 폴더 생성)
</code></pre></div>    </div>
  </li>
  <li>클래스 파일 실행 시에는 -cp 옵션으로 클래스 파일 기준 패키지 루트 패키지 디렉토리 지정 가능
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  java -cp out com.example.Main
</code></pre></div>    </div>
  </li>
  <li>패키지를 사용하는 클래스(별도의 package 선언을 한 클래스)를 실행할 때는 항상 패키지명.클래스명 전체를 포함해서 실행해야 함</li>
  <li>패키지 이름은 모두 소문자로 지정해야 하며, 자바의 예약어를 포함할 수 없음</li>
</ul>

<h3 id="62-패키지-import">6.2 패키지 import</h3>
<ul>
  <li>자바에서는 같은 패키지에 있는 클래스들과 java.lang 패키지에 있는 클래스들만 찾을 수 있음. 그외에는 import 패키지명.클래스명을 정의해줘야 함</li>
  <li>import로 불러온 클래스를 따로 컴파일하지 않았어도 해당 클래스를 사용하는 소스 파일을 컴파일하면 (그리고 import한 패키지명과 실제 해당 클래스의 소스 파일이 있는 디렉토리 경로가 일치하면) 해당 클래스를 먼저 컴파일한 후 호출하는 클래스를 컴파일 함</li>
  <li>특정 패키지의 하위 패키지들을 모두 import하고자 할 경우 import c.javapackage.sub.*;사용
    <ul>
      <li>단, 해당 패키지의 바로 하위 패키지만 import 하므로 import c.*를 한다고 해서 c.javapackage의 하위 패키지들까지 import 되진 않음</li>
      <li>폴더 구조상 상위 패키지에 있는 클래스와 하위 패키지에 있는 클래스의 상관관계는 자바 언어 상에는 없으며, 단지 논리적으로 어떤 패키지 하위에 있는지 여부를 따지기 위함임</li>
    </ul>
  </li>
  <li>클래스안에 static 메소드나 변수가 있을 경우 import static을 사용하여 해당 메소드나 변수를 직접 import 할 수 있음
    <ul>
      <li>import static을 사용안 할 경우 해당 클래스를 import하여 클래스명.static_메소드/변수 형태로 사용해야 함</li>
      <li>import 클래스명.*로 해당 static 메소드/변수 import할 때도 마찬가지로 import static 사용</li>
      <li>static 메소드/변수가 직접 import되므로 해당 메소드/변수를 import 한 클래스에 이름이 중복되는 메소드/변수가 있을 수 있는데, 이 경우 자신의 클래스에 있는 변수/메소드가 더 우선됨</li>
    </ul>
  </li>
</ul>

<h3 id="63-자바의-접근-제어자">6.3 자바의 접근 제어자</h3>
<ul>
  <li>public : 누구나 접근 가능</li>
  <li>protected : 같은 패키지 내에 있거나 상속받은 경우에만 접근 가능</li>
  <li>package-private : 아무런 접근 제어자를 적어주지 않은 경우. 같은 패키지 내에 있을 때만 접근 가능</li>
  <li>private : 해당 클래스 내에서만 접근 가능</li>
  <li>구조상으론 public &gt; protected &gt; package-private &gt; private</li>
</ul>

<table>
  <thead>
    <tr>
      <th>지시자</th>
      <th>해당 클래스 안에서</th>
      <th>같은 패키지에서</th>
      <th>상속받은 클래스에서</th>
      <th>import한 클래스 또는 그외에서</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>public</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>protected</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
      <td>X</td>
    </tr>
    <tr>
      <td>package-private</td>
      <td>O</td>
      <td>O</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td>private</td>
      <td>O</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>유의점 : public으로 선언된 클래스가 소스 내에 있다면 그 소스 파일의 이름은 public과 동일해야 함
    <ul>
      <li>소스 파일명과 일치하는 클래스가 있어야 하는 건 아님</li>
    </ul>
  </li>
</ul>

<h2 id="7-상속">7. 상속</h2>

<h3 id="71-상속-예약어와-동작">7.1 상속 예약어와 동작</h3>
<ul>
  <li>extends는 클래스를 상속 받기 위해 사용하는 자바 예약어. 자바에선 하나의 클래스만 상속 가능</li>
  <li>자식 클래스에서는 부모 클래스에 있는 public, protected로 선언된 모든 인스턴스 및 클래스 변수와 메소드 사용 가능. package-private는 패키지가 같을 경우 사용 가능</li>
  <li>상속이란 분류. A는 B의 한 종류이다 (=is kind of)</li>
  <li>자식 클래스 생성자에서 super(매개변수)를 명시적으로 지정하지 않으면 컴파일 시 자동으로 부모클래스의 기본생성자를 호출하는 super()가 추가됨. 따라서 부모 클래스에 기본 생성자가 없으면 에러 발생할 수 있음</li>
  <li>super()는 반드시 자식 클래스의 생성자에서 가장 첫줄에 선언되어야 함</li>
</ul>

<h3 id="72-메소드-오버라이딩">7.2 메소드 오버라이딩</h3>
<ul>
  <li>부모 클래스 메소드와 동일한 시그니처(메소드 이름, 매개변수 타입 및 개수)를 갖는 자식 클래스의 메소드가 존재할 때 성립됨 (다르면 오버로딩)</li>
  <li>부모 클래스의 메소드와 이름이 같으면서 리턴 타입이 다른 메소드는 자식클래스에서 정의할 수 없음
    <ul>
      <li>변수 이름은 같을 수 있으나 권장하지 않음</li>
    </ul>
  </li>
  <li>접근제어자는 부모 클래스 메소드와 다르게 할 수 있으나, 확대되는 것만 가능하고 축소되는 것은 안됨 (public &gt; protected &gt; package-private &gt; private)</li>
</ul>

<h3 id="73-참조-자료형의-형변환">7.3 참조 자료형의 형변환</h3>
<ul>
  <li>기본 자료형에서 데이터 범위가 더 확장되는 경우(int -&gt; long)와 마찬가지로 참조 자료형에서도 자식 클래스 타입을 부모 클래스 타입으로 형 변환시 명시적인 형 변환이 필요 없음 (데이터의 범위가 넓어지는 거지 사용 가능한 변수나 메소드가 많아진다는 걸 의미하진 않음)</li>
  <li>부모 타입 객체를 자식 타입으로 형 변환 시에는 명시적인 타입 지정 필요. 이때, 변환하더라도 실제 들어있는 객체가 자식 타입이 아니면 사용 불가능</li>
  <li>개발 편의상 부모 타입 배열 등에 여러가지 자식 타입의 값을 담아야 하는 경우가 있음</li>
  <li>instanceof 예약어를 사용하면 객체의 실제 타입을 확인할 수 있는데, 부모 타입으로 체크해도 true가 반환됨</li>
  <li>다형성 : 부모 타입 변수에 자식 타입 객체가 들어있어도 실제 호출되는 것은 원래 객체(자식 타입 객체)에 있는 메소드임</li>
</ul>

<h2 id="8-자바-api">8. 자바 API</h2>

<h3 id="81-api">8.1 API</h3>
<ul>
  <li>JDK에는 매우 많은 클래스와 메소드를이 포함되어 있으며, JDK에 포함된 클래스들 외에도 엄청나게 많은 클래스들이 존재함. 이러한 클래스들을 설명하는 API 문서는 HTML로 구성됨</li>
  <li>API 문서는 클래스 및 메소드에 API에 명시되도록 하기 위한 주석을 달고 jdk/bin 디렉터리에 있는 javadoc 명령어만 실행하면 자동으로 생성됨</li>
</ul>

<h3 id="82-api-문서-상세-정보화면">8.2 API 문서 상세 정보화면</h3>
<ul>
  <li>패키지와 클래스 / 인터페이스 이름</li>
  <li>클래스 상속 관계 다이어그램
    <ul>
      <li>해당 클래스가 어떤 클래스들의 상속을 받았는지 간단한 계단식으로 표시</li>
    </ul>
  </li>
  <li>직속 자식 클래스
    <ul>
      <li>현재 보고 있는 클래스를 확장한 클래스들의 목록</li>
    </ul>
  </li>
  <li>알려진 모든 하위 인터페이스 목록
    <ul>
      <li>인터페이스에 대한 문서일 경우 해당 인터페이스 상속받은 인터페이스 목록</li>
    </ul>
  </li>
  <li>알려진 모든 구현한 클래스 목록
    <ul>
      <li>해당 인터페이스를 구현한 클래스들의 목록</li>
    </ul>
  </li>
  <li>구현한 모든 인터페이스 목록
    <ul>
      <li>클래스에서 구현한 모든 인터페이스 목록</li>
    </ul>
  </li>
  <li>클래스 / 인터페이스의 선언 상태
    <ul>
      <li>클래스가 어떤 접근 제어자를 사용했는지, final 클래스인지 등을 확인</li>
    </ul>
  </li>
  <li>클래스 / 인터페이스의 설명
    <ul>
      <li>클래스의 용도, 사용법, 사용 예시 등</li>
      <li>Since : 해당 클래스가 JDK 몇 버전부터 추가되었는지 명시. 클래스만이 아닌 클래스에 선언된 상수 필드나 메소드에도 Since 표시되어 있는 경우가 있음</li>
      <li>See also : 해당 클래스와 관련되어 있는 모든 클래스나 인터페이스, 메소드 등의 링크 제공</li>
    </ul>
  </li>
  <li>내부 클래스 종합
    <ul>
      <li>클래스 안에 내부 클래스가 public하게 선언된 경우 그에 대한 내용 제공</li>
    </ul>
  </li>
  <li>상수 필드 종합
    <ul>
      <li>public static으로 선언한 상수 필드</li>
    </ul>
  </li>
  <li>생성자 종합</li>
  <li>메소드 종합
    <ul>
      <li>클래스에 선언되어 있는 모든 public 및 protected 메소드에 대한 종합 정보</li>
      <li>각 메소드의 리턴 타입, 매개 변수, static 여부, 접근제어자</li>
      <li>javadoc 설명에 따르면 API 문서 생성 시 private도 보이도록 할 수 있음</li>
    </ul>
  </li>
  <li>부모 클래스로부터 상속받은 메소드 들</li>
  <li>상수 필드 상세 설명
    <ul>
      <li>선언된 상수 필드가 어떤 내용을 제공하는지에 대한 상세설명</li>
      <li>Since, See Also가 제공되기도 함</li>
    </ul>
  </li>
  <li>생성자 상세 설명
    <ul>
      <li>해당 생성자를 어떻게 사용하고, 매개 변수, 리턴 값 정보와 이 생성자에서 던지는 예외는 언제 발생하는지 등</li>
      <li>Since, See Also가 제공되기도 함</li>
    </ul>
  </li>
  <li>메소드 상세 설명
    <ul>
      <li>Since, See Also가 제공되기도 함</li>
    </ul>
  </li>
</ul>

<h3 id="83-api-문서-header--footer에-있는-링크">8.3 API 문서 Header / Footer에 있는 링크</h3>
<ul>
  <li>OVERVIEW
    <ul>
      <li>전체 패키지에 대한 설명 화면. Java SE 모듈과 JDK 모듈과 그 외 모듈로 분하여 정리됨</li>
    </ul>
  </li>
  <li>MODULE
    <ul>
      <li>패키지 묶음 설명화면. Java SE 모듈과 JDK 모듈과 그 외 모듈 등</li>
    </ul>
  </li>
  <li>PACKAGE
    <ul>
      <li>현재 보고 있는 클래스가 속한 패키지의 모든 인터페이스, 클래스, 예외 등 간단한 설명</li>
    </ul>
  </li>
  <li>CLASS
    <ul>
      <li>USE 페이지에서 클래스 상세 설명으로 넘어가는 링크 클릭하여 이동</li>
    </ul>
  </li>
  <li>USE
    <ul>
      <li>현재 보고 있는 패키지, 클래스, 인터페이스 등을 사용(매개변수나 멤버 변수 및 기타 등등)하는 모든 목록 나열</li>
      <li>처음 보는 클래스가 어디 사용되는지 확인하기 좋음</li>
    </ul>
  </li>
  <li>TREE
    <ul>
      <li>클래스가 속한 패키지에 있는 모든 클래스들의 상속 관계를 Tree 형태로 제공</li>
    </ul>
  </li>
  <li>DEPRECATED
    <ul>
      <li>JDK에 포함된 클래스/메소드 중 deprecated 클래스나 메소드 목록</li>
    </ul>
  </li>
  <li>INDEX
    <ul>
      <li>A부터 Z까지의 알파벳 클릭하여 각 알파벳에 해당하는 클래스, 인터페이스, 메소드, static 변수 등의 색인을 오름차순으로 제공</li>
    </ul>
  </li>
  <li>HELP
    <ul>
      <li>API 문서에 대한 간단 설명</li>
    </ul>
  </li>
</ul>

<h2 id="9-javalangobject">9. java.lang.Object</h2>

<h3 id="91-object-클래스의-메소드">9.1 Object 클래스의 메소드</h3>
<ul>
  <li>자바에서는 기본적으로 아무런 상속을 받지 않을 경우 java.lang.Object 클래스를 확장함. 따라서 Object 클래스의 메소드는 모든 클래스에서 사용가능</li>
  <li>주요 메소드
    <ul>
      <li>toString()
        <ul>
          <li>객체가 System.out.println() 메소드에 매개 변수로 들어가거나 객체에 대하여 더하기 연산 할때 자동 호출됨</li>
          <li>String을 제외한 참조 자료형에 더하기 연산을 수행하면 자동으로 toString() 메소드가 호출되어 그 리턴 값이 더해지게 됨</li>
        </ul>
      </li>
      <li>equals()
        <ul>
          <li>== 연산자는 참조 자료형의 경우 단순 주소값을 비교하므로 equals() 메소드를 오버라이딩 하여 사용. 오버라이딩 하지 않으면 equals() 메소드에서는 hashCode() 메소드 리턴 값인 주소값으로 비교함</li>
          <li>만약 어떤 두 개의 객체가 서로 동일하다면 hashCode() 값 역시 무조건 동일해야 하므로 equals() 메소드를 오버라이딩 시 hashCode()도 같이 해야함</li>
        </ul>
      </li>
      <li>hashcode()
        <ul>
          <li>기본적으로 객체의 메모리 주소를 16진수로 반환</li>
          <li>자바 API 문서에는 equals(), hashcode() 오버라이딩 시 지켜야 할 규칙을 명시하고 있는데, 이러한 제약들 때문에 해당 메소드들을 직접 작성하는건 권장하지 않으며 개발 툴에서 자동 생성해주는 기능을 사용하는 것이 좋음</li>
        </ul>
      </li>
      <li>wait(), notify(), notifyAll()
        <ul>
          <li>스레드 처리 시 사용</li>
        </ul>
      </li>
      <li>그 밖에 객체의 복사본을 반환하는 clone(), 더 이상 쓸모없어진 객체를 정리하기 위해 GC가 호출하는 finalize(), 객체가 어떤 클래스의 인스턴스인지에 대한 메타데이터 객체를 반환하는 getClass() 등</li>
    </ul>
  </li>
</ul>

<h2 id="10-인터페이스와-추상클래스-enum">10. 인터페이스와 추상클래스, enum</h2>

<h3 id="101-인터페이스">10.1 인터페이스</h3>
<ul>
  <li>개발 절차의 설계 단계에서 인터페이스를 만들어두면 개발 단계에서 메소드의 이름, 매개변수에 대해 일일이 고민하지 않을 수 있음. 실제 코드는 만들지 않더라도 어떤 메소드들이 있어야 하는지 정의할 때 사용</li>
  <li>implements 라는 예약어 사용. 끝에 s가 붙는 것은 클래스 자체가 3인칭 단수이기 때문</li>
  <li>implements 뒤에는 여러 인터페이스가 올 수 있음</li>
  <li>abstract 클래스가 아닌 인터페이스를 구현하는 클래스에서는 반드시 인터페이스에 정의된 메소드들을 구현해야 함</li>
</ul>

<h3 id="102-추상클래스">10.2 추상클래스</h3>
<ul>
  <li>abstract 클래스는 abstract 클래스를 구현해 놓은 클래스를 통해 초기화 및 실행 가능</li>
  <li>abstract로 선언한 메소드는 반드시 abstract 클래스 안에 있어야 함</li>
  <li>인터페이스와 달리 구현되어 있는 메소드가 있을 수 있으며 static이나 final 메소드도 가능</li>
  <li>abstract 클래스는 상속과 동일하게 extends 예약어로 구현. 인터페이스와 유사하게 구현하는 클래스에서는 상속받은 abstract 메소드를 반드시 구현해야 함</li>
  <li>
    <p>설계 단계에서 인터페이스 선언 시 어떤 메소드는 미리 만들어 놓아도 문제가 없는 경우 사용</p>

    <table>
      <thead>
        <tr>
          <th>구분</th>
          <th>인터페이스</th>
          <th>abstract 클래스</th>
          <th>클래스</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>선언 시 사용하는 예약어</td>
          <td>interface</td>
          <td>abstract class</td>
          <td>class</td>
        </tr>
        <tr>
          <td>구현 안 된 메소드 포함 가능 여부</td>
          <td>가능(필수)</td>
          <td>가능</td>
          <td>불가</td>
        </tr>
        <tr>
          <td>구현된 메소드 포함 가능 여부</td>
          <td>불가</td>
          <td>가능</td>
          <td>가능(필수)</td>
        </tr>
        <tr>
          <td>static 메소드 선언 가능 여부</td>
          <td>불가</td>
          <td>가능</td>
          <td>가능</td>
        </tr>
        <tr>
          <td>final 메소드 선언 가능 여부</td>
          <td>불가</td>
          <td>가능</td>
          <td>가능</td>
        </tr>
        <tr>
          <td>상속 가능</td>
          <td>불가</td>
          <td>가능</td>
          <td>가능</td>
        </tr>
        <tr>
          <td>구현 가능</td>
          <td>가능</td>
          <td>불가</td>
          <td>불가</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="103-final">10.3 final</h3>
<ul>
  <li>클래스에 선언할 경우 해당 클래스 상속 불가</li>
  <li>메소드에 선언할 경우 해당 메소드 오버라이딩 불가</li>
  <li>변수에 선언할 경우 더 이상 값을 바꿀 수 없음. 따라서 인스턴스 변수나 static 변수, 참조 자료형의 경우 여러곳에서 사용될 수 있으므로 선언과 함께 값을 지정해야 함</li>
  <li>매개 변수나 지역 변수가 final일 경우는 반드시 선언할 때 초기화할 필요는 없음</li>
  <li>참조 자료형 클래스가 final이라고 해서 그 안에 있는 인스턴스 변수나 static 변수가 final이 되진 않음. 따라서 해당 값들은 변경 가능</li>
</ul>

<h3 id="104-enum">10.4 enum</h3>
<ul>
  <li>상수의 집합으로, 타입이자 클래스의 일종</li>
  <li>enum 클래스에 있는 상수들은 별도로 타입이나 값을 지정할 필요가 없음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public enum OverTimeValues {
      THREE_HOUR,
      FIVE_HOUR,
      WEEKEND_FOUR_HOUR,
      WEEKEND_EIGHT_HOUR;

      // 컴파일러가 기본 생성자 자동 생성
      private OverTimeValues() { }
  }

  public class OverTimeManager {
      public getOverTimeAmount(OverTimeValues value){
          int amount = 0;
          Sytstem.out.println(value);
          switch(value){
              case THREE_HOUR:
                  amount = 18000;
                  break;
              case FIVE_HOUR:
                  amount = 30000;
                  break;
              case WEEKEND_FOUR_HOUR:
                  amount = 40000;
                  break;
              case WEEKEND_EIGHT_HOUR:
                  amount = 60000;
                  break;
          }
          return amount;
      }
  }

  public class OverTimeManager {
      public static void main(String args[]){
          OverTimeManager manager = new OverTimeManager();
          int myAmount = manager.getOverTimeAmount(OverTimeValues.THREE_HOUR); // enum 클래스이름.상수이름 지정만으로 객체 생성 완료
          System.out.println(value2.getAmount);
      }
  }

  // 출력 결과
    
  // THREE_HOUR
  // 18000
</code></pre></div>    </div>
  </li>
  <li>필요할 경우 enum 상수 값을 처음부터 지정할 수 있음</li>
  <li>enum 클래스의 각 상수는 해당 클래스의 인스턴스 변수가 아닌, 인스턴스 자체로 간주하면 됨. 따라서 해당 클래스에 상수가 아닌 인스턴스 변수가 늘어나면 각 상수가 가지는 값의 개수도 늘어남</li>
  <li>enum 클래스는 생성자는 package-private나 private로 만들 수 있으나 package-private로 선언해도 사실상 private로 동작함. 또한 생성자를 통해 객체를 생성할 수는 없으며, enum 클래스 내부에서 각 상수의 값을 선언할 때에만 이 생성자를 사용할 수 있음</li>
  <li>메소드는 보통 클래스와 동일하게 정의하여 사용할 수 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public enum OverTimeValues2 {
      THREE_HOUR(18000),
      FIVE_HOUR(30000),
      WEEKEND_FOUR_HOUR(40000),
      WEEKEND_EIGHT_HOUR(60000);

      private final int amount;

      OverTimeValues2(int mount){
          this.amount = amount;
      }
      public int getAmount(){
          return amount;
      }
  }

  public class OverTimeManager2 {
      public static void main(String args[]){
          OverTimeValues2 value2 = OverTimeValues2.FIVE_HOUR;
          System.out.println(value2);
          System.out.println(value2.getAmount);
      }
  }

  // 출력결과

  // FIVE_HOUR
  // 30000
</code></pre></div>    </div>
  </li>
  <li>
    <p>enum 클래스는 무조건 java.lang.Enum 클래스의 상속을 받음</p>

    <table>
      <thead>
        <tr>
          <th>접근 제어자</th>
          <th>메소드</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>protected</td>
          <td>Enum(String name, int ordinal)</td>
          <td>컴파일러에서 자동 호출되도록 해둔 생성자</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>name은 enum 상수의 이름이며 ordinal은 상수가 선언된 순서대로 0부터 증가</li>
  <li>Enum 클래스의 부모 클래스는 Object 클래스이나, Enum 클래스에서 Object 클래스 중 4개의 메소드(clone(), finalize(), hashCode(), equals())를 오버라이딩하지 못하도록 막아 toString()만 오버라이딩 가능. toString()은 기본적으로 상수 이름을 출력해줌</li>
  <li>Enum 클래스에서 선언되어 있는 메소드 중에서는 compareTo(E e)가 있는데, enum 타입과 순서 차이(ordinal)를 반환함. 같은 상수라면 0을 반환</li>
  <li>그 외에 API 문서에 없는 특수한 메소드로 values()라는 static 메소드가 있는데, enum 클래스에 선언되어 있는 모든 상수를 배열로 반환. enum 객체에 어떤 상수가 어떤 순서로 선언되었는지 확인하기 좋음</li>
</ul>

<h2 id="11-예외">11. 예외</h2>

<h3 id="111-try-catch-문">11.1 try-catch 문</h3>
<ul>
  <li>try 블록 내에서 선언한 변수는 catch에서 인식되지 않음. try 앞에 미리 선언해놔야 함</li>
  <li>finally 블록은 try-catch 블록 이후, 예외 발생 여부와 상관 없이 항상 실행됨</li>
  <li>catch 블록을 여러개 정의하여 서로 다른 타입의 예외를 캐치하려할 경우 앞 catch 블록에서 캐치된 경우 뒤로는 전달이 되지 않음. 따라서 catch문의 예외는 체크해야 할 순서대로 나열해야 함</li>
  <li>모든 예외 클래스의 부모 클래스는 java.lang.Exception으로, Exception 클래스는 모든 예외를 캐치하므로 맨 밑에 사용해 예외들이 빠져나가지 못하도록 묶어두는 역할을 하는게 좋음. 캐치되지 않아 예외가 발생할 경우 해당 스레드는 끝남</li>
</ul>

<h3 id="112-예외의-종류-3가지">11.2 예외의 종류 3가지</h3>
<p><img src="/assets/images/자바예외.jpeg" alt="예외 클래스 상관 관계도" /></p>
<ul>
  <li>error
    <ul>
      <li>자바 프로그램 밖에서 발생한 예외 (서버 디스크 고장, 메인보드 고장 등으로 자바 프로그램이 동작 못하는 경우)</li>
      <li>프로세스에 영향을 준다는 점에서 스레드에 영향을 주는 Exception과 구분됨</li>
    </ul>
  </li>
  <li>checked exception (Other Exception)
    <ul>
      <li>Exception을 확장한 예외들</li>
      <li>NullPointerException, NumberFormatException, ClassCastException.. 및 기타 등등</li>
    </ul>
  </li>
  <li>runtime exception
    <ul>
      <li>RuntimeException을 확장한 예외들</li>
      <li>컴파일 시점이 아닌 실행 시점에 발생 가능. 따라서 try-catch로 묶지 않아도 컴파일시에 예외가 발생하지는 않으나 묶어두는 편이 좋음</li>
      <li>IOException, SQLException.. 및 기타 등등</li>
    </ul>
  </li>
</ul>

<h3 id="113-javalangthrowable">11.3 java.lang.Throwable</h3>
<ul>
  <li>Throwable의 생성자
    <ul>
      <li>Throwable()</li>
      <li>Throwable(String Message)</li>
      <li>Throwable(String Message, Throwable casue)</li>
      <li>Throwable(Throwable casue)</li>
    </ul>
  </li>
  <li>Throwable 클래스에 선언되어 있고 Exception 클래스에서 오버라이딩 한 주요 메소드
    <ul>
      <li>getMessage()
        <ul>
          <li>예외 메시지를 String 형태로 제공받음. 어떤 예외가 발생했는지에 대한 예외 메시지를 활용하여 사용자에게 별도의 예외 메시지를 보여주기 위해 오버라이딩 가능</li>
        </ul>
      </li>
      <li>toString()
        <ul>
          <li>getMessage()와 비슷하나 약간 더 자세하게, 예외 클래스 이름도 같이 제공받음</li>
        </ul>
      </li>
      <li>printStackTrace()
        <ul>
          <li>첫 줄에 예외 메시지를, 두 번째 줄부터는 예외가 발생하게 된 메소드들의 스택 트레이스 출력</li>
          <li>printStackTrace &gt; toString &gt; getMessage 순으로 자세함</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="114-throw-throws">11.4 throw, throws</h3>
<ul>
  <li>예외를 직접 던지려면 throw 예외객체; 실행. catch문에 해당 예외를 잡아줄 객체나 부모 객체가 정의되어있지 않을 경우 해당 예외가 발생한 메소드 밖으로 던져짐</li>
  <li>이때 예외를 던지는 메소드 선언 옆에는 throws + 예외 클래스가 붙어야 함. 해당 메소드를 호출한 메소드로 예외 처리를 위임한다는 의미. 해당 메소드에선 try-catch문이 없어도 되며 해당 메소드를 호출한 메소드에서 호출문을 try-catch문으로 감싸주거나 예외를 다시 그 밖으로 위임할 수 있음</li>
  <li>Exception을 던질 가능성이 있는 코드가 try-catch나 throws가 강제되는 건 checked exception에 한정됨</li>
  <li>가장 좋은 방법은 throws하는 메소드를 호출하는 메소드에서 try-catch로 처리하는 것. 예외가 시작된 메소드에서는 어떻게 처리해야할지 알 수 없는 경우가 있으니 책임이 있는 곳(메소드)에서 처리해야 함</li>
  <li>implements 처럼 throws 뒤에도 여러 예외 클래스가 올 수 있음</li>
</ul>

<h3 id="115-사용자-정의-exception">11.5 사용자 정의 Exception</h3>
<ul>
  <li>Throwable이나 그 자식 클래스의 상속을 받아야 함</li>
  <li>try-catch로 묶어줄 필요가 있을 경우에만 Exception클래스 확장, 실행 시 예외를 처리할 수 있는 경우에는 RuntimeException 클래스 확장</li>
</ul>

<h2 id="12-string">12. String</h2>

<h3 id="121-string-클래스-선언">12.1 String 클래스 선언</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final calss String extends Object
     implements Serializable, Comparable&lt;String&gt;, CharSequence
</code></pre></div></div>
<ul>
  <li>Serializable 인터페이스 : 구현해야 하는 메소드가 하나도 없음. 구현 시 해당 객체를 파일로 저장하거나 다른 서버에 전송 가능한 상태가 됨</li>
  <li>Comparable 인터페이스 : compareTo() 메소드를 상속받아 구현함. 매개변수로 받은 객체를 비교하여 같으면 0, 알파벳 순으로(정확히는 유니코드 값에 따라) 앞이면 -1, 뒤이면 1 반환. 알파벳 순서만큼 그 숫자값이 커짐</li>
  <li>CharSequence 인터페이스 : 해당 클래스가 문자열을 다루기 위한 클래스라는 것을 명시적으로 나타내는데 사용</li>
</ul>

<h3 id="122-string---바이트-배열-변환">12.2 String &lt;-&gt; 바이트 배열 변환</h3>
<ul>
  <li>String 클래스에는 다양한 생성자가 있지만 아래 2개가 가장 많이 사용됨
    <ul>
      <li>String(byte[] bytes) : 현재 JVM이 실행되는 환경의 기본 문자 인코딩 방식의 캐릭터 셋을 사용하여 제공된 byte 배열을 디코딩한 String 객체를 생성</li>
      <li>String(byte[] bytes, String charsetName) : 지정된 캐릭터 셋을 사용하여 제공된 byte 배열을 디코딩한 String 객체를 생성</li>
      <li>생성자의 매개 변수로 받는 byte 배열은 String 클래스의 아래의 메소드로 생성됨
        <ul>
          <li>byte[] getBytes() : 기본 캐릭터 셋의 바이트 배열 생성</li>
          <li>byte[] getBytes(Charset charset) : 지정한 캐릭터 셋으로 바이트 배열 생성</li>
          <li>byte[] getBytes(String charsetName) : 지정한 캐릭터 셋 이름으로 바이트 배열 생성</li>
        </ul>
      </li>
      <li>java.nio.Charset 클래스 API에는 표준 캐릭터 셋이 정해져 있음.
        <ul>
          <li>UTF-8, UTF-16, EUC-KR 및 기타 등등</li>
          <li>한글을 처리하기 위해 자바에서 많이 사용하는 캐릭터 셋은 UTF-16</li>
        </ul>
      </li>
      <li>문자가 깨지는 것을 방지하려면 문자열 &lt;-&gt; 바이트 배열 전환 시 동일한 캐릭터 셋을 사용해야 함</li>
      <li>한글을 byte 배열로 만들 때 어떤 캐릭터 셋을 쓰느냐에 따라서 배열의 크기가 달라짐. EUC-KR은 두글자에 4바이트, UTF-16은 6바이트</li>
      <li>String 타입의 캐릭터 셋을 매개변수로 받는 아래의 두 생성자/메소드는 UnsupportedEncodingException 체크 예외를 발생시킬 수 있음. 따라서 반드시 try-catch로 감싸줘야 함
        <ul>
          <li>String(byte[] bytes, String charsetName)</li>
          <li>byte[] getBytes(String charsetName)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="123-string의-다양한-메소드">12.3 String의 다양한 메소드</h3>

<h4 id="1231-문자열의-길이를-확인하는-메소드">12.3.1 문자열의 길이를 확인하는 메소드</h4>
<ul>
  <li>length() : 배열의 크기를 확인하는 .length와 달리 괄호가 붙음. 배열은 객체이나 메소드는 없는 특수한 객체</li>
</ul>

<h4 id="1232-문자열이-같은지-비교하는-메소드">12.3.2 문자열이 같은지 비교하는 메소드</h4>
<ul>
  <li>메소드
    <ul>
      <li>boolean equals(Object anObject)</li>
      <li>boolean equalsIgnoreCase(String anotherStr)</li>
      <li>int compareTo(String anotherStr)</li>
      <li>int compareToIgnoreCase(String str)</li>
      <li>boolean contentEquals(CharSequence cs)</li>
      <li>boolean contentEquals(StringBuffer sb)</li>
    </ul>
  </li>
  <li>모두 매개변수로 넘어온 값과 String 객체가 같은지를 비교하는 메소드로 IgnoreCase가 붙은 메소드들은 대소문자 구분을 할지 안할지 여부만 다름</li>
  <li>String 클래스의 equals() 메소드는 오버라이딩 되어 주소값이 아닌 value를 비교함</li>
  <li>자바에는 객체들을 재사용하기 위해 Constant Pool이라는 것이 만들어져 있는데, String의 경우 동일한 값을 갖는 객체가 있으면 이미 만든 객체를 재사용함. 따라서 아래의 text와 text2는 동일한 객체가 됨
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String text = "Check value";
  String text2 = "Check value";
  if(text == text2){
      ...
  }
  if(text.equals("Check value")){
      ...
  }
  //두 if문 모두 true가 됨
</code></pre></div>    </div>
  </li>
  <li>같은 문자열 값이어도 Constant Pool 활용하지 않고 별도의 객체를 생성하고 싶으면
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String text = "Check value";
  String text2 = new String("Check value");
</code></pre></div>    </div>
  </li>
  <li>comepareTo() 메소드 설명은 앞의 12.1참고, contentEquals는 2권에서</li>
</ul>

<h4 id="1233-특정-조건에-맞는-문자열이-있는지를-확인하는-메소드">12.3.3 특정 조건에 맞는 문자열이 있는지를 확인하는 메소드</h4>
<ul>
  <li>boolean startsWith(String prefix)</li>
  <li>boolean startsWith(String prefix, int toffset)</li>
  <li>boolean endsWith(String suffix)</li>
  <li>boolean contains(CharSequence s)</li>
  <li>boolean matches(String regex) : contains()와 유사하나 매개변수가 정규표현식이어야 함</li>
  <li>boolean regionMatches(int toffset, String other, int ooffset, int len)</li>
  <li>boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)
    <ul>
      <li>ignoreCase : true일 경우 대소문자 구분없이 비교</li>
      <li>toffset : 비교 대상 문자열의 확인 시작 위치 지정</li>
      <li>other : 존재하는지를 확인할 문자열</li>
      <li>ooffset : other 객체의 확인 시작 위치 지정</li>
      <li>len : 비교할 char의 개수 지정 (비교 대상 문자열의 확인 시작 위치, other 객체의 확인 시작 위치로부터 몇개 문자가 일치하는지 확인할지)</li>
      <li>매개 변수의 값이 잘못된 경우 무조건 false 반환됨</li>
    </ul>
  </li>
</ul>

<h4 id="1234-string-내에서-위치를-찾는-메소드">12.3.4 String 내에서 위치를 찾는 메소드</h4>
<ul>
  <li>메소드
    <ul>
      <li>int indexOf(int ch)</li>
      <li>int indexOf(int ch, int fromIndex)</li>
      <li>int indexOf(String str)</li>
      <li>int indexOf(String str, int fromIndex)</li>
      <li>int lastIndexOf(int ch)</li>
      <li>int lastIndexOf(int ch, int fromIndex)</li>
      <li>int lastIndexOf(String str)</li>
      <li>int lastIndexOf(String str, int fromIndex)</li>
    </ul>
  </li>
  <li>indexOf()는 가장 앞에서부터, lastIndexOf()는 뒤에서부터 문자열이나 char을 찾음</li>
  <li>int ch는 char을 의미함. char은 정수형이기 때문에 매개변수로 char 넘기면 자동으로 int로 형변환 됨</li>
  <li>fromIndex는 문자열의 가장 왼쪽 기준 몇번째 자리부터 값을 확인할지에 대한 값. IndexOf()에서는 해당 위치로부터 오른쪽으로, lastIndexOf()에서는 왼쪽으로 탐색함</li>
  <li>해당 char이나 문자열이 없으면 -1 반환</li>
</ul>

<h4 id="1235-string-값의-일부를-추출하기-위한-메소드">12.3.5 String 값의 일부를 추출하기 위한 메소드</h4>
<ul>
  <li>java 8까지 String 클래스에선 String 문자열의 값을 char 배열로 저장해왔으나, 성능과 메모리 활용성을 고려하여 java 9부터는 byte 배열로 내부적으로 저장</li>
  <li>char 단위의 값을 추출하거나 char 배열 &lt;-&gt; String 변환 메소드
    <ul>
      <li>char charAt(int index) : 특정 위치의 char 값을 반환</li>
      <li>static String copyValueOf(char[] data) : char 배열 -&gt; 문자열</li>
      <li>char[] toCharArray() : 문자열 -&gt; char 배열</li>
    </ul>
  </li>
  <li>문자열의 일부 값을 잘라내는 메소드
    <ul>
      <li>String substring(int beginIndex) : beginIndex부터 끝까지 문자열 잘라 반환</li>
      <li>String substring(int beginIndex, int endIndex) : beginIndex부터 endIndex까지 문자열 잘라 반환</li>
      <li>CharSequence subSequence(int beginIndex, int endIndex) : beginIndex부터 endIndex까지 문자열을 잘라 반환</li>
    </ul>
  </li>
  <li>문자열을 여러 개의 String 배열로 나누는 split 메소드
    <ul>
      <li>메소드
        <ul>
          <li>String[] split(String regex) : 정규 표현식에 맞춰 문자열을 잘라 String 배열로 반환</li>
          <li>String[] split(String regex, int limit) : 위와 유사하나 반환하는 String 배열 크기에 대한 limit가 있음</li>
        </ul>
      </li>
      <li>정규표현식이나 특정 알파벳, 기호 하나로 문자열을 나눌경우 split()를, 특정 String으로 문자열을 나눌경우 StringTokenizer 클래스를 이용하는 편이 용이함</li>
    </ul>
  </li>
</ul>

<h4 id="1236-string값을-바꾸는-메소드">12.3.6 String값을 바꾸는 메소드</h4>
<ul>
  <li>문자열을 합치거나 공백을 제거하는 메소드
    <ul>
      <li>String concat(String str) : 자바에선 +로 문자열을 더할 수 있어 잘 사용 안됨</li>
      <li>String trim() : 문자열의 맨앞과 맨뒤에 있는 공백들을 제거. 문자열에 공백을 제외한 char값이 하나 이상 있는지 확인하는데 사용할 수 있음
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String text = " a ";
  if(text!=null &amp;&amp; text.trim().length() &gt; 0){
      System.out.println("OK");
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>내용을 교체하는 메소드
    <ul>
      <li>String replace(char oldChar, char newChar) : 문자열에서 oldChar 문자를 newChar 문자로 모두 치환</li>
      <li>String replace(CharSequence target, CharSequence replacement) : 문자열에서 target 문자열을 replacement 문자열로 모두 치환</li>
      <li>String replaceAll(String regex, String replacement) : 정규 표현식에 매칭되는 모든 부분을 replacement로 치환</li>
      <li>String replaceFirst(String regex, String replacement) : 정규 표현식에 매칭되는 첫번째 내용을 replacement로 치환</li>
    </ul>
  </li>
  <li>특정 형식에 맞춰 값을 치환하는 메소드
    <ul>
      <li>메소드
        <ul>
          <li>static String format(String format, Object… args)</li>
          <li>static String format(Locale 1, String format, Object… args) : 지정한 Locale 지역 규칙에 따라 포맷팅</li>
        </ul>
      </li>
      <li>%s는 String, %d는 정수형, %f는 소수점이 있는 숫자, %%는 % 의미
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String name = "민형";
  int age = 25;

  String result = String.format("이름: %s, 나이: %d", name, age);
  System.out.println(result);
  // 출력: 이름: 민형, 나이: 25
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>대소문자를 바꾸는 메소드
    <ul>
      <li>toLowerCase()</li>
      <li>toLowerCase(Locale locale)</li>
      <li>toUpperCase()</li>
      <li>toUpperCase(Locale locale)</li>
    </ul>
  </li>
  <li>기본 자료형을 문자열로 변환하는 메소드
    <ul>
      <li>메소드
        <ul>
          <li>static String valueOf(boolean b) : boolean 값을 “true” 또는 “false” 문자열로 변환</li>
          <li>static String valueOf(char c)</li>
          <li>static String valueOf(char[] data)</li>
          <li>static String valueOf(char[] data, int offset, int count)</li>
          <li>static String valueOf(double d)</li>
          <li>static String valueOf(float f)</li>
          <li>static String valueOf(int i)</li>
          <li>static String valueOf(long l)</li>
          <li>static String valueOf(Object obj) : obj 객체의 toString() 결과를 반환. obj 값이 null인 경우에는 NullPointeraexcerption 없이 null을 반환함</li>
        </ul>
      </li>
      <li>별도의 문자열과 합치는 경우에는 valueOf() 사용할 필요없이 자동으로 문자열로 변환됨
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  byte b = 1;
  String byte1 = String.valueOf(b);
  String byte2 = b + ""
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="1237-사용해서는-안되는-메소드">12.3.7 사용해서는 안되는 메소드</h4>
<ul>
  <li>
    <p>String 클래스에서 관리하는 문자열 풀에 있는 값을 재사용하므로 text, text2는 동일한 객체가 되고, text3은 새로운 객체를 생성</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  String text = "Check value";
  String text2 = "Check value";
  String text3 = new String("Check value");
</code></pre></div>    </div>
  </li>
  <li>String 클래스에는 자바가 아닌 C로 구현된 intern()이라는 메소드가 있음.</li>
  <li>intern()을 사용하면 new String(String)으로 생성한 문자열 객체라도 풀에 해당 값이 있으면 풀에 있는 값을 참조하는 객체 반환. 만약 동일한 문자열이 존재하지 않으면 풀에 해당 값을 추가. 따라서 아래를 수행한 뒤의 문자열은 equals()가 아닌 == 으로 값이 동일한지 비교할 수 있음
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  text3 = text3.intern();
</code></pre></div>    </div>
  </li>
  <li>문제는 새로운 문자열을 쉴새없이 만드는 프로그램에서 intern() 메소드를 사용하여 억지로 문자열 풀에 값을 할당하게 하면 저장영역의 한계로 별도의 메모리 청소 단계를 거치게 되어 전체 자바 시스템 성능에 악영향을 줌
    <ul>
      <li>리터럴만 풀에 저장되기 때문에 아래의 경우 힙 영역에만 객체가 새로 생성되지만
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  for (int i = 0; i &lt; 1000000; i++) {
      String s = "Num" + i;   //i가 변수이므로 해당값은 힙에 저장됨
  }
</code></pre></div>        </div>
      </li>
      <li>아래의 경우에는 강제로 풀에 쌓이게 되어 GC의 부담이 커짐
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  for (int i = 0; i &lt; 1000000; i++) {
      String s = ("Num" + i).intern();
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h3 id="124-stringbuffer와-stringbuilder">12.4 StringBuffer와 StringBuilder</h3>
<ul>
  <li>String은 immutable(불변의) 객체이므로 한 번 만들어지면 더이상 값을 바꿀수 없음. 문자열을 더하면 새로운 문자열 객체가 생성되고 기존의 객체는 GC의 대상이 됨</li>
  <li>이러한 쓰레기를 계속 만드는 단점을 보안하기 위해 StringBuffer와 StringBuilder 클래스 제공</li>
  <li>StringBuffer와 StringBuilder는 +가 아닌 append() 메소드로 문자열을 더함. 이 때 새로운 객체를 생성하지 않으므로 여러 String을 더하는 연산이 있을 경우 해당 클래스를 적절하게 선택하여 사용하는 것이 좋음</li>
  <li>append()는 매개변수로 모든 기본 자료형과 참조 자료형을 포함하므로 어떤 값이라도 매개변수로 넣을 수 있음. append()의 반환 타입은 StringBuffer/StringBuilder이므로 연달아 사용 가능</li>
  <li>두 클래스의 메소드는 동일하나 StringBuffer는 Thread safe하고 StringBuilder는 그렇지 않음. 대신 StringBuilder가 속도는 더 빠름</li>
  <li>JDK 5 이상에서는 String 더하기 연산을 할 경우 컴파일 시 자동으로 해당 연산을 StringBuilder로 변환하나, for 루프와 같이 반복 연산을 할 경우에는 자동으로 변환을 해주지 않으므로 수동으로 해야함</li>
  <li>String, StringBuilder, StringBuffer 클래스는 모두 CharSequence 인터페이스를 구현하므로 이 셋 중 하나의 클래스를 사용하여 매개 변수로 받는 작업을 할 때 String이나 StringBuilder 타입으로 받기보다 CharSequence 타입으로 받는 편이 좋음</li>
  <li>하나의 메소드 내에서 문자열을 생성하여 더할 경우 StringBuilder를 사용해도 문제없으나, 어떤 클래스에 문자열을 생성하여 더하기 위한 인스턴스 변수가 선언되었고 여러 스레드에서 이 변수를 동시에 접근하는 일이 있다면 반드시 StringBuffer를 사용해야 함</li>
</ul>

<h2 id="13-내부-클래스">13. 내부 클래스</h2>

<h3 id="131-내부-클래스-종류">13.1 내부 클래스 종류</h3>
<ul>
  <li>static 여부에 따라 Static nested 클래스와 내부 클래스로 구분됨</li>
  <li>내부 클래스는 다시 (로컬) 내부 클래스와 익명 클래스로 나뉨</li>
  <li>내부 클래스의 용도
    <ul>
      <li>한 곳에서만 사용되는 클래스를 논리적으로 묶어서 처리해야 할 때</li>
      <li>캡슐화가 필요할 때 (내부 구현 은닉)</li>
      <li>소스의 가독성과 유지보성 향상</li>
    </ul>
  </li>
</ul>

<h3 id="132-static-nested-클래스">13.2 Static nested 클래스</h3>
<ul>
  <li>일반 내부 클래스와 달리 감싸고 있는 클래스의 static 변수만 참조할 수 있음</li>
  <li>반대로 감싸고 있는 클래스에서 내부 클래스의 인스턴스 변수에 접근하려면 static 여부 상관없이 내부 클래스의 객체를 생성해서
그 객체를 통해서만 가능
    <ul>
      <li>outer를 만든다고 해서 자동으로 inner가 생성되지는 않으며, outer.new Inner()라고 명시적으로 생성해야 Inner 객체가 생성됨. 따라서 Inner 클래스는 문법적으로 내부에 포함되어 있을뿐, 객체 레벨에선 독립적임</li>
    </ul>
  </li>
  <li>Static nested 클래스를 초기화하려면
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class OuterOfStatic {
      static class StaticNested { //Static nested 클래스
          int value = 200;
            
          public int setValue(int value){
              this.value = value;
          }
      }
  }

  public class NestedSample {
      public static void main(String[] args){
          NestedSample sample = new NestedSample();
          sample.makeStaticNestedObject();
      }
      public void makeStaticNestedObject(){
          OuterOfStatic.StaticNested staticNested = new OuterOfStatic.StaticNested();
          staticNested.setValue(3);
      }
  }
</code></pre></div>    </div>
  </li>
  <li>Outer 클래스와 논리적으로 묶여 있지만, 인스턴스에 종속될 필요는 없는 클래스가 필요할 때 사용. Outer 객체 없이도 생성 가능함</li>
  <li>School, University 클래스가 있을 때 Student 클래스를 독립적으로 생성하는 대신 각 클래스 안에 static으로 생성하면 어느쪽의 Student인지 용도가 보다 명확해짐</li>
</ul>

<h3 id="133-내부클래스와-익명클래스">13.3 내부클래스와 익명클래스</h3>
<ul>
  <li>static 하지 않은 일반 내부클래스는 outer 객체 생성이 먼저 필요함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class InnerSample {
      public static void main(String[] args) {
          // Outer 객체 먼저 생성
          InnerSample outer = new InnerSample();

          // Inner 객체 생성 (Outer 인스턴스를 통해)
          Inner inner = outer.new Inner();
          inner.setValue(5);
          inner.printValue();
      }
  }
</code></pre></div>    </div>
  </li>
  <li>하나의 클래스에서 어떤 공통적인 작업을 수행하는 클래스가 필요한데 다른 클래스에서는 그 클래스가 전혀 필요 없을 때 사용</li>
  <li>GUI(사용자 화면용 애플리케이션) 관련 프로그램 개발 시 가장 많이 사용. Swing, Applet, SWT, GWT, 안드로이드 등</li>
  <li>GUI에서 내부클래스들은 리스너를 처리할 때(어떤 버튼이 눌렸을 때) 해야 하는 작업을 정의할 때 많이 쓰임. 버튼마다 작업이 보통 상이하므로 별도로 클래스를 만드는 대신 내부클래스를 만들며, 일회성일 경우 더 간단하게 익명클래스를 사용함
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  public class MagicButton {
      private EventListener listener;

      public void setListener(EventListener listener) {
          this.listener = listener;
      }
      public void onClickProcess(){
          if(listener != null){
              listener.onClick();
          }
      }
  }

  MagicButton button = new MagicButton();
  button.setListener(new EventListener() {   //익명클래스
      public void onClick(View v) {
          System.out.println("Clicked!");
      }
  });
</code></pre></div>    </div>
  </li>
  <li>객체 생성처럼 보이나, outer 클래스 내부에서 새로운 클래스의 몸통을 정의했으므로 내부클래스에 속함</li>
  <li>클래스를 만들고 호출하면 그 정보는 메모리에 올라가므로 많이 생성될수록 메모리 사용량이 늘어나고 애플리케이션 시작 속도가 느려짐. (로컬)내부클래스와 달리 익명클래스를 사용하면 Outer 클래스의 인스턴스 변수 등을 참조하지 않는 이상 Outer 객체와 불필요하게 오래 연결되지 않아 GC의 Outer 객체 회수가 더 용이해짐</li>
</ul>

<h2 id="14-어노테이션">14. 어노테이션</h2>

<h3 id="141-정의">14.1 정의</h3>
<ul>
  <li>클래스나 메소드 등의 선언시에 @를 사용하는 것. JDK 5부터 등장함</li>
  <li>컴파일에게 정보를 알려주거나, 컴파일할 때와 설치 시의 작업을 지정하거나, 실행할 때 별도의 처리가 필요할 때 사용함</li>
</ul>

<h3 id="142-자바-기본-어노테이션-3개">14.2 자바 기본 어노테이션 3개</h3>
<ul>
  <li>@Override
    <ul>
      <li>해당 메소드가 Override 된 것이니 잘못 코딩 시 컴파일러가 알려주도록 하기위해 사용</li>
    </ul>
  </li>
  <li>@Deprecated
    <ul>
      <li>컴파일러에게 더 이상 사용하지 않는 클래스/메소드이며 다른이가 사용시 경고하도록 요청하기 위해 사용</li>
      <li>여러 사람들과 작업할 경우 @Deprecated로 사용하지 않을것이라는 알림을 제공하여 계도 기간을 거친 후 삭제하는 것이 바람직함</li>
    </ul>
  </li>
  <li>@SupressWarings
    <ul>
      <li>컴파일 시 경고 메시지가 나타날 때 내 의도대로 코딩한 것이니 경고를 해줄 필요가 없다고 컴파일러에게 알리는 용도</li>
      <li>속성값을 지정할 수 있음 -&gt; @SupressWarings(“deprecation”)</li>
    </ul>
  </li>
</ul>

<h3 id="143-메타-어노테이션">14.3 메타 어노테이션</h3>
<ul>
  <li>어노테이션을 직접 선언할 때 사용</li>
  <li>@Target
    <ul>
      <li>어노테이션을 어떤 것에 적용할지 선언</li>
      <li>@Target(ElementType.METHOD)와 같이 괄호 안에 적용대상 지정
        <ul>
          <li>적용 대상
            <ul>
              <li>CONSTRUCTOR</li>
              <li>FIELD</li>
              <li>LOCAL_VALIABLE</li>
              <li>METHOD</li>
              <li>PACKAGE</li>
              <li>PARARMETER</li>
              <li>TYPE : 클래스, 인터페이스, enum 등</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>@Retention
    <ul>
      <li>얼마나 오래 어노테이션 정보가 유지되는지 선언</li>
      <li>@RETENTION(RetentionPolicy.RUNTIME)
        <ul>
          <li>적용대상
            <ul>
              <li>SOURCE</li>
              <li>CLASS</li>
              <li>RUNTIME</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>@Documented
    <ul>
      <li>해당 어노테이션에 대한 정보가 Javadocs(API) 문서에 포함된다는 것 선언</li>
    </ul>
  </li>
  <li>@Inherited
    <ul>
      <li>모든 자식 클래스에서 부모 클래스의 어노테이션을 사용 가능하다는 것 선언</li>
    </ul>
  </li>
  <li>@interface
    <ul>
      <li>어노테이션을 선언 시 함게 사용</li>
    </ul>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.lang.annotation.*;

//적용 대상 지정 (클래스, 메서드 등)
@Target({ElementType.TYPE, ElementType.METHOD})

//유지 정책 지정 (런타임)
@Retention(RetentionPolicy.RUNTIME)

//어노테이션 정의
public @interface UserAnnotation {
    public int number();  // 속성 정의
    public String text() default "This is first annotation" // 기본값 있는 속성
}

@UserAnnotation(number = 1, text = "클래스에 적용")
public class UserService {

    @UserAnnotation(number = 2) // text는 기본값 사용. 기본값 지정되어 있지 않은 number는 반드시 값 지정 필요
    public void createUser() {
        ...
    }
}
</code></pre></div></div>

<ul>
  <li>어노테이션 속성은 메타데이터일 뿐 실제 필드가 아니며, 값을 읽어오려면 자바 리플렉션이라는 API에서 제공하는 클래스들을 사용해야 함</li>
  <li>lombok : 개발자가 필요한 작업을 어노테이션 선언만으로도 편하게 처리할 수 있게 도와줌</li>
</ul>]]></content><author><name>Toyo</name></author><category term="CS" /><category term="java" /><summary type="html"><![CDATA[1. 자바 변수와 자료형]]></summary></entry><entry><title type="html">뉴욕주민의 진짜 미국식 주식투자 : 내용 정리</title><link href="/investments/2025/06/07/%EB%89%B4%EC%9A%95%EC%A3%BC%EB%AF%BC%EC%9D%98-%EC%A7%84%EC%A7%9C-%EB%AF%B8%EA%B5%AD%EC%8B%9D-%EC%A3%BC%EC%8B%9D%ED%88%AC%EC%9E%90.html" rel="alternate" type="text/html" title="뉴욕주민의 진짜 미국식 주식투자 : 내용 정리" /><published>2025-06-07T00:00:00+00:00</published><updated>2025-06-07T00:00:00+00:00</updated><id>/investments/2025/06/07/%EB%89%B4%EC%9A%95%EC%A3%BC%EB%AF%BC%EC%9D%98%20%EC%A7%84%EC%A7%9C%20%EB%AF%B8%EA%B5%AD%EC%8B%9D%20%EC%A3%BC%EC%8B%9D%ED%88%AC%EC%9E%90</id><content type="html" xml:base="/investments/2025/06/07/%EB%89%B4%EC%9A%95%EC%A3%BC%EB%AF%BC%EC%9D%98-%EC%A7%84%EC%A7%9C-%EB%AF%B8%EA%B5%AD%EC%8B%9D-%EC%A3%BC%EC%8B%9D%ED%88%AC%EC%9E%90.html"><![CDATA[<h2 id="1-미국-주식시장-구조">1. 미국 주식시장 구조</h2>
<ul>
  <li>미국 주식시장은 3개의 시장 플레이어로 구성됨.
    <ul>
      <li>미국증권거래위원회(SEC) : 매매 관리 감독, 규제.</li>
      <li>셀사이드 : 유가 증권을 유통하는 증권사. 미국에서는 투자은행IB가 담당. 매매 중개자이자 딜러에 속함.</li>
      <li>바이사이드 : 투자 대상을 선별해 자산을 투자하는 운용 주체. 개인 또는 외부 투자자의 자금을 운영하는 펀드회사. 헤지펀드, 사모펀드, 자산운용자, 보험사 등</li>
    </ul>
  </li>
  <li>을의 입장인 셀사이드는 갑인 바이사이드에게 매매 수수료를 받는 대신 기본 매매 업무뿐 아니라 기업 연계 서비스도 제공</li>
  <li>셀사이드 애널리스트 : 증권사, 투자은행 등에서 일하며 기업 분석 리포트를 작성하고 기관/개인에게 투자 의견을 제공. 투자자의 셀사이드 리서치 의존도가 예전에 비해 낮아지자 증권사 측에서는 셀사이드 애널리스트를 줄이는 추세</li>
  <li>바이사이드 애널리스트 : 연기금, 자산운용사, 보험사, 헤지펀드 등에서 내부 투자 판단을 위한 분석을 수행하는 전문가. 외부에 분석 결과를 공개하지 않음</li>
  <li>공시 자료를 정확히 이해하고 미래 손익을 추정하는 작업이 어려운 이유는 기업이 보고한 숫자를 그대로 받아들여서는 안되기 때문. 기업이 특정 비용을 예외로 간주해 누락한 이유가 무엇인지, 의도적으로 제외한 요소는 없는지, 경영진이 말하는 계속사업이익은 정말 지속가능한지, 재무상태표에 숨은 부채나 자산은 없는지 등 합리적인 의심 요소는 수없이 많음</li>
  <li>특별손익(Extraorinary Gains,/Losses), 일회성 비용(One-time Expenses; Non-recurring Charges) 같은 용어가 보이면 그 항목의 자금흐름을 정확히 이해할 필요가 있음. 회계기준을 위반하지 않으면서 경영진이 보여주고 싶은 부분만 보여주고 특정 비용을 잘 포장해 재무제표상의 숫자를 크게 왜곡할 수 있음</li>
</ul>

<h2 id="2-미국의-기업-공시">2. 미국의 기업 공시</h2>

<h3 id="21-ipo-공모주--회사가-처음으로-주식을-일반-투자자들에게-공개해서-파는-것">2.1 IPO 공모주 : 회사가 처음으로 주식을 일반 투자자들에게 공개해서 파는 것</h3>
<ul>
  <li>IPO를 진행 시 해당 기업이 SEC에 제출하는 S-1 등록서류에는 최근 3년간의 연결 재무제표와 함께 기업의 사업 개요, 리스크 요인, 경영진 정보, 공모 조건 등이 포함됨</li>
  <li>SEC에 제출하는 증권신고서에는 오퍼링(규정상의 사업설명서)/트레이딩 레지스트레이션(장외시장에 거래하는 증권 등록 공시자료. 사업설명서 없음)이 있음</li>
  <li>S-1 : 일반 기업의 오퍼링 레지스트레이션
    <ul>
      <li>확인할 내용
        <ul>
          <li>IPO 개괄(The Offering)과 조달 자금의 사용 목적과 용도(Use of Proceeds), 배당 정책(Dividend Policy), IPO 전후를 비교하는 기업의 캡 테이블(Cap Table, IPO 같은 투자, 자금조달에 따른 기업의 자본금 변화와 지분 관계를 나타내는 표. Capitalization 탭 참고), 주가 희석(Dilution) 내용 정도는 확인하는게 좋음</li>
          <li>회사 재무 상황과 사업 실적에 관한 경영진 의견과 분석(MD&amp;A)에 있는 리스크 요인(risk factors)을 집중해서 볼 것.</li>
          <li>연결재무제표. 최근 몇년 간의 재무제표를 통해 과거 실적들의 행간을 읽는 재무 분석 필요.</li>
          <li>기업의 비즈니스 모델을 확인해야 함. 기업이 매출을 어떻게 올리고 비용구조는 어떻게 되는지.
            <ul>
              <li>기업이 수익을 내는 핵심 요소(드라이버)를 반영한 가치 평가 지표 및 타 경쟁사와 비교 가능한 운영지표는 변동 시 주가가 크게 움직이므로 파악해두는게 좋음</li>
              <li>Key Performance Metrics 참고</li>
            </ul>
          </li>
          <li>회사의 IR 사이트나 SEC의 EDGAR 공시 시스템에서 확인 가능.</li>
        </ul>
      </li>
      <li>변경사항을 확인할 수 있는 보충문서
        <ul>
          <li>Form 424B1(기존 공시 및 사업 보고서에 나와 있지 않은 새로운 정보가 있으면 공시)</li>
          <li>Form 424B2(새 증권 발행 시 해당 증권의 발행 가격 및 방법에 대한 정보 공시 보고서)</li>
          <li>Form 424B3(기존 공시 및 사업 보고서에 나온 내용에 유의미한 변화가 있을 때 정정 보고서)</li>
          <li>Form 424B4(최종적인 증권 발행의 가격 및 투자금 배분, 조달. S-1과 함께 공시)</li>
        </ul>
      </li>
      <li>공시 문서를 읽고 해당 기업이 속한 산업의 성장 동력, 해당 기업의 차별화된 비즈니스 모델에 대한 산업 규제 리스크 등 앞으로 주가에 영향을 미칠 것들에 대해 고려해야 함
        <ul>
          <li>Adjusted EBITDA는 이자, 세금, 감가상각 외에 일회성 비용, 주식보상비, 소송 비용 등으로 쓰인 금액을 제외한 핵심 영업활동 수익성만 확인하는 것. 해당 항목에서 비즈니스 모델의 리스크에 해당하는 금액을 확인 할 수 있음. 영업외비용으로 분류된 법무 비용이 진정 일회성 비용이 아니라면 리스크가 될 수 있음</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="22-10-k--sec-제출용-연간-보고서">2.2 10-K : SEC 제출용 연간 보고서</h3>
<ul>
  <li>1부 : 사업 개요, 리스크, 법적 사항 (Business, Risk Factors)</li>
  <li>2부 : 회사 재무 상황과 사업 실적에 관한 경영진 의견과 분석(MD&amp;A)
    <ul>
      <li>기업의 지배구조, 조직구조</li>
      <li>기업의 연결재무제표</li>
      <li>기업의 실적 목표, 과거 경영진의 기대치와 실제 수치</li>
      <li>주요 사업 개요, 사업 환경, 시장 동향</li>
      <li>경영진이 인지하는 사업 리스크와 불확실성</li>
      <li>사업의 리스크 설명</li>
      <li>재무제표와 부속명세서 : 지난 2년간의 재무상태표, 지난 3년간의 손익셰산서와 현금 흐름표, 자본변동표</li>
    </ul>
  </li>
  <li>3부 : 경영진 및 이사회 구성과 기업의 지배구조, 임원의 보수 정보, 기업 내부자의 주식 보유 현황, 지분 관계가 있는 외부 주체 등</li>
  <li>4부 : 요약 재무 실적, 부록</li>
  <li>회계연도가 끝나면 90일 이내에 제출하는 공시자료이므로 해당 보고서 내용은 적어도 2~3개월 이상 지난 기업 현황임. Recent Events, Recent Deve-lopments 키워드로 최근 사건 검색 필요</li>
</ul>

<h3 id="23-10-q">2.3 10-Q</h3>
<ul>
  <li>분기가 끝나면 45일내로 공시하는 분기 실적 보고서. 10-K와 달리 공시한 재무제표에 감사가 들어가지 않았으며 덜 상세함</li>
  <li>추가로 분기별로 확인할 수 있는 자료로 주요 실적 발표 보고서 (Earnings Release), 해당 분기 사업 내용에 대한 투자자 설명서(Investor Presentation), 영업 실적의 보충 재무 현황을 담은 재무 보조 설명서(Financial Supplement), 어닝 콜 자료가 있음. 어닝 콜(경영진이 실적을 발표하고 다음 실적 목표를 공표한 이후 증권가 애널리스트와 Q&amp;A 세션을 여는 것) 내용은 대부분 웹캐스트나 오디오 파일 형태로 공유</li>
  <li>기업에 따라 기업이 예상하는 실적 지표 전망치를 담은 가이던스 메뉴를 따로 제공하기도 함. 보통은 주요 실적 발표 보고서 (Earnings Release), 해당 분기 사업 내용에 대한 투자자 설명서(Investor Presentation)에서 찾아봐야 함</li>
  <li>분기별 어닝 시즌은 주가가 가장 민감하게 움직이는 시기</li>
</ul>

<h3 id="24-애널리스트">2.4 애널리스트</h3>
<ul>
  <li>흔히 주식 애널리스트라 하면 셀사이드 애널리스트로, 증권사나 투자은행에서 일하면서 분기마다 담당 기업의 적정 주가 모델을 업데이트하고 기업 실적과 섹터 트렌드를 전망하는 보고서를 작성함</li>
  <li>어닝 시즌에 기업이 발표한 실제 실적이 월가에서 모아진 애널리스트들의 평균 예상치보다 높게 나오는지, 한참 미치지 못하는지에 따라 주가 등락이 결정됨. 실적이 예상치에 미칠지 미치지 못할 지를 예상하고 실적발표보다 먼저 움직일 필요가 있음.</li>
  <li>예상치는 Yahoo Finance &gt; Analysis 또는 Investing.com에서 무료로 확인 가능</li>
  <li>실적 발표 전에 이미 현재 주가에 기대심리가 반영되어 있을수도 있음</li>
</ul>

<h3 id="25-8-k">2.5 8-K</h3>
<ul>
  <li>10-Q, 10-K 제출 기간이 아닐 때 기업의 영업/재무 상황에 대하여 중요 변경 사항이 생길경우 공시. 파산, 구조조정, M&amp;A 관련소식 및 기타 등등</li>
  <li>파산에는 챕터 11인 파산 보호 신청과 챕터 7인 기업 청산이 있음. 파산 보호 신청 시 파산 보호법 상 기업은 빠르게 보유 자산을 청산하고 파산보호 상황에서 벗어나야 하는데, 파산 시 상환 우선순위에서 보통주 투자자는 가장 마지막이므로 대부분의 경우 주식 가치는 0이 됨</li>
  <li>유상증자 증권 신고서는 S-3으로 공시하며 투자자는 Form 424B에서 확인 가능. 신규 증권 발행 시 해당 증권 가격과 발행 주식 수 및 투자자가 알아야 할 리스크, 기대수익, 손실을 설명함
    <ul>
      <li>유상증자 시 주식 수가 늘어나며 주주 가치가 희석되지만 주가가 올라 부채비율을 낮추기 위함이거나 신사업 개발에 쓰이는 경우라면 기업 성장을 위함이므로 결과적으로 주가가 상승함. 반대로 재무 상황이 악화되었을 때 유상증자를 하면 공시가 뜨자마자 주가가 하락함</li>
    </ul>
  </li>
</ul>

<h3 id="26-def-14a">2.6 DEF-14A</h3>
<ul>
  <li>정기 주주 총회 전 제출해야 하는 공시. 프록시라고도 함.</li>
  <li>의결권이 있는 주주들이 회사 주요 사항, 지배구조에 투표하는 프로세스와 관련 정보 제공</li>
  <li>수록 내용
    <ul>
      <li>기업의 지배구조 : 이사회 역할과 구성</li>
      <li>이사회 : 이사회 멤버 약력과 당해 연도 보수, 선출 후보들의 프로필</li>
      <li>경영진/임원 : 경영진 약력과 지난 3년간 보수, 인센티브 금액, 보수 산정 체계, 경영권 해지/변동에 따른 페이아웃 제도
        <ul>
          <li>Compensation Discussion &amp; Analysis 부분에서 경영진의 기본 연봉, 성과급 기준, 현금 보너스, 스톡옵션 등 주식 보상을 포함해 지난 몇 년간의 보수 지급 현황/지급 사유 내역을 찾아볼 수 있음</li>
          <li>기업의 사업 실적에 비해 경영진/이사회 지급 보상 수준이 적절한지 확인 가능</li>
          <li>인수합병(M&amp;A) 등의 이유로 기업 경영권 주체가 변경될 경우 기존 경영진에게 주는 보상 내용도 있을 수 있음</li>
        </ul>
      </li>
      <li>주주총회 안건</li>
    </ul>
  </li>
  <li>일반적으로 경영진의 인센티브 상충에 문제가 잇거나 지배구조에 문제가 있는 기업의 경우 헤지펀드의 타깃이 되기 쉬움. 헤지펀드는 해당 기업들을 노려 지분을 5% 정도 매입한 후 기업구조를 주가가 오르는 방향으로 바꾸도록 영향력을 행사하고(구조조정, 자사주 매입 등), 주가가 오르면 차익을 실현하고 빠지는 식.</li>
</ul>

<h3 id="27-schedule-13d-13g">2.7 Schedule 13D, 13G</h3>
<ul>
  <li>미국 증권거래법 상 상장기업 지분을 5% 이상 보유하게 된 주체는 지분 거래 기준일로부터 10일 이내에 반드시 SEC에 신고해야 하며 Schedule 13D를 공시해야 함</li>
  <li>해당 공시는 공시자가 지분을 보유한 기업의 이름/티커의 13G, 13D로 검색 가능</li>
  <li>5% 이상 지분 보유자의 주식 매입 의도(Purpose of the Transaction, 테이크오버를 위함인지, M&amp;A를 위함인지 등)를 확인하기 위함</li>
  <li>해당 지분 소유자가 이미 13D를 공시한 상태에서 지분율을 1% 이상 변경한 경우에도 관련해서 다시 13D를 제출해야 함</li>
  <li>Schedule 13G는 13D에 비해 훨씬 더 간소한 보고서로, 13D 대신 제출할 경우 보유 지분으로 회사에 영향력을 행사할 의도가 없음을 증명하고 그 외에 SEC가 규정하는 일정 자격 요건을 갖춰야 함. 특정 기관에게만 허락된 형태의 보고서</li>
  <li>해당 공시를 통해 전문성 있는 큰 기관의 자금 흐름을 알 수 있지만, 개인 투자자가 그에 따라 해당 종목을 추격 매수/매도하는 건 권장되지 않음.
    <ul>
      <li>개인과 기관은 유동자금과 기회비용, 대체 전략 면에서 차이가 크기 때문에 설명 저평가 된 기업에 대한 투자라 할지라도 개인은 오랜 기간 유지되는 손실구간을 버티기 힘들 수 있으며, 행동주의 헤지펀드의 적대적 매수일 경우 경영권 주체가 정해지기 전까지 주가 변동성만 높아져 수익을 실현하기 어려울 수 있음</li>
    </ul>
  </li>
</ul>

<h3 id="28-schedule-13f">2.8 Schedule 13F</h3>
<ul>
  <li>자산 규모가 1억 달러 이상인 기관은 SEC에 해당 보유 지분 현황 보고서를 공시해야함. 헤지펀드를 비롯한 주식관련 대부분의 기관이 이에 해당됨.</li>
  <li>이 경우에도 지분을 보유한 기업의 이름/티커의 13F로 공시하는 것</li>
  <li>따라서 어떤 기업의 주요 주주명부를 확인하는 가장 빠르고 정확한 방법은 해당 기업의 13D, 13G, 13F 공시를 찾아보는 것임. 주주 중 기관투자자와 헤지펀드에 주목</li>
  <li>관심 있는 기관 플레이어들이 어디에 집중 베팅하는지 등 어떻게 움직이는지 확인할 수 있지만 분기 말 이후 45일 이내에만 공시하면 되므로 실제 매매가 이뤄진 타이밍보다 한참 뒤 지분 매입, 매각, 변경사항을 알 수 있다는 단점이 있음</li>
  <li>비교 분석하려면 이전 버전과 비교해 보아야 하며, 가독성이 떨어져 투자자를 위해 대형 기관이나 유명 헤지펀드에서 정리해 정보를 공유하는 사이트도 있음. 단, 실시간 제공이 아니며 다소 오류가 있을 수 있음</li>
  <li>포트폴리오를 방어하는 숏 포지션(공매도, 주가 하락에 배팅)이나 헤지는 롱 포지션(주식 직접 매수, 주가 상승에 배팅)과 달리 공시조차 하지 않음. 개인 투자자가 헤지펀드의 포지션을 따라하는 것은 앞서 말한 이유로 권장되지 않으므로 참고용으로만 활용할 것</li>
  <li>여기서 파악한 주주 명부로 해당 기관들의 13F</li>
  <li>용어
    <ul>
      <li>COM : 보통주 매입</li>
      <li>NOTE : 채권 투자자</li>
    </ul>
  </li>
</ul>

<h3 id="29-form-3-4-5">2.9 Form 3, 4, 5</h3>
<ul>
  <li>주요 미공개 정보를 보유한 사람들이 내부자 위치를 이용해 비파생/파생증권 매매 이득을 취하는 행위를 차단하기 위한 공시</li>
  <li>Form 3 : 인사이더가 처음 지분 획득 시 공개하는 지분율 최초 공시.
    <ul>
      <li>대상 : 기업 임원들, 기업 이사회 전원, 발행주식 총수의 10% 이상 보유한 실질 소유자, 기업의 주요관계자(기업 홍보자, 주식 발행 주관사, 기업의 전략 자문회사 등 내부자 정보를 아는 주체)</li>
      <li>대상자는 설령 지분이 없더라도 인사이더로 등재하는 순간 10일 이내 공시해야 함</li>
    </ul>
  </li>
  <li>Form 4 : 이후 주식 보유 현황에 변화가 있을 때 공시. 주식 매매일 기준 2거래일 이내 제출해야 하며, 그렇지 않을 경우 민형사상 처벌 대상.</li>
  <li>Form 5 : 해당 연도 보유 지분의 변경 사항과 최종 지분 상황을 정리한 것. 회계연도가 끝나고 45일 이내에 공시. Form 4 공시를 특정 사유로 지연 또는 면제 받은 사람은 Form 5를 제출하며 그간 공개안한 지분 변경 사항까지 공시해야 함</li>
  <li>내부자의 주식 추가 매수는 좋고 매도는 나쁘다고 단순하게 생각하기보단 그 의도가 더 중요함. 단지 스톡옵션을 일부 생사하기 위한 매도 일 수 있으며, 의도를 파악하려면 기업의 전체 상황과 공시 자료의 행간을 읽어내야 함</li>
  <li>용어
    <ul>
      <li>non-derivative securities (비파생 증권. 주식 등)</li>
      <li>derivative securities (파생 증권. 스톡옵션은 주식의 가치에 따라 가격이 결정되는 파생 증권)</li>
      <li>스톡옵션 : 회사 임직원에게 주는, 정해진 기간 동안 정해진 가격으로 주식을 살 수 있는 권리</li>
    </ul>
  </li>
</ul>

<h3 id="210-defm-14a">2.10 DEFM-14A</h3>
<ul>
  <li>공시 항목
    <ul>
      <li>해당 인수합병의 개요 (제안하는 인수대금 구성이 나옴)</li>
      <li>M&amp;A 타당성</li>
      <li>인수합병 딜의 구조</li>
      <li>딜 성사 조건과 클로징 예상일</li>
      <li>시너지</li>
    </ul>
  </li>
  <li>개인투자자가 흐름을 미리 읽고 인수합병을 예측하는데는 한계가 있으나, M&amp;A 발표 이후에도 투자 기회가 있음. 규제 장벽도 있고 다른 인수 제의가 들어오는 등 변수가 많기 때문. 이에 따라 주가도 낙폭이 커짐</li>
  <li>언론이 내보내는 기사는 공시자료를 추린 것으로 정보전달에 한계가 있으므로 직접 살펴보는 게 좋음</li>
  <li>일반 투자자 입장에서 관심대상은 주가가 급등하는 피인수 기업인데, M&amp;A에 필요한 자금조달 과정에서 인수 대금을 어떻게 구성하느냐에 따라 피인수 기업 주주가 얼마를 받을지가 결정됨</li>
  <li>인수합병은 일반적으로 피인수 기업의 보통주를 기존 주주들로부터 전부 사들이는 것</li>
  <li>보통 현금보유량이 많지 않으므로 100% 현금보다는 주식과 부채를 섞어 최대한 저렴하게 자금을 조달하려 함</li>
  <li>주식 교환비율은 “피인수 기업의 주주가 보유 주식 1주당 인수 기업의 주식을 몇 주 받는가”를 나타냄</li>
  <li>인수대금 구성 중 인수기업의 주식이 있을 경우 인수기업의 주가가 오를수록 이득. 대규모 유상증자로 인해 주가가 희석되니 인수 시너지가 얼마나 인수 기업의 주가를 상승시킬지가 중요</li>
  <li>인수합병(M&amp;A) 발표가 나면, 피인수 기업의 주가는 인수 기업이 제시한 인수가격 이상으로는 잘 오르지 않는 반면 인수 기업 주가는 딜 이후에도 업사이드가 있음. M&amp;A 뉴스로 거래량이 오르거나 다른 인수자가 인수 경합을 벌일 가능성이 있을 경우 기대 심리로 인해 피인수 기업의 주가가 더 오를수는 있음</li>
  <li>딜이 성사되지 않을 가능성이 높아질수록 인수 대상 주가는 하락함. 무산 원인으로는 반독점법 정부규제, 이사회에서의 승인 여부, 협상 결렬 등이 있음</li>
  <li>딜이 성사될거란 가정 하에 작지만 비교적 확실한 인수 가격과 현재 시장 가격과의 차이에서 오는 단기 수익 실현 -&gt; 피인수 기업 주식 구매</li>
  <li>딜의 시너지와 미래 성장성을 믿고 장기투자 -&gt; 인수 기업 주식 구매</li>
</ul>

<h3 id="211-s-4">2.11 S-4</h3>
<ul>
  <li>M&amp;A 관련주의 가장 상세하고 딜의 모든 내용을 포함하는 방대한 공시 자료.</li>
  <li>주요 항목
    <ul>
      <li>M&amp;A 승인을 위한 주주총회 위임 권유서</li>
      <li>주주들을 위한 Q&amp;A</li>
      <li>인수 기업, 피인수 기업 개요</li>
      <li>M&amp;A 딜 개요</li>
      <li>인수 기업 이사회가 해당 M&amp;A 건을 승인, 지지하는 이유</li>
      <li>인수 기업 재무 자문사(투자은행) 의견</li>
      <li>피인수 기업 이사회가 해당 M&amp;A 건을 승인, 지지하는 이유</li>
      <li>피인수 기업 재무 자문사(투자은행) 의견</li>
      <li>M&amp;A 인수합병 계약서 전문 : 재무분석, 합병 이후 추정 재무제표, 벨류에이션, 자금 조달 계획 등</li>
      <li>M&amp;A 자금조달 관련 사항</li>
      <li>인수 기업, 피인수 기업 주주의 권리 관련 사항</li>
      <li>M&amp;A가 인수/피인수 기업에 미치는 영향</li>
      <li>인수 대금 구성</li>
      <li>인수 기업과 피인수 기업 주주의 지분율 변화</li>
      <li>경영진의 황금낙하산</li>
      <li>딜의 성사 조건</li>
      <li>딜이 무산되었을 경우</li>
    </ul>
  </li>
  <li>위의 주요 항목 중 인수 기업의 밸류에이션 부분에서는, 인수/피인수 기업을 각각 자문해주는 투자은행이 제 3자 입장에 서는 다른 투자은행을 고용하여 해당 M&amp;A가 주주의 이익을 잘 대변하는 딜인지 평가하는 공정성 보증 의견의 일부 내용을 공개함</li>
  <li>공정성 보증 의견에는 각각의 시나리오에 따라 어떤 배수를 적용했는지, 어떤 할인 가격을 적용했는지 들의 방법론 설명. 밸류에이션에 관심이 있다른 중요한 참고자료</li>
  <li>딜 발표날짜 이후 언제까지 딜이 성사되지 않으면 시간이 흐를수록 위약 수수료(인수기업 -&gt; 피인수 기업)가 어떻게 되는지도 명시됨. 상황 상 인수가 미뤄지고 있어 방대한 수수료가 발생함에도 딜에 대한 재검토 의견이 없다면 그만큼 딜에 강한 확신과 자금력이 있다는 걸 유추할 수 있음</li>
  <li>인수합병에서 보통주는 단순히 현재 주가에 사들이는게 아닌, 인수자가 제시하는 “인수가격”에 따라 사들이는 구조. 피인수 기업 주주들에게 지분을 넘기도록 유인해야 하기 때문에 보통 <strong>현재 주가보다 높은 가격(프리미엄)</strong>을 제시</li>
</ul>

<h3 id="212-form-10">2.12 Form 10</h3>
<ul>
  <li>스핀오프로 설립한 새로운 회사가 주체인 공시 자료</li>
  <li>스핀오프는 기업의 성장 잠재력이 큰 부문을 독립시켜 자율성과 효율성을 높이는 구조로, 스핀아웃과 달리 기존 기업과의 자본관계가 유지되고 기존 주주가 신설 법인의 주식도 배분받기 때문에 주주가치가 증대됨. 이러한 구조는 장기적인 성장성과 수익성 향상에 대한 신호로 받아들여져 주가 상승으로 이어짐
    <ul>
      <li>리츠 회사에 대한 법인세 면제 조항이 무효화 되며 부동산 관련 부문을 독립시키는 리츠 스핀오프 열풍은 사그러들었지만 여전히 미국 스핀오프 시장은 활발하며, 스핀오프에 대한 예비 주주들의 관심도도 높음</li>
    </ul>
  </li>
  <li>Form 10을 검색하려면 새로 분사하는 기업명/티커를 알아야하는데, 기존 기업의 IR 측이 발표하는 뉴스를 확인하는 수밖에 없음. Form 10이 공시되면 기존 기업의 IR 사이트에 해당 내용을 발표함</li>
  <li>주요 항목
    <ul>
      <li>스핀오프를 하게 된 배경과 프로세스</li>
      <li>배당금 관련 사항</li>
      <li>분사 기업의 추정 연결재무제표</li>
      <li>회사 재무 상황과 사업 실적에 관한 경영진 의견과 분석</li>
      <li>분사 후 각 기업의 새로운 경영진 소개</li>
    </ul>
  </li>
  <li>추정 재무재표에는 독립되는 회사가 처음부터 모기업으로부터 독립한 별개 사업 주체였다면 과거 재무 상황이 어땠을지 계산한 내용이 나옴</li>
  <li>분사한 회사를 어떻게 운영하고 얼마만큼 새로운 가치를 실현하여 주식에 반영될지에 대한 상세 분석이 있으나, 경영진 입장에서의 설명이므로 주관적임을 감안해야 함</li>
  <li>주가의 향후 방향성에 대한 확실한 자료는 공시뿐이므로 공시를 읽고 이해한 다음 이를 투자에 적용하는 훈련이 필요함</li>
</ul>

<h2 id="3-섹터별-재무제표-읽기">3. 섹터별 재무제표 읽기</h2>

<h3 id="31-재무제표를-본다는-것">3.1 재무제표를 본다는 것</h3>
<ul>
  <li>기업 공시에 나타난 재무적 성과 지표를 제대로 본다는 것은 뛰어난 기업을 골라낸다기 보다는, 투자하기 좋지 않은 기업을 가려낼 가능성을 높이는 것
    <ul>
      <li>부실한 재무 상태를 숨기고 있는지, 경영진이 제시하는 기업 전략과 성장 예상치가 현재의 재무/영업 상황 대비 얼마나 현실적인지 등</li>
    </ul>
  </li>
</ul>

<h3 id="32-싼-주식과-비싼-주식">3.2 싼 주식과 비싼 주식</h3>
<ul>
  <li>‘싸게 사서 비싸게 팔아라’는 말은 차트를 보며 저점 타이밍에 매수해 고점으로 보이는 변곡점에 매도하는 기술적 매매가 아닌, 가치와 가격의 관계를 이해하고 그 균형이 기울어지는 순간 매수 매도 결정을 내리는 것</li>
  <li>단기간에 나타나는 필연적인 가격과 가치의 갭이 곧 수익실현의 기회
    <ul>
      <li>가격 &lt; 가치 : 싼 주식</li>
      <li>가격 &gt; 가치 : 비싼 주식</li>
    </ul>
  </li>
  <li>비싸다는 것은, 본인이 상품 가치를 충분히 인정하고 소비욕구가 있는 상태에서 본인이 인정하는 가치 대비 지불해야 하는 가격이 높은 것
    <ul>
      <li>현재 주가에 이미 미래 가치가 반영된 상태라면 그 가치를 실현해도 그 수준에 머물고 실현 못할 시 오히려 하락하므로 비싼 주식임</li>
    </ul>
  </li>
  <li>주식이 싸다면 시장이 기업 가치를 알아보지 못하고 있거나 기업 가치에 도달하는 것을 방해하는 기업 자체 문제 혹은 외부요인이 있다는 것</li>
  <li>가격이 실제로 확인 가능한 절대적인 숫자인 반면에 가치는 그 기준이 획일적이지 않아서 중점을 두기 쉽지 않으나, 자신만의 적정 가치를 정립해야 내가 싸게 사는지 비싸게 사는지에 대한 기준이 정해짐</li>
  <li>해당 주식이 같은 섹터 내 경쟁 기업 주식 대비 싸거나 비싼지 확인해보는 방법도 있음
    <ul>
      <li>현재 주가를 반영한 기업 가치(EV=시총+순부채=회사인수금액)를 향후 12개월 후의 실적을 추정한 EBITDA로 나누면 EBITDA 배수(=트레이딩 멀티플) 산정 가능
        <ul>
          <li>시총 : 주식의 현재 가격에 발행 주식 수를 곱하여 계산되는 시가총액</li>
          <li>EBIT : 이자, 세금 차감 전 이익. 감가상각비, 무형자산상각비가 반영되어 있어 설비투자비용이 크게 소요되는 섹터의 기업들의 수익지표로 적합</li>
          <li>EBITDA : EBIT와 달리 감가상각비, 무형자산상각비를 차감하지 않은 영업이익. 기업의 실제 수익 창출 능력을 평가하는 지표로 사용</li>
          <li>영업이익(Operating Income) : 매출에서 제품원가와 일반 판매비용과 관리비용을 차감한 금액. 본업에서 발생한 이익만 계산하며 영업외수익/비용은 포함하지 않음</li>
          <li>트레이딩 멀티플은 적정가치를 평가한 결과값이 아닌 실제 시장 가격을 기반으로 한 각 기업의 주가 배수. 투자 사이트나 증권사 컨센서스에서 흔히 보는 주가 배수임</li>
          <li>밸류에이션 멀티플은 가치 평가 대상인 기업과 유사한 기업들의 트레이딩 멀티플 평균값에다 애널리스트 재량에 따라 대상 기업의 성장성, 경쟁 우위 등을 반영해 적용하는 가치 배수</li>
          <li>실제 매출을 기준으로 계산하면 트레이딩 멀티플, 미래 EBITDA에 배수를 곱해 가치 추정할 때는 밸류에이션 멀티플
            <ul>
              <li>추정 EPSx12x = 추정 주당 가치. EPS는 주당순이익의 약자로, 기업의 연간 순이익을 발행주식수로 나눈 값</li>
              <li>추정 EBITDAx8x = 추정 기업 가치</li>
              <li>위에서 12x, 8x가 가치 배수임</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>주가배수 대비 가격에 대한 명칭
        <ul>
          <li>업계 평균 대비 낮은 배수에서 거래하는 주식 : Trading below market, Trading below sector average, Trading at a discount</li>
          <li>업계 평균 대비 높은 주가 배수인 주식 : Trading above market, Trading above industry average, Trading at a premium</li>
        </ul>
      </li>
      <li>트레이딩 멀티플은 비교 그룹 내 상대평가 잣대가 될 수 있지만 이는 실제 시장 가격을 기반으로 한 수치일 뿐 해당 배수가 상대적으로 낮거나 높은데에는 여러 요인이 있을 수 있으므로 큰 그림을 봐야 함
        <ul>
          <li>유사 기업과 비슷한 자본구조, 비슷한 규모의 기업 가치인데 미래 EBITDA 기대 성장률이 너무 높아 배수가 낮은 것이라면 싼 주식이라 할 수 있음
            <ul>
              <li>자본구조 : 필요한 자산을 어떻게 조달했는지. 자기자본과 부채의 비율</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>PER(주가수익배수) = P/E
    <ul>
      <li>주가 ÷ 주당순이익(EPS) = 주식투자자들이 손익분기점에 도달하는 기간</li>
      <li>주당순이익은 해당 기업이 매년 달성하는 예상 순이익 금액</li>
      <li>화폐의 시간가치나 기업의 성장 등 다른 요소를 고려하지 않은 단순 가정으로, P/E 배수는 상대적으로 봐야만 의미가 있음. 단, 비교를 하더라도 나머지 가치 요인들이 있으므로 그것만으로 더 싼 주식인지 판단하기는 힘듦</li>
      <li>이를 위해 기업마다 각각 다른 성장성을 표준화한 주가 배수가 PEG(주가수익성장률). 기대 성장률 차이를 P/E에 적정 수준으로 반영하고 있는지 판단하기 위해 사용됨
        <ul>
          <li>PEG = P/E ÷ (EPS 성장률 x 100)</li>
          <li>여기서 성장률은 향후 3~5년 연평균 기대 성장률을 말함</li>
          <li>이는 P/E가 높은 성장주에 유리한 지표</li>
          <li>이론적으로 PEG가 1.0 이하인 기업은 투자 적격 대상, 0.5 이하인 주식은 적극 매수라고 함</li>
          <li>그러나 EPS 기대 성장률이 높고 현재 주가수익률(EPS ÷ 주가 = P/E의 역수)이 낮다면 낮은 PEG만 보고 주식을 구매하는 건 현실적으로 지속되기 힘든 예상 고성장률만 믿고 손해를 보는 것과 다를바 없음</li>
          <li>또한 EPS 성장률이 중요한 자본 지표 중 하나인 기업의 잉여현금흐름(EBIT 같은 회계상의 영업이익에서 세금과 투자비용을 뺀 실제 손에 쥐는 현금) 창출 능력을 대변하지 못한다는 문제점이 있음
            <ul>
              <li>EPS 산출에 사용되는 순이익은 모든 비용을 다 뺀 회계상의 최종 이익으로, 실제로 기업이 쓸 수 있는 현금과는 차이가 있을 수 있음. 예를 들어 순이익에는 감가상각비가 반영되지만, 실제로는 투자할 때 한꺼번에 현금이 빠져나감</li>
              <li>PEG가 낮아도 잉여현금흐름 비율이 너무 낮으면 저평가된 주식이라 보기 어려움</li>
              <li>결국 기업의 종합적 요소를 고려하기 위해 재무제표와 기업 공시를 참고해야 함</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="33-소비유통주">3.3 소비유통주</h3>
<ul>
  <li>경제위기에 상대적으로 영향을 덜 받고 방어주 역할도 하면서 필수소비재로 취급받는 섹터</li>
  <li>식품 리테일
    <ul>
      <li>오래전 성숙기에 접어들어 경쟁이 심하며 보통 GDP 성장률을 따르지만 코로나19발 경기침체 때는 GDP 성장률과 반대로 급성장</li>
      <li>가장 주목해야 할 수익성 지료는 동일 매장 매출, 동일 매장 매출 성장률, 매출총이익, 매출총이익률</li>
      <li>동일 매장 매출 : 유통업에서 빈번한 매장 인수합병, 리모델링, 폐점, 신규개장 등의 변동성을 제외한 동일 매장 기준 매출 성장률을 추산할 때 사용. 실질적 실적 지표로 공시에서 총매출 성장률보다 주목해야 함</li>
      <li>매출총이익 : 유통 업계에서는 총매출에서 상품 유통비용을 차감한 금액. 유통비용에는 공급자에게 상품을 받는 원가, 상품을 자사 물류센터나 최종 리테일 지점까지 운반하는 비용, 재고 물량, 가격 할인과 프로모션, 기타 수입 비용 등이 있음</li>
      <li>해당 섹터 내 주요 주식은 앨버트슨, 크로거, 월마트, 타깃 코퍼레이션, 코스트코 등</li>
      <li>같은 섹터 내에서도 사업 모델이 다를 수 있음. 코스트코는 회원제로 대량 판매한다는 면에서 월마트의 샘스클럽과 유사해보이나, 주식을 볼때 가격대와 매장 규모 면에서 월마트, 타깃과 유사해 같은 비교 대상군으로 분류하는 편</li>
      <li>사업 보고서를 볼 때 수치뿐만 아니라 경영진이 설명하는 내용, 주석을 함게 참고해야 함
        <ul>
          <li>예를 들어 월마트는 경쟁사와 비교해 매출총이익률이 떨어지지만 어닝 콜 등 공시 들을 보면 가격 경쟁력을 위한 투자(Price Investment)로 인한 것임을 알 수 있음. 점유율을 높임으로서 보다 더 저렴한 가격 제공을 위한 것으로 기업 재무를 볼 때는 숫자만 보고 판단하는 단편적 비교는 지양해야 함</li>
          <li>반대로 재고관리 실패나 매출원가 증가에 대처하지 못해 이익률이 감소했거나 경쟁사 대비 줄어들었다면 실적발표나 주가에 부정적 영향을 미침</li>
        </ul>
      </li>
      <li>앨버트슨과 크로거는 규모, 수익모델, 가격/상품전략, 배송 서비스 등 여러면에서 가장 유사한 기업으로, 영업과 전략 부문에서 유사한 기업의 주식을 비교할 때는 재무적 성과에 집중하는 게 좋음. 매출 성장과 매출 총이익 성장률, 자본지출 규모, 이자보상배율, 잉여현금흐름 등
        <ul>
          <li>자본지출 : 미래의 이윤 창출을 위해 지출하는 비용. 대체로 장비, 토지, 건물 등의 고정자산이나 설비에 관한 지출</li>
        </ul>
      </li>
      <li>해당 섹터는 저마진 영업이라는 구조적 한계 상 마진 감소에 따른 경영 악화와 EPS 성장 침체가 가장 큰 리스크
        <ul>
          <li>투자를 위한 지출이 지속적 영업마진 악화로 이어지진 않는지 확인</li>
          <li>대부분 노동조합이 있어서 고용비용, 의료복지, 연금 비용 지출이 큼 -&gt; 기업 손익계산서상의 판매 및 일반관리비와 재무상태표 상의 연금부채 관련 항목 주시</li>
          <li>아마존 같은 전국적이고 효율성 높은 배급망으로 식품 유통시장에 진입하는 이커머스 업체로 인한 경쟁 심화도 리스크</li>
        </ul>
      </li>
      <li>자본지출 규모에 따른 투자자본수익률과 잉여현금흐름의 상태를 이해해야함</li>
    </ul>
  </li>
  <li>주주 주성 확인
    <ul>
      <li>IPO한지 얼마 안된 기업일수록 주주 구성을 살피는게 매우 중요. 특정 대주주가 기업 지분을 다량 보유해 일반 주주가 보유한 주식 가치를 희석할 가능성이 있음</li>
      <li>IPO 이후 내부자가 일정기간 동안 자사주를 매각할 수 없는 IPO 록업 기간은 90~180일 사이로, 이 기간이 지난 뒤 주식을 대량 매각하는 경우가 있음
        <ul>
          <li>IPO 이전에 자금조달을 위해 사모펀드 등 스폰서 기업들에 다량의 주식을 매각할 수 있으며 대량 매도 물량이 시장에 한꺼번에 풀릴 경우 얼마 안되는 나머지 주식 가격은 쉽게 무너짐</li>
          <li>스폰서 기관이 보유 지분을 계속 유지하는 경우에도, 주식 대부분이 스폰서 지분으로 묶여있으면 공개시장에서 유통되는 주식 비율이 너무 낮아 유동성 문제가 생김</li>
          <li>유동성이 낮으면 매수·매도 주문이 조금만 들어와도 주가가 크게 출렁이며 시장가 주문 시 원하는 가격에 체결이 어려운 문제 등이 있음</li>
        </ul>
      </li>
      <li>IPO 이후 변화는 분기 실적 리포트 10-Q, 연간 사업 보고서로 확인하고 공시 전 현재 시장에서 거래되는 주식의 유동성을 확인하려면 주식사이트에서 시장지표 확인
        <ul>
          <li>Shares Float, Free Float : 회사가 발행한 총 주식 수</li>
          <li>Shares Outstanding : 시장에서 실제로 매매 가능한 주식 수</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="34-성장형-우량주">3.4 성장형 우량주</h3>
<ul>
  <li>S&amp;P 500 지수 비중은 각 기업의 시가총액 크기에 따라 정해지는데, 2010년대 이후 애플, 마이크로소프트, 아마존, 구글 등이 기술 혁신과 수익성 개선으로 시총이 기하급수적으로 증가하며 지수 전체에서 20~30% 이상을 차지하게 됨 -&gt; 미국 주식시장을 대변하지 못하고 사실상 “빅테크 지수”에 가깝게 됨</li>
  <li>펀더멘털과 밸류에이션이 역으로 시장을 쫓는 주객전도 경향이 강한 섹터</li>
  <li>IT 버블기인 1999~2000년에 테크 스타트업은 연속 순손실을 기록하고 초기 사업 모델 콘셉만 있어도 애플에 견줄 시총을 달성 했음
    <ul>
      <li>밸류에이션을 산정하려면 ‘기준’이 필요함. 이익도 없고, 비즈니스 모델도 안정되지 않은 기업은 PER, PBR, EV/EBITDA 같은 밸류에이션 기준이 적용 자체가 불가능하거나 의미가 없음</li>
      <li>이때 펀더멘털(실적, 매출 같은 기업의 본질적인 가치)은 주가와 아무런 상관이 없어짐. 도박과 다를바 없음</li>
      <li>최근 기술주 밸류에이션 급상승은 이를 뒷받침하는 성숙기에 접어든 비즈니스 모델과 영업실적이 있으므로 버블이라 보긴 힘듦</li>
    </ul>
  </li>
  <li>단일한 수익 채널에 의존하던 과거와 달리, 최근의 대표 기술주들은 규모의 경제를 이루고 수익 채널을 다각화한 플랫폼 기반 사업 모델로 전환해 수익구조를 안정화함
    <ul>
      <li>구글은 유튜브내에서도 광고 수익, 프리미엄 구독 수입, 유튜브 TV 등으로 다양한 수익 채널을 만들어 옴. 클라우드 컴퓨팅과 자율주행 기술에도 공격적으로 투자중</li>
      <li>마이크로소프트는 소프트웨어 메인사업에 머물지않고 클라우드 사업에 적극 진출하여 수익 모델 업그레이드</li>
      <li>아마존 역시 주력인 이커머스 사업 외에 오프라인 매장, 광고 사업, 구독 사업, 아마존 웹 서비스 AWS 등으로 다수의 수익 채널 확장</li>
      <li>다각화된 수익 채널이 특정 사업 부문에 대한 하락세를 방어해주기 때문에 주가 안정성이 확보됨</li>
    </ul>
  </li>
  <li>수익채널 다각화에 따라 사업 부문별로 개별실적을 발표하며 부문별 수익구조에 따라 실적/가치 평가 방법이 다름
    <ul>
      <li>10-K나 연간 보고서에서도 부문별로 나뉜 공시를 확인할 수 있지만 Financial Supplement 공시에서 사업을 더 세분화하여 실적을 보여주기에 투자자가 사업 성장성과 수익 모델을 이해하기에 더 좋음</li>
      <li>해외 매출 비중이 큰 사업은 달러 환율의 영향을 많이 받으므로 전분기와 당기 실적 비교 시 환율 변동 효과를 제거한 수치를 봐야함 : Constant Currency, F/X Adjusted, Comparable, Excluding F/X 등의 조정 수치 참고</li>
    </ul>
  </li>
  <li>사업 부문별 성장 요인과 가치 창출 요인이 상이할 경우 각 부문을 개별 평가한 후 통합하는 SOTP 방식이 주로 활용됨
    <ul>
      <li>부문별 평가가치 총합 - 전사적 비용 = 기업 가치</li>
      <li>기업 가치 - 순부채 = 주주 가치</li>
      <li>주주 가치 ÷ 발행주식 총수 = 적정 주가</li>
    </ul>
  </li>
  <li>개인 투자자 입장에서, 시장 참여자(증권사 애널리스트 등)가 평균적으로 예상하는 수치인 컨센서스 수치를 기준으로 미래 실적을 예측하고 밸류에이션을 하는 것이 현실적</li>
  <li>컨센서스를 바탕으로 사업 모델을 이해하며, 적정 주가(가치)를 계산하고 시나리오 별로 바뀌는 주가를 예측
    <ol>
      <li>비즈니스 모델의 이해
        <ul>
          <li>구글이 공시 목적으로 구분하는 사업모델 3가지
            <ul>
              <li>구글 서비스 : 광고 수익을 창출하는 채널로 구글서치, 유튜브, 구글 네트워크로 구분</li>
              <li>구글 클라우드</li>
              <li>기타 사업 : 아직 R&amp;D 단계이거나 상품을 상용화하지 않은 시장 초입 단계인 외부사업에 구글이 투자하고 수익을 얻는 사업</li>
            </ul>
          </li>
          <li>각 사업 모델과 수익구조가 전혀 다르므로 매출 성장세 ,영업마진, 투자이익률도 구분해서 이해</li>
          <li>단순 연결재무제표상의 손익계산서는 매출이 하나의 수치로 통합되어 나오므로 제무제표상의 각 항목을 세부적으로 구분하고 설명해주는 10-K의 MD&amp;A 섹션 참고. 10-Q에도 사업 부문별 손익 업데이트 있음</li>
        </ul>
      </li>
      <li>사업 부문별 매출, 영업이익 추정
        <ul>
          <li>구글 기업 공시에서 가장 세분화한 구분인 6개 사업 부문별로 각각 다른 성장률을 적용하여 향후 1년 매출과 EBITDA 추정
            <ul>
              <li>이때 필요한 매출총이익, 영업비용, 영업마진(매출 중 얼마가 이익으로 남았는지 = 영업이익 ÷ 매출) 등은 가이던스나 어닝 콜에서 경영진이 꽤 자세히 설명해주므로 대략적인 추정치를 알 수 있음</li>
              <li>EBITDA = 영업이익 + 감가상각비</li>
              <li>영업이익 = 매출총이익 - 영업비용 또는 영업마진 × 매출</li>
              <li>매출총이익 = 매출 − 매출원가(소모된 재료비, 인건비 등)</li>
              <li>감가상각비는 10-K, 10-Q 등의 공시자료에서 확인. 보통 매출 대비 감가상각비 비율이 일정한 편</li>
            </ul>
          </li>
          <li>추정한 EBITDA 값에 밸류에이션 멀티플 적용. 밸류에이션 멀티플은 사업 모델이 비슷한 유사 기업, 동종 및 타 업계 경쟁사들의 현재 트레이딩 멀티플 참고. 비교군의 평균이나 주관대로 정함</li>
          <li>구글 서치, 네트워크, 구글 플레이 같은 사업은 이미 안정화되었고 수익(영업이익, EBITDA) 변동도 크지 않기 때문에 미래의 현금흐름을 비교적 예측하기 쉬움. 따라서 EBITDA와 기업 가치(밸류에이션 멀티플) 적용해서 사업 부문별 가치 계산 가능</li>
          <li>유튜브는 성장률이 훨씬 더 높고 수익 모델 자체가 계속 진화하여 EBITDA 추정하기 어려움. 이 경우 많은 테크 스타트업 처럼 추정 매출과 매출 배수만 적용하여 사업 가치 계산
            <ul>
              <li>EBITDA 추정하려면 EBITDA 배수, 마진 등이 필요한데 해당 수치들이 변동성이 높으면 불확실성만 높아짐</li>
              <li>여기서 EBITDA 배수, 매출 배수 등 밸류에이션 멀티플은 1년 예상 수익같은게 아니라 해당 기업/사업의 가치를 반영해 더 점수를 매기기 위해 적용하는 배수</li>
              <li>유튜브는 보는 사람마다 가치평가의 차이가 큼. 현재 애널리스트들은 9x에서 12.5x까지도 적용</li>
            </ul>
          </li>
          <li>구글 클라우드 사업 역시 성장하는 단계이므로 매출과 매출 배수만 적용하여 사업 가치 계산</li>
          <li>기타 사업들 중 대표적으로 웨이모는 당해 투자금액에 유사한 기업인 GM 크루즈의 밸류에이션 배수 적용, 나머지는 경영진이 가끔 컨퍼런스 콜 등에서 언급한 금액 참고</li>
        </ul>
      </li>
      <li>기업 전사적 비용 추정 및 기업 가치 선정
        <ul>
          <li>세일즈와 마케팅 비용, G&amp;A, R&amp;D, 기타 인건비나 장비 구입 비용 등 사업 부문별 마진을 통해 반영된 금액 외의 현금성 비용이 존재함</li>
          <li>Unallocated Costs, Unallocated Corporate Expenses라고 표현되며 공시에 반드시 따로 기재됨</li>
          <li>애널리스트들은 이런 비용 추정 시 경영진에서의 콘퍼런스 콜(어닝 콜에서 자주 등장하는 질문)에서 물어보거나, 경영진이 제시한 비용에서 추가로 감안하거나, 전체 매출에서 비율로 책정. 확실하게 추가로 지출될 것으로 보이는 법무비용 등이 생기면 반영해서 조정</li>
          <li>추정한 전사적 비용에 EBITDA 배수 등을 참고하여 밸류에이션 멀티플 적용, 사업 부문별 평가가치를 총 합산한 값에서 차감하여 기업 가치 선정</li>
        </ul>
      </li>
      <li>재무상태표에서 부채와 현금 계산
        <ul>
          <li>주주 가치는 총 기업 가치에서 순부채를 차감한 수치. 순부채 계산을 위해 기업의 총부채 금액, 현금 및 현금성자산 금액을 알아야 함</li>
          <li>올해 회계연도 말 예상 총부채와 현금성자산 금액을 계산해줘야 함
            <ul>
              <li>10-K 또는 10-Q 공시에서 현재 재무상태표상 현금(Cash and Cash Equivalents)에서 예상하는 현금흐름을 고려하여 연말 기준 현금보유 수준 추정
                <ul>
                  <li>우선 올해 남은 기간동안 창출 가능한 순이익 합계에 각종 비현금 비용(감가상각비, 스톡옵션 지급 비용 등 현금 아닌 회계상 비용)을 더하고 운전자본 변화로 생긴 추가 현금성비용(빌린 돈)과 지출을 반영하여 연말까지의 영업현금흐름 구함</li>
                  <li>자본지출 규모(올해 매출의 n% 투자 예정)를 확인하고 올해 남은 기간까지의 자본 지출 규모 추정. 그외 부채 상환 비용(Debt securities and maturity schedule, 분기별로 투명하게 공개됨), 자사주 매입 비용 등을 앞서 구한 영업현금흐름에서 차감</li>
                  <li>마지막으로 유가증권(Marketable Securities) 보유액 합산</li>
                  <li>총 부채를 나타내는 Long-term Dept 확인</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>주주가치와 적정 주가 계산
        <ul>
          <li>(기업 가치 - 총 부채 + 현금성 자산) ÷ 총 주식발행 수 = 적정 주가</li>
          <li>미국 애널리스트 리포트나 뉴스 기사에 등장하는 Implied Equity Value, Intrinsic Share Price가 이런식으로 산정한 적정 주가를 말함</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>5분 만에 추정하는 적정 주가
    <ul>
      <li>관심 기업의 티커를 미국 주식 사이트에 검색 -&gt; Analysis 탭으로 이동 -&gt; 애널리스트들이 평균적으로 추정한 주당 가치 (EPS)를 확인. 가치평가를 하려면 연 단위 EPS를 확인해야 함</li>
      <li>다음으로 티커와 함께 ‘PE multiple’ 혹은 ‘PE Ratio’를 포털 사이트에서 검색하여 P/E 배수 그래프로 추이 확인</li>
      <li>내년 해당 기업 컨센서스 EPS x 해당 기업 평균 주가 배수(P/E) = 적정 목표 주가. 주가 배수는 시기를 고려하여 가감하여 적용</li>
      <li>나의 기대수익률을 기준으로 내가 생각한 수익률이 얼마나 현실적인지 점검하는 법
        <ul>
          <li>기대수익률이 적용된 목표 주가를 현재의 추정 EPS(내년 EPS) 기준으로 주가 배수 역산(=Implied Multiple).</li>
          <li>그리고 그 목표 주가를 주식사이트에서 확인한 애널리스트 추정 EPS의 최댓값, 최솟값을 기준으로 주가 배수 역산. 내 기대 주가배수가 최댓값, 최솟값 사이에 있다면 내가 생각한 기대수익률과 목표 주가가 어느정도는 타당하는 것을 확인할 수 있음</li>
        </ul>
      </li>
      <li>많은 가정과 변수가 생략된 단편적인 방법이라 허점이 많으며, 도출해낸 값보다 그것을 해석하는 것이 훨씬 더 중요함</li>
    </ul>
  </li>
  <li>컨센서스와 밸류에이션은 시장 또는 개별 기업의 상황에 따라 얼마든지 바뀔수 있으며, 시장에서 항상 가격이 가치에 수렴하진 않음. 적정가치를 숫자 하나로 보는 것보다, 그 숫자가 나오게 된 배경(시장·기업에 대한 분석)을 스스로 파악하고 주가가 어떻게 움직일지 판단하는 훈련이 필요
    <ul>
      <li>컨센서스(여러 애널리스트들이 추정한 수치들의 평균값)를 형성하는 주요 변수들 : 시장과 기업 성장에 관한 가정, 수익 모델, 경영진이 가이던스에서 제시한 대로 기업을 이끌어가는 실행력, 가치 산정에 쓰인 유사기업 주식의 밸류에이션과 시장 프리미엄 등 시간에 따라 변화하는 여러 변수들</li>
    </ul>
  </li>
</ul>

<h3 id="35-호텔주">3.5 호텔주</h3>
<ul>
  <li>미국 호텔 산업은 호텔 건물이라는 유형자산이 아닌 호텔 브랜드(프랜차이즈)라는 무형자산을 운영하는 사업 모델, 호텔을 직접 소유한 주체는 호텔 리츠라는 부동산 회사 형태로 따로 분류해 상장되어 있음</li>
  <li>가장 중요한 사업 지표 : 객실당 매출(RevPAR, 객실 점유율 + 객실 단가). 해당 지표의 연도별 추이, 경쟁사 대비 상대적 성장률에 주목</li>
  <li>글로벌 단위의 프랜차이즈 운영을 하고 있어 ‘system-wide’(전사적 수치), ‘comparable’(리모델링/재개발 등으로 연중에 운영 못한 호텔/객실 수를 제외한 전기와 당기 간 비교 가능 수치) 표기가 들어간 실적 지표를 봐야 기업의 전체 운영 실적을 알 수 있음
    <ul>
      <li>ex : System-wide Revenue, System-wide EBITDA, Comparable Revenue..</li>
    </ul>
  </li>
  <li>호황기 때는 수혜를 많이 받지만 불황기에는 직격탄을 맞는 섹터</li>
  <li>chainscale(호텔 브랜드 등급)에 따라서도 타격과 회복 속도에 큰 차이가 남. 고가 브랜드(Luxury, Upper Upscale) 호텔이 경기에 가장 민감하고, 중저가 브랜드(Economy, Midscale) 호텔은 상대적으로 충격이 덜하며 회복 속도도 빠름
    <ul>
      <li>투자 시 대상 기업이 어떤 chainscale에 속하는 호텔브랜드를 각각 어느 비중으로 운영하는지 살피는 것이 중요</li>
    </ul>
  </li>
  <li>호텔 브랜드 기업의 성장 모델은 프랜차이즈 수익 확대에 있음. 가맹 호텔 개수 증가율 지표는 NUG(Net Unit Growth)</li>
  <li>미국 호텔 기업은 전체 포트폴리오를 Owned &amp; Leased 부문(호텔 자산 소유/임대하는 사업)과 Managed &amp; Franchised 부문(운영 및 프랜차이즈 사업)으로 분리해 공시. 각기 다른 매출, EBITDA, 영업마진 등을 각각의 수익 모델과 상황에 맞게 이해하고 분석해야 함
    <ul>
      <li>Revenues(수익) : Franchise and Licensing Fees, Owned and Leased Hotels..</li>
      <li>Expenses(비용) : Owned and Leased Hotels(운영 하는 호텔의 지출비용. 개별 호텔 직원 고용비, 식음료비, 청소비, 물품비, 건물관리비), General and administrative(그룹 차원에서 쓰는 마케팅, 호텔 경영진 월급, 호텔 프랜차이즈 플랫폼 운영비, IT 비용 등)</li>
    </ul>
  </li>
  <li>기업이 고정비와 변동비를 어떻게 구성하느냐에 따라 영업 레버리지가 달라짐. 고정비 비중이 큰 사업을 영업 레버리지가 높다고 표현하며 호황이면 영업이익률 증가가 매출 성장률보다 크고 반대로 불황으로 매출이 떨어질때는 영업이익 감소폭이 더 큼
    <ul>
      <li>영업 레버리지 : 매출 변화에 따라 영업이익이 얼마나 민감하게 반응하는지</li>
      <li>고정비 : Managed &amp; Franchised 부문에서 이미 구축한 IT 시스템, 본사 사무실 운영비. Owned &amp; Leased 부문에서 호텔 건물에 대한 호텔 자산 개발비, 자본투자비, 부동산 유지 관리비 등</li>
      <li>변동비 : Managed &amp; Franchised 부문에서 마케팅, 세일즈 비용. Owned &amp; Leased 부문에서 이용고객 증가에 따른 식음료비, 청소비, 객실관리비, 전기세, 호텔스태프 인건비, 물품비 등</li>
    </ul>
  </li>
  <li>호텔 사업의 경우 프랜차이즈보다 호텔을 직접 소유 운영하는 사업의 영업 레버리지가 훨씬 큼. 따라서 투자자는 호텔의 전체 사업에서 영업 레버리지가 높은 직접 운영 사업 비중이 얼마나 큰지, 프랜차이즈 사업 규모와 성장률이 그를 상쇄할 만한지 등을 따져봐야 함
    <ul>
      <li>경기불황에 버틸 수 있는 사업구조인지, 경기 회복 시점에 어떤 기업이 더 빠르게 반등 가능한지 등</li>
    </ul>
  </li>
  <li>호텔 리츠의 경우 지역별 호텔 자산(건물) 분포를 파악하는게 중요. 자산 입지 별로 수익 편차가 큼. 호텔 수요가 집중된 미국 대도시가 경기침체기에 특히 더 취약함</li>
</ul>

<h3 id="36-리츠주">3.6 리츠주</h3>
<ul>
  <li>모기지 리츠, 주식 리츠(임대 사업을 하는 부동산 회사 주식)</li>
  <li>채권과 유사한 경향을 보임. 기업 가치 성장은 다른 섹터 보다 낮은 편으로, 리츠 기업을 볼때 중요한 것은 사업을 지속하게 하는 부동산의 순자산가치와 배당 가능한 안정적인 현금흐름</li>
  <li>미국 리츠협회가 정의하는 리츠의 자격 요건은 기업이 소유한 자산의 75% 이상이 부동산이고 총수입의 75% 부동산 임대수익, 모기지나 부동산 매매로 구성되어야 함. 또한, 과세소득의 90% 이상을 주주에게 배당해야 함</li>
  <li>리츠 기업은 법인세를 내지 않으나 리츠주 배당금은 일반소득으로 구분되어 주주들은 본인 소득구간에 맞는 소득세를 냄</li>
  <li>리츠가 배당금을 정하는 기준은 당기순이익이 아닌 조정 운영수익이라는 수익지표
    <ul>
      <li>리츠의 운영수익(FFO) = 당기순이익 + 감가상각비 - 자산 매각으로 얻는 이익 + 자산 매각으로 얻는 손실 + 감액손실</li>
      <li>운영 조정수익(AFFO) = FFO - 반복적 자본지출 = 배당가능자금</li>
      <li>이 리츠가 매달 부동산 굴려서 현금 얼마나 잘 벌고 있나를 보는 것으로 정상적이고 일상적인 영업활동에서 발생한 수익만 산정함. 따라서 일회성 비용(자산 매각으로 얻은 이익, 손실)과 일상적인 영업활동과 무관한 비용(건물 가치 하락으로 인한 손실)은 모두 제외함</li>
      <li>감가상각비 = 건물이나 부동산 같은 고정자산의 장부가치를 매년 조금씩 비용으로 나누어 반영하는 것. 그러나 리츠에서 부동산은 시간이 지난다고 사업가치가 사라지는게 아니므로 오히려 더해줌</li>
    </ul>
  </li>
  <li>실적 발표마다 공시하는 AFFO 성장률과 배당지급비율 확대/축소/유지 상황에 주목해야 해당 리츠의 배당성향 파악 가능</li>
  <li>당기순이익을 대신해 AFFO를 보므로 EPS 대신 주당 AFFO를, P/E 대신 P/FFO, P/AFFO를 주가배수로 참고해야 함</li>
  <li>NOI는 전체 임대수익에서 부동산 관련 경비를 차감한 수치로 부동산 운영수익을 나타냄. 리츠주의 실적을 발표할 때 관건은 FFO, AFFO 성장률을 비롯데 NOI 성장률, NOI 마진이 얼마나 개선되었는지</li>
  <li>NOI 수치를 자본환원율로 나누면 리츠의 전체 부동산 가치, 여기서 부채를 차감하면 순자산가치가 됨</li>
  <li>임대수익은 임차인의 월 임대료를 꾸준히 지불할 수 있는 재정능력에 달려있으며, 리츠 사업 보고서에 있는 임차인 프로필로 현금 능력, 신용등급 확인 가능
    <ul>
      <li>임대료 감당률 = (EBITDA + 임대료) ÷ 연간 임대비용 = 몇 년 동안 임대료를 낼 만큼의 현금을 보유하고 있는지</li>
      <li>EBITDA는 임대료가 차감된 영업이익이므로 다시 더해주는 것</li>
      <li>임차인의 신용등급이 BBB 이상인 경우가 다수이면 안정적</li>
      <li>임대료 감당률을 보고 받지 못하거나 신용등급을 알 수 없는 리츠주는 투자 위험도가 높음</li>
      <li>임차인이 사업별로 얼마나 고르게 분포되어있는지 확인하는 것도 중요. 편의점, 약국, 대형 할인마트 등 경기와 무관한 필수소비재 관련 사업주가 임차인 구성의 주를 이루는 것은 강점. 그렇지 않은 임차인들은 어떤 식으로 임대료를 지급받고 어떻게 미지불 임대료 협상을 진행하는지 모니터링 필요</li>
    </ul>
  </li>
</ul>

<h2 id="4-미국-주식-특수-상황별-체크리스트">4. 미국 주식 특수 상황별 체크리스트</h2>

<h3 id="41-ma-종목-투자-시">4.1 M&amp;A 종목 투자 시</h3>
<ul>
  <li>영업 모델이 건실하고 시장 확대가 예상되며 재무 건전성이 좋으나 주가가 회사와 무관한 대외적 악재로 하락한 경우 매력적인 인수 합병 타깃</li>
  <li>미국에서는 매년 최고치 영업이익과 현금 보유금을 경신하며 잉여 현금, 높은 주가 배수를 자랑하는 기업이 많아 중장기 성장 동력을 위해 M&amp;A를 적극 활용함</li>
  <li>인수 주체는 같은 섹터 내 유사 기업 또는 사모펀드나 헤지펀드 같은 재무적 투자자인 경우도 있음. 미국에서는 평균 15~30% 인수 프리미엄을 붙여 인수금을 제시함</li>
  <li>M&amp;A 대상이 될 법한 주식에 투자할 수 있는 정보가 공시자료에 충분히 제공되기에 인수 대상 물색/딜을 진행하는 관점은 기관투자자와 개인투자자가 크게 다르지 않음</li>
  <li>인수 기업, 피인수 기업이 둘다 상장 기업인 경우 두 기업 간의 주가 배수 차이는 딜 성사 가능성을 알아내는 방법 중 하나. 최근에 격차가 많이 벌어진 경우 등</li>
  <li>개인투자자는 공시자료에서 인수 가격, 인수 대금 지급 형태, 인수 성사 조건, 딜이 성사되지 않을 경우 피인수 기업에 주는 위약 수수료 등을 확인하여 주주에게 얼마나 유리한 딜인지를 파악해야 함 (Preliminary Proxy, Definitive Proxy, DEFM 14A 확인)
    <ul>
      <li>100% 현금 인수일 경우 피인수 기업 주주들의 주식은 정해진 가격으로 강제 매각됨. 거래 대금 지급 방식에 주식 양도가 포함되어 있으면 주식 교환비율(현금 대비 주식 배율)에 맞춰 일부를 인수 기업 주식으로 할당 받음</li>
      <li>검색 키워드 : Closing Conditions, Condi-tions to the Merger, Termination Fee, Break-up Fee 등</li>
    </ul>
  </li>
  <li>M&amp;A 발표 직후부터 딜이 성사되기까지의 차익으로 수익 실현이 가능하나 여러 요인으로 무산되는 경우도 흔함. 개인 투자자는 매도 결정을 위해 공시자료에 있는 인수계약 불이행/재협상 사유, 위약금 등을 확인하여 인수가 어떻게 진행될지를 예측할 수 있음</li>
  <li>인수합병 시 인수/피인수 기업 모두 IR, 8-K 공시 및 보도 자료로 공시되나 스팩과의 합병일 때는 인수 주체가 되는 스팩이 SEC에 의무적으로 공시하는 Form 425 공시 및 8-K 중에서 ‘Entry into a Material Definitive Agreement’ 섹션에서 자세한 내용 확인 가능</li>
</ul>

<h3 id="42-ipo-주식">4.2 IPO 주식</h3>
<ul>
  <li>미국 증시에 IPO 직후 주가가 급등하는 경향이 있어 IPO 시장이 활발함. 단, 시황에 민감하여 철회/무기한 연기되는 경우도 많음</li>
  <li>나스닥 거래소의 IPO 캘린더, 뉴욕증권거래소의 IPO 센터에서 섹터 별로 자세한 추이를 확인할 수 있음</li>
  <li>헤지펀드, 사모펀드, 연기금 및 기타 대형 기관투자자는 주관사를 거쳐 할인된 가격으로 공모주 매입할 수 있으나 개인투자자 입장에서는 기본 최소 물량 때문에 권장되지 않음. 괜찮은 공모주 물량은 보통 기관투자자 &gt; 개인고액자산가 선에서 마감됨</li>
  <li>개인투자자 입장에서는 상장 후 주가 상승을 기대한다면 콜 옵션을 매수하거나(공모가 밑으로 하락시에도 행사안하면 그만), 공모주 투자 인덱스 펀드를 선택하거나, 롱숏 IPO 펀드 유형을 고려할 수 있으나 이 경우는 대부분 운용 수수료가 높음</li>
  <li>IPO 대신 뉴욕거래소/나스닥에 직상장하는 방법도 있음. IPO와 달리 기존 주주의 지분을 주식시장에서 매매 가능한 주식으로 교환한다는 차이가 있었으나, 최근 2020년 개정안에 따라 신주 발행도 가능해져 개인투자자에게도 첫 거래일에 주가 급등에 대한 수익을 낼 수 있는 기회가 주어짐
    <ul>
      <li>2억 5000만 달러 이상 규모여야 한다는 조건이 있으며 형성되는 시가에 요구되는 하한가가 있음</li>
      <li>IPO 보다 훨씬 빠르고 간편하게 기업공개가 가능하나 IPO의 인수 중개 과정을 생략하므로 기업 가치 선정/로드쇼 등으로 잠재 기관투자자에게 주식을 홍보해주는 투자은행의 도움을 받지 못함. 따라서 인지도 낮은 기업은 IPO 형태가 더 유리할 수 있음</li>
      <li>록업 기간 규제를 받지 않아 상장과 동시에 바로 보유 주식을 팔고 나올 수 있으며 투자은행에게 지급하는 자문 수수료가 없어 막대한 비용을 절감할 수 있음</li>
      <li>어느 정도 주가를 지지해주는 기관투자자/투자은행이 없어 변동성이 훨씬 커 리스크가 있음</li>
    </ul>
  </li>
  <li>미국 공모주 투자 시 알아야 할 6가지 날짜
    <ul>
      <li>공모가 산정일(IPO 날짜)</li>
      <li>상장 첫 거래일</li>
      <li>클로징 날짜(기업이 IPO/M&amp;A 등으로 자금 조달 시 해당 주관사로부터 거래 대금을 받은, 실질적으로 딜이 성사된 날)</li>
      <li>록업 기간
        <ul>
          <li>핫한 공모주에 참여해 단기 차익을 노리는 플리핑을 금지하기 위해 IPO를 앞두고 거래/홍보를 제한하는 기간. 통상 90일~180일 사이. 해당 날짜가 지나면 내부자들이 주식을 대량 매도하여 주가가 하락하는 경우 많음</li>
        </ul>
      </li>
      <li>침묵 기간
        <ul>
          <li>기업이 SEC에 공시 자료를 등록한 날부터 SEC에서 해당 공시 자료가 유효함을 승인하고 EDGAR에 공개하는 날까지 (경영진, 주관 투자은행 등 내부자들이) 주식 관련 어떤 의견이나 정보도 발표할 수 없는 기간. IPO의 경우에는 S-1 공시 발표시점부터 상장 이후 주식이 공개시장에서 거래되기 시작한지 40일째가 되는 날까지</li>
          <li>내부자가 편익을 챙길 수 없도록 투자자들을 보호하기 위함</li>
          <li>록업 만료일 전후로도 15일간의 침묵 기간이 있음</li>
        </ul>
      </li>
      <li>매매 제한 기간
        <ul>
          <li>기업 내부자들이 자사주 매매를 할 수 없도록 금지된 기간. 주로 어닝 시즌에 실적 발표 직전 며칠은 내부자들의 매매 금지됨. 해당 기업의 회계분기 말 이후부터 시작</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>개인 투자자에게는 침묵기간 후 애널리스트들이 처음으로 주식에 레이팅을 주는 Initiation Report라는 리서치 보고를 발표하고 이 방대한 투자 의견에 시장이 민감하게 반응하므로 해당 기간이 좋은 매매 기회가 될 수 있음</li>
  <li>IPO 주식은 유통하기 전부터 수요가 몰려 수급 현상 때문에라도 가격이 상승하며, 특정 산업(IT 같은) 밸류에이션 버블까지 가세하면 공모 전부터 주가는 크게 부풀려짐. 따라서 공모가에 매수하는 것도 심사숙고 해야함</li>
</ul>

<h3 id="43-로빈후드의-남다른-ipo">4.3 로빈후드의 남다른 IPO</h3>
<ul>
  <li>미국에서 일반적인 기업들은 예측 불가능한 주가 변동성을 우려하여 기관에만 공모주를 배정하다시피 하지만, 로빈후드는 IPO를 통하여 최종 38 달러(Priced at the low-end = 최종가격)로 자사앱에서 개인투자자들이 공모주의 20~35% 정도 되는 물량을 공모가에 매수할 수 있게 함(Form 424B4)
    <ul>
      <li>사고 싶었는데 못사는 상황이 없어져 오히려 첫날 주가 폭등이 없어짐</li>
    </ul>
  </li>
  <li>S-1에서는 내부자 트레이딩으로 의심되어 SEC가 조사하겠다고 한 내용이 공시됨
    <ul>
      <li>투자자들은 해당 내용을 참고하여 SEC 규제 당국과의 마찰이 과거에도 있었고 앞으로도 있을 것이며, 이런 마찰로 주가에 상당한 규제 리스크가 존재한다는 걸 인지해야 함</li>
      <li>사건 : 레딧에 모인 수백만명의 개미 투자자들이 전통적 기업이 기관투자자에 의해 지나치게 공매도 당하고 있다는 걸 지적 -&gt; 우리가 함께 매수해서 주가를 끌어올리고, 헤지펀드들에게 ‘숏스퀴즈’를 걸자는 집단 운동이 일어남 -&gt; 거래가 한번에 너무 많이 몰려 증거금이 지나치게 많이 필요해지자 로빈후드는 해당 밈주식들을 매매정지 조치함 -&gt; 로빈후드 임직원 일부가 우연히도 해당 주식들을 매매정지 조치가 있었던 1/28일 직전에 매도 -&gt; 내부자 정보에 따른 거래인가?
        <ul>
          <li>공매도 : 주식을 빌려서 지금 비싼 가격에 판 다음, 나중에 더 싸졌을 때 다시 사서 갚는 것</li>
          <li>숏스퀴즈 : 공매도 세력이 빌린 주식을 되사서 갚아야 할 때, 주가가 오르면 손해를 감수하고 더 비싸게 매수해야 하는 상황. 이로 인해 주가가 폭등할 수 있음</li>
          <li>헤지펀드는 “망할 것 같은 기업”의 주가가 떨어질 것으로 보고, 그 하락에 돈을 걸기 위해 공매도를 함</li>
        </ul>
      </li>
      <li>브로커딜러 임직원은 대부분 개별 주식 매매가 전면 금지이나, 개인투자자에 가까운 로빈후드 직원들에게 어디까지 매매 제한을 두어야 하는지 아직 법적 기반이 없음</li>
      <li>로빈후드는 증권사 역할을 하지만 새로 등장한 IT 기반의 브로커딜러에 대한 규제 프레임워크가 아직 완성되지 않아 완성될때까지 마찰이 있을 것이며, 주가에 악영향을 끼치는 건 덤</li>
    </ul>
  </li>
  <li>상장 후 5 거래일째가 되던 날 장이 열리자 28% 이상 주가 폭락
    <ul>
      <li>로빈후드는 IPO 전에 투자자들에게 전환사채(IPO가 끝나면 공모가의 70% 수준”의 낮은 가격으로 주식으로 바꿀 수 있는 권리)를 발행했는데, 이는 이미 S-1과 사업 보고서 등에서 수차례 공시된 내용</li>
      <li>로빈후드는 록업기간을 면제하는 조항을 두어서 상장 첫날부터 주식을 팔 수 있었음</li>
      <li>그런데 로빈후드 초기 투자자들이 약 9,800만 주에 달하는 주식을 매도하게 될 것이라는 뉴스 헤드라인 때문에 주가 희석에 대한 소문이 커뮤니티를 돌게되며 패닉 셀 유발</li>
      <li>결국 로빈후드는 그 다음날 8-K 공시와 보도 자료를 통해 전날 공시된 매도 가능 물량은 초기 투자자들의 전환사채 전환과 기존 록업 조항에 따른 것일 뿐 아직 SEC 승인절차가 남았고 2분기 실적 발표전까지는 해당 물량의 어떤 매도도 없을 것이라는 해명 보고서를 공시함</li>
      <li>이로인해 이튿날 그 주가가 다시 17% 회복됨</li>
    </ul>
  </li>
</ul>

<h3 id="44-스팩주">4.4 스팩주</h3>
<ul>
  <li>IPO와 달리 스팩 인수 건은 별도의 SEC 심사가 이뤄지지 않음. 따라서 IPO 대신 스팩회사로의 인수합병을 진행하면 SEC 규정에 피요한 의무 제출 서류, 세부 공개 절차, 기타 복잡한 규제를 피해갈 수 있음.</li>
  <li>주관사인 투자은행의 실사를 거쳐 밸류에이션 끝에 적정 공모가를 정해 IPO를 하는 일반 기업들과 달리 스팩은 유닛 단가 개념으로 주로 6, 8, 10 달러에 거래가 이루어짐. 밸류에이션 할 대상이 없어 사업 보고서도 기대하기 어려움</li>
  <li>투자자는 스팩 주식을 사면서 인수합병에 투자할 수 있고 정해진 기간 안에 기업 인수가 이뤄지지 않으면 펀드를 청산해 원금을 돌려받을 수 있음. 다만 스팩 공모 단계에서 투자자는 아무런 인수 대상도 없이 스팩을 운영하고 투자처를 발굴하는 사람들에게 투자하는 셈.</li>
  <li>상장으로 조달한 자금의 80% 이상을 사용해 18~24개월 안에 기업을 인수해야 하고 그렇지 못하면 해산되어 투자자는 스팩주 공모가에 투자 원금을 돌려 받음</li>
  <li>스팩이 인수합병을 진행하여 최종 인수 승인까지 받으면 기존 스팩 주식은 1주 당 인수 기업 주식 1주로 전환되며 인수 완료 후에는 정해진 기간,  행사가 등의 조건에 주식을 살 수 있는 Warrent 행사가 가능</li>
  <li>인수 대상 회사의 가치평가 없이 단지 인수 대상 발표 만으로 주가가 2배 가까이 급등하는 경우가 흔했지만 지금은 거품이 좀 꺼짐. 스팩주가 가장 크게 급등하는 구간은 합병 성사가 아닌, 합병 발표 시점이며 스팩주의 업사이드는 원금 보장과 합병에 대한 기대</li>
  <li>합병 발표 이후부터는 해당 기업의 실적과 미래 성장성이 반영된 주가로 거래되고, 여기서부터는 전혀 다른 접근법이 필요</li>
  <li>스팩주는 공모 단계부터 주식과 워런트를 한 쌍의 유닛으로 구성해 상장. 워런트는 “미래에 미리 정해진 가격으로 주식을 살 수 있는 권리”. 보통 IPO 이후 정해진 기간이 지나면 주식과 워런트로 따로 분리되어 각각 따로 사고 팔 수 있어짐
    <ul>
      <li>주가 희석 때문에 주식과 워런트는 1 대 1이 아닌 1 대 3비율과 같이 주어짐. 워런트는 정수 개수만 인정되므로 그만큼 유닛을 더 보유해야 손해를 안 봄</li>
      <li>스팩의 유닛 분리는 반드시 8-K 공시를 선행함. 이 때 해당 공시에서는 감사를 마친 제무제표와 스팩 공모로 조달한 자금을 반영한 자본금 변경 사항까지 나오므로 확인하는 게 좋음</li>
      <li>워런트는 보통 인수합병 성사 후 행사 가능하며 만기일이 지나면 사라짐. 해당 기간 공시 확인 필요</li>
    </ul>
  </li>
  <li>인수합병 과정에서 공시하는 프록시(DEF-14A)를 확인하여 적어도 주요 거래 내용(Key Tran-saction Terms) 섹션 확인하여 인수합병 이후 회사의 기업 가치(Pro-forma Enterprise Value)와 간단한 밸류에이션 지표 확인</li>
  <li>워런트에는 보통 콜 리스크가 있음. S-1, 8-K 확인
    <ul>
      <li>예: “합병 후 주가가 20일 중 10일 이상 $18 이상이면, 회사가 워런트를 30일 내에 행사하지 않으면 무효 처리할 수 있음.”</li>
    </ul>
  </li>
  <li>기초자산(주식)의 가격이 조금만 움직여도 워런트 가격은 훨씬 더 크게 움직임. 워런트 행사가보다 현재 주가가 더 높을때 워런트 가치는 가장 높음</li>
  <li>스팩의 워런트가 지닌 높은 레버리지 효과 때문에 인수합병 발표(주가 오름)나 성사 시점(신뢰가 높아져 더 오름)에 실현할 단기 수익을 노리는 트레이더들도 있음</li>
  <li>스팩 투자에 관심이 있다면 수시로 업데이트하는 스팩주의 공모 현황을 모니터링하고, 스팩을 운용하는 투자 인력과 그들의 투자 과정까지 신뢰할 수 있는지 따져봐야 함</li>
  <li>스팩주는 사모펀드의 블라인드 풀(투자자가 어떤 자산에 투자할지 미리 정확히 알지 못하는 상태에서 전문가에게 돈을 맡기는 펀드)과 유사한 효과가 있지만 사모펀드보다 최소 투자금액이 적고 접근이 쉬우며, 전문가들이 다양한 인수 대상을 고르기 때문에 분산 투자 효과가 있음</li>
  <li>단기로 접근한다면 인수합병 발표 시점을 주목해야 하고, 장기적으로 본다면 인수합병 후 성공적인 상장에 이어 계속 성장할 주식을 스팩 원금가로 싸게 진입한다는 사실에 의의를 둬야 함. 후자의 경우 길게는 2년 이상 투자금을 묶어놔야 함</li>
</ul>

<h3 id="45-주식분할">4.5 주식분할</h3>
<ul>
  <li>주식분할은 말그대로 보유한 1주의 주식이 여러개로 분할되어 가격도 개수도 그만큼 나눠질 뿐 기업의 펀더멘털과는 무관함. 그러나 기업이 주식 분할을 결정할 때 시장의 인식에는 변화가 생김</li>
  <li>기관 투자자 입장에서는 아무런 변화가 없지만 개인 투자자들은 가격 부담 때문에 고려하지 않던 주식의 가격이 1/n으로 줄어들면 더 관심을 보이기 때문에 그러한 심리를 이용해 주가 상승을 기대함. 실제로 애플, 테슬라가 주식 분할을 발표한 직후 주가가 11%, 13% 상승</li>
  <li>그러나 기업가치와 무관한 주가 상승이기 때문에 기업 가치와 상관 없는 이유로 주식을 매도할 가능성이 높은, 기업이 선호하지 않는 투자자들이 유입될 수 있음. 이에 따라 단기성 자금이 몰리며 변동성이 높아지므로 주식분할을 선호하지 않는 기업도 많음. 대표적인 예가 버크셔 해서웨이 주식</li>
  <li>주식분할 시 S&amp;P500 지수에는 별 영향이 없지만, 다우 지수는 단순 주가의 평균값이 움직이는 정도를 나타내므로 주식을 분할하여 주가가 분할된 기업의 움직임이 다우 지수에 미치는 영향력은 훨씬 떨어지고, 나머지 29개 주식의 영향력은 더 커짐. 따라서 다우 지수를 움직이는 주요 기업의 주식 분할은 다우 지수를 많이 하락시킬 수 있음</li>
  <li>다우 지수는 나머지 기업 주식과의 균형을 고려하기 때문에 너무 주가가 높은 주식은 포함시키지 않음. 주식 분할 이후 다우 지수에 새로 편입되는 등의 호재가 작용하면 주가의 추가 상승을 기대할 수도 있으나, 그런게 아니라면 차라리 다른 건전한 성장주 중 주식분할을 예상하는 주식에 투자하는 게 나음
    <ul>
      <li>기업이 건실하지만 주가가 너무 높아 다우 지수에 포함 안되고 있는 아마존, 구글, 넷플릭스 및 기타 등등</li>
    </ul>
  </li>
  <li>주식분할은 일시적 유동성 공급 면에서 호재일 수 있으나 기업의 성장성이 받쳐줘야 함. 그렇지 않다면 장기적으로 주가를 오르게 하진 않음</li>
</ul>

<h3 id="46-배당주">4.6 배당주</h3>
<ul>
  <li>배당은 기업이 잉여자본금을 주주에게 환원해주는 것</li>
  <li>배당률 = 연간배당금/현재 주가일 뿐이고 배당 성향도 기업 상황에 따라 얼마든지 바뀔 수 있으므로 배당주를 탐색할 때 단순히 배당률이 높거나 오랜 배당 역사가 있는지 보는 것은 의미가 없음
    <ul>
      <li>실제로 코로나 시기(2020년) 동안 경기침체 타격으로 배당금을 축소, 중지한 종목은 총 639개나 되었음</li>
    </ul>
  </li>
  <li>고배당주가 고배당인 이유, 저배당주가 저배당인 이유와 배당을 꾸준히 유지할 현금 여력이 있는 지를 기업 공시와 제무제표를 통해 반드시 확인해야 함</li>
  <li>배당성향은 회사가 벌어들인 순이익 중에서 얼마를 배당금으로 지급했는지를 나타내는 비율
    <ul>
      <li>배당성향=( 배당금/순이익 )×100</li>
    </ul>
  </li>
  <li>일반적으로 기업 순이익과 주당순이익에 배당성향을 적용해 배당금을 책정함. 단, 리츠 같은 특수한 경우 주당 순이익이 아닌 AFFO 수치에 배당성향 적용
    <ul>
      <li>예를 들어 통신사인 AT&amp;T의 2020년 2분 10-Q의 손익계산서에 공시된 당기순이익, 희석주당순이익은 Asset Impairments, Depreciation &amp; Amortization 처럼 실제 현금 지출이 아닌 회계 비용을 모두 차감해서 표시하고 있어 산업 특성 상 배당 지금 여력을 판단하는 기준인 실제 현금 보유력과 무관함</li>
      <li>따라서 AT&amp;T 경영진은 순이익이 아닌 잉여현금흐름(영업현금흐름 - 자본지출)을 기준으로 배당성향 책정해 분기별 배당금 지급 사항 공시</li>
      <li>최근 어닝 콜에서 CFO는 연초에 발표한 200억 달러 자본지출 계획은 여전히 유효하며, 현금흐름은 영업활동에 따른 현금 증가분을 목표로 하고 있고 자본지출을 절감하는 식의 현금 유는 없을거라 명시함 -&gt; 현재로선 성장을 위한 자본 투자를 소홀히 하지 않으며 정상적인 영업활동에 지출하는 영업비용, 이자비용 등을 충분히 감당할 잉여현금흐름 창출 능력이 있다는 것</li>
    </ul>
  </li>
  <li>배당성향은 기업이 벌어들인 돈 대비 얼마를 돌려주는지, 배당률은 투자자가 지금 가격에 투자했을 때 기대할 수 있는 배당 수익이 얼마인지를 보여줌</li>
  <li>배당주 배당성향 체크리스트
    <ul>
      <li>기업 실적 : 기업의 이익과 현금흐름(EPS, AFFOPS, FCF)이 배당과 함께 성장하고 있어야 배당금도 성장함</li>
      <li>배당성향 변화 추이 : 배당성향이 올라 배당금이 커진 건 경영진이 기업 미래 이익이 상승할거라 판단했기 때문이고 그 반대의 경우는 기업 이익 악화 신호이자 배당 성향 축소 조짐</li>
      <li>배당 패턴 : 배당금이 일관성 있게 유지 또는 성장하고 있는지, 큰 변동성이 있었다면 어떤 이유였는지</li>
      <li>배당률 산정 기준 : 배당률 계산에 사용된 연간배당금이 과거 1년간 지급한 금액인지, 예상 금액인지, ETF 배당의 경우 주가가 펀드 주가(시장가)인지 순자산(실제 구성 주식 주가들의 합)인지, 주가와 순자산에 큰 차이가 있는지 확인</li>
    </ul>
  </li>
</ul>

<h2 id="5-현실적인-미국-주식투자-전략">5. 현실적인 미국 주식투자 전략</h2>

<h3 id="51-리스크-관리">5.1 리스크 관리</h3>
<ul>
  <li>목표 수익률을 제대로 확립하려면 먼저 리스크 대비 수용 가능성을 이해해야 함. 리스크를 수용하는 만큼 기대수익도 커짐
    <ul>
      <li>주식, 채권 6:4의 흔한 비율의 포트폴리오 구성 시 연 8~10%이 현실적인 목표 수익률, 주식만으로 채울경우 리스크가 올라가지만 연 10~15% 정도</li>
    </ul>
  </li>
  <li>리스크는 단순히 손실 가능성이 아닌, 수익 변동성으로 이해하는 것이 정확함
    <ul>
      <li>공격적인 투자 전략으로 알려진 헤지펀드는 리스크 대비 높은 수익률을 실현하며 다른 기관투자자보다 훨씬더 보수적이고 리스크 관리를 핵심으로 여김</li>
    </ul>
  </li>
  <li>개인투자자들에게 가장 효과적인 리스크 관리는 포트폴리오의 자산분배 전략. 음의 상관관계(한쪽 자산가격이 올라갈 때 다른 쪽 자산가격이 내려가는 관계)인 자산을 적절히 배분하여 급변하는 시장 움직임에도 평균 수익률을 방어</li>
  <li>리스크 수용도란 리스크 감당 능력이 아닌, 개인이 리스크를 받아들이는 성향을 의미함. 반면에 리스크 감당 능력은 말그대로 감당할 수 있는 개인의 재정 능력을 의미</li>
  <li>수익을 내는 트레이더는 사고파는 시점을 미리 정해놓고 포지션을 잡음. 손실과 수익실현에 대한 기준점이 미리 있어야 함</li>
  <li>손절 StopLoss’ S/L과 익절 Take Profit; T/P의 지정가 설정과 자동 매매 기능으로 주가의 평균 변동성 구간을 나타내는 ATR(Average True Range)에서 1.5배를 벗어나는 구간에서 지정가 매도 주문을 걸어놓는 방법도 자주 쓰임. 종목, 섹터마다 시장 수익률과 변동 폭의 편차가 심하고 어닝 시즌 같은 시기에 더욱 편차가 증가하니 유의해야 함</li>
  <li>손실 상쇄 전략으로 풋 옵션 구매가 있음. 풋 옵션은 미래에 특정 주식을 특정 가격에 팔 수 있는 권리로, 매수한 주식의 주가 하락 시 풋 옵션 가격은 반대로 오르며 손실 한도를 제한함
    <ul>
      <li>단, 적어도 1년 이상 투자를 지속할 가치평가를 한 기업이고 단기간의 변동성에 의한 일시적 하락세가 예상될 때만 의미가 있으며, 6개월 정도의 단기 수익을 노리고 매수했다면 3, 6개월 만기의 풋 옵션을 사는 건 의미가 없음</li>
    </ul>
  </li>
</ul>

<h3 id="52-성장주와-가치주">5.2 성장주와 가치주</h3>
<ul>
  <li>성장주 : 전체 시장보다 높은 가격에 거래되고 주가 배수가 높음. 낮은 순이익이나 향후 기대 성장률이 높음. 경기와 무관하게 높은 성장에 대한 기대를 받음. 가격 변동성이 높으며 주로 IT, 임의 소비재가 이에 속함</li>
  <li>가치주 : 주로 펀더멘털은 탄탄한데 특정 요소(컨센서스에 못미친 분기 실적, 소송, 경영진 문제 등) 때문에 일시적으로 주가가 떨어진 기업. 상대적 주가 배수, 가격 변동성이 낮음. 시장에서 아직 가치를 인정받지 못하지만 향후 가치가 주가에 반영되기를 기대하고 매수하므로 장기투자 필요. 주로 금융주, 유틸리티, 에너지 섹터가 이에 속함</li>
  <li>경기침체기에는 가치주가, 그 외 경기 호황, 상승장에서는 성장주 수익률이 시장을 압도함
    <ul>
      <li>침체기에는 사람들이 안정성을 선호함. 가치주는 이미 이익을 내고 있고, PER이 낮음 → 방어적 성격</li>
      <li>배당도 주고, 실적 변동도 적음</li>
      <li>호황기에는 금리가 낮음 → 미래 수익의 현재 가치가 커짐</li>
      <li>성장주는 미래 수익 기대가 크기 때문에 → 주가가 더 크게 반응</li>
    </ul>
  </li>
  <li>당장 1년 안에 결판을 볼게 아니라면 성장주, 가치주 중 하나에만 베팅하지 말고 기업 가치에 중점을 두되 시황에 따라 비율을 조정하며 수익을 극대화하는게 최선의 방법</li>
</ul>

<h3 id="53-채권과-주식">5.3 채권과 주식</h3>
<ul>
  <li>일반적으로 경기 침체 시 위험 자산인 주식이 빠져 주가가 하락하고, 안전자산인 채권에 몰려 가격이 상승하는 반면 경기 호황 시에는 기업의 수익에 대한 기대로 주식 매수가 증가하여 주가가 상승하고 금리 상승 전망으로 채권 가격이 낮아지는 등 서로 반대로 움직임</li>
  <li>단, 코로나 시기에 경제 활성화를 위해 저금리 상황에서 국채까지 매입, 국민들에게 직접 현금까지 지급하며 돈이 남아 금리는 더더욱 낮아지고 채권과 주식의 동반 랠리가 이어짐</li>
  <li>채권 이자는 정해져 있으므로 금리가 더 떨어져야 수요가 증가하고 가격도 오르는데, 경기 회복에 대한 기대감으로 오르는 주식과 달리 이미 0% 금리라 수요가 적어짐.</li>
  <li>그러나 주식대비 안정적이고 절대적인 고이자 수익 채권에 투자하는 건 유리할 수 있음. 미국의 투자적격 등급 회사채나 고수익 회사채의 경우 요즘 같은 경기침체기에 채무 불이행 위험이 상승하면 미국 국채 대비 훨씬 더 높은 금리 스프레드를 지급해야하기 때문</li>
  <li>또한 코로나로 인한 경기침체가 10년간 지속될거라 생각하지 않는 이상 경기회복 이후 채권을 포함한 포트폴리오는 제 역할을 충분히 발휘할 수 있음. 단기적인 현상이 아닌 장기적인 자산 가격 추이를 보면 두 자산은 반대방향으로 움직이는 게 맞음</li>
  <li>채권 투자가 불리한 시황이면 방어자산으로 현금 보유를 택하는 것도 좋을 수 있음. 핵심은 무조건 주식과 채권 비율을 맞추기보단 내 투자 목적을 고려하는 것</li>
  <li>시장 흐름을 살피려면 연방기금금리, 미국 국채 수익률, LIBOR, 인프레이션, 주요 환율 등의 경제지표와 그 외에도 대선이나 외교 정책, 새로운 정책 발표 같은 굵직한 정치적 이벤트들을 알아야 함</li>
</ul>

<h3 id="54-레버리지-투자">5.4 레버리지 투자</h3>
<ul>
  <li>기대수익률이 더 높은 자산에 집중하는 것과 레버리지로 수익률을 끌어올리는 것 중에서는 레버리지가 더 효과적임. 레버리지 없이 수익을 극대화하려면 고위험-고수익 자산에 더 집중할 수 밖에 없기 때문</li>
  <li>레버리지란, 선물계약·스왑·옵션 등의 파생상품을 활용해 기초자산(주식, 지수 등)의 하루 수익률을 2배, 3배 등으로 배수 추종하는 투자 구조. 실제 자산을 배수만큼 직접 사는 것이 아니라, 기초자산이 오르거나 내릴 때 수익률을 배수만큼 얻거나 잃을 권리를 가진 파생계약을 활용</li>
  <li>ETF의 경우 지수추종으로 치면 SPY, VOO, IVV 등에 대하여 배수 레버리지를 활용한 ETF 상품들이 있음. 하락장 일 때 2배, 3배 강도로 더 하락한다는 리스크가 있지만 해당 타이밍에 저점 매수 전략으로 추가 매수를 한다거나 새로운 진입 시점으로 잡으면 반등장에서 더 큰 폭의 수익률을 노릴 수 있음</li>
  <li>3배수 레버리지 ETF에 투자 시 원금이 녹아버릴 정도가 되려면 S&amp;P500 지수가 33% 이상 폭락했을 때인데 이 정도 규모의 폭락장은 글로벌 마켓에서도 찾아보기 힘듦. 인덱스 추종 펀드와 함께 레버리지 상품과의 비율을 조절해 활용하면 효과적인 포트폴리오 관리가 가능</li>
  <li>레버리지 상품은 하락시 복리효과가 더 강하게 적용되기 때문에 원금이 회복되려면 하락한 비율보다 훨씬 더 높은 상승폭이 필요
    <ul>
      <li>예 : 100만원에서 50% 손실 -&gt; 원금회복하려면 100% 비율로 상승 필요, 여기서 레버리지까지 고려하면 더 큰 상승폭 필요</li>
    </ul>
  </li>
  <li>반대로 시장을 숏하는 증시하락에 베팅하는 레버리지 상품도 있으나 실행하기 힘들 뿐더러 거래량이 적어 유동성이 낮으므로 추천하지 않음</li>
</ul>

<h3 id="55-애널리스트-리포트">5.5 애널리스트 리포트</h3>
<ul>
  <li>미국은 한국과 달리 애널리리스트 독립성을 명확히 보장하는 법적·제도적 장치가 있고 매년 바이사이드 투자 인력이 각각의 투자은행 애널리스트를 평가한 전문성, 독립성, 객관성 순위 공개. 따라서 애널리스트는 객관성을 유지하고 주가 분석에 따른 하향조정 리포트가 자주 나오는 편</li>
  <li>애널리스트가 분석한 목표주가가 시장가격과 연동하거나 심지어 실제 주가를 후행하는 경우도 있음. 이런 현상은 주로 성장주에서 나타나는데 애널리스트가 분석한 펀더멘털과 밸류에이션 모델의 결과값이 실제 시장에서 거래되는 가격과 편차가 큰 경우가 흔하기 때문</li>
  <li>성장주는 시장의 기대와 투자심리(주가가 오를수록 투자심리가 더 뜨거워짐)에 의해 주가가 폭발적으로 오르기도 하는데, 이럴 경우 전통적인 펀더멘털 분석이 무력해지기 때문</li>
  <li>재무적 숫자로 설명할 수 없는 시장의 기대심리를 잔뜩 반영해 주가의 상승세가 이어지면 애널리스트는 어느 정도 시장심리를 후반영해 목표주가를 수정하기도 함</li>
  <li>투자은행은 업무 특성상 대형 기관투자자의 거래를 중개하거나 자문하므로 기관의 자금흐름을 가장 먼저 파악할 수 있으나 이 역시 증권사 리포트(목표 주가·투자의견)로 선반영되므로 또 한 번 실제 매매가격을 후행하는 셈</li>
  <li>따라서 애널리스트 보고서에서 목표주가보다는 실적 추정치를 주목해야 함. 해당 기업의 실적 추정치 변화를 보는 것이 투자 의견보다 더 정확하기 때문. 목표 주가나 투자 의견에 변화가 없어도 애널리스트가 실적 추정치를 상향조정한다면 그 주식에 모멘텀이 있다고 본다는 것
    <ul>
      <li>예를 들어 매도 의견을 고수하던 애널리스트가 분기 실적 발표 전 경영진과의 미팅에서 새로운 자금조달 힌트를 얻거나 시장에 뜻밖의 호재가 생겼을 경우 매도 의견은 유지하되 일전에 발표한 비관적인 실적 예상치를 다소 상향조정할 수 있음</li>
    </ul>
  </li>
  <li>한 명의 애널리스트가 아닌 여러 투자은행이 같은 추세를 보인다면 주가에 큰 영향을 미침. 애널리스트들의 실적 추정치 평균을 스트리트 컨센서스라 하는데 어닝 시즌 동안 단기 주가를 움직이는 가장 큰 동력은 추정치 대비 실제 발표한 수치와의 갭</li>
  <li>애널리스트가 분석한 목표 주가는 도달하기까지 얼마가 걸릴지 알 수 없으며, 도달하지 않을수도 있음. 결국 개인투자자는 개인보다 정보 접근성, 전문성에서 우위인 애널리스트의 기업 분석 내용을 참고하여 스스로 기업의 펀더멘털에 따른 가치평가를 하고 적정주가를 산정해야 함</li>
  <li>증권사 리포트 체크 포인트
    <ul>
      <li>애널리스트 목표 주가는 회의적 시각에서 최대한 비판적으로 볼 것. 기업 가치와 시장 가치의 차이를 이해라고 목표 주가를 어떤 방법으로 도출했는지, 애널리스트의 의견을 어떤 방식으로 반영했는지 이해</li>
      <li>해당 산업과 기업의 객관적 팩트만 구분해서 소화할 것. 최대한 여러 명의 애널리스트 보고서를 참조, 비교해 주가방향의 객관성을 유지하고 항상 컨센서스와 비교해 업계 평균 컨센서스와 차이가 크면 왜 그런지 이해해야 함</li>
      <li>애널리스트 분석과 경영진 예측의 근거 자료를 확인하고 비교. 애널리스트가 왜 이런 가정을 하고, 그 근거는 무엇이며 타당한지, 경영진의 가이던스와 얼마나 차이가 나고 어디서 비롯되었는지, 현재 기업 상황과 시황을 봤을 때 말이 되는 모델인지</li>
      <li>애널리스트 리포트는 물론 시황, 경영진 가이던스, 자신의 의견 등을 비교해보며 기업 가치를 끊임없이 반문하고 분석하는 훈련이 필요</li>
    </ul>
  </li>
  <li>미국에선 증권사 리서치 리포트를 개인이보려면 돈을 지불해야 함. 대신 애널리스트의 목표 주가와 투자 의견, 그에 사용된 기본적인 수치들이 거의 실시간으로 각종 증권 뉴스 포탈에 올라오고 그 투자 의견의 변화 추기만 종합해서 종목별로 열람할 수 있는 무료 사이트가 많음</li>
  <li>가끔 주식투자 커뮤니티(Seeking Alpha, The Motley Fool 등)에서 특정 종목에 대한 증권사 리포트 일부를 공유하고 애널리스트의 가치평가 방법 및 그에 대한 분석을 하는 글이 종종 올라와 참고하기 좋음</li>
</ul>

<h3 id="56-투자-원칙을-지킨다는-것">5.6 투자 원칙을 지킨다는 것</h3>
<ul>
  <li>투자자는 자신만의 투자 원칙을 세워야 함. 투자 원칙 없이 주식투자를 하는 것은 도박과 다를게 없음</li>
  <li>자신의 투자 원칙에 참고할 보편적 투자 원칙
    <ul>
      <li>고위험 고수익에 내포된 위험과 보상 체계를 정확히 이해하고 수익실현과 손절매 기준을 세움
        <ul>
          <li>높은 리스크를 감수하고 고위험 성장주에만 집중하는 ETF나 개별 종목에 투자했다면 그 리스크에 따른 결과값을 이해하고 손실 기준점을 확립할 것. 급락 시 어디까지 손실을 감당할 수 있는지 기준을 먼저 계획해야 의연하게 대처할 수 있음</li>
        </ul>
      </li>
      <li>투자 기간이 길수록 자산 수익률 리스크가 낮아짐
        <ul>
          <li>투자 기간이 길수록 전체 가격 변동성이 낮아져 수익률 리스크도 낮아짐. 주식투자는 장기 보유하며 하락세든 상승세든 관계없이 초기 투자 전략, 투자 판단을 고수하는 것만으로도 리스크를 상당 수준 제거할 수 있음</li>
        </ul>
      </li>
      <li>정액분할투자를 함
        <ul>
          <li>특정 포지션에서 한 번에 매수하지 않고 주기적으로 정해진 금액을 투자해 평균 단가를 낮추는 방법. 주가가 떨어졌을때는 자동으로 더 많은 수의 주식을 매수하고, 주가가 오를 대는 덜 매수함. 즉, 매수하는 주식 수는 단가에 따라 변함</li>
          <li>갑자기 찾아오는 변동성과 불확실함 속에서도 포트폴리오를 키워갈 수 있게 함</li>
        </ul>
      </li>
      <li>포트폴리오 조정으로 리스크를 낮추고 수익률을 높임(리밸런싱)
        <ul>
          <li>예를 들어 포트폴리오가 주식 60%, 채권 30%, 금 10%이라면 분기마다 그 비율을 유지하도록 투자금을 조정함. 한쪽이 급상승하면 원래 목표로 한 배분비율에 따라 청산하고 나머지에 재분배</li>
          <li>오른 자산을 팔고 덜오르거나 떨어진 자산을 사서 자산 방어를 위해 원래 목표로 한 배분비율을 유지하여 수익률을 개선하고 손실을 방어함</li>
          <li>분기마다 주로 연기금이나 뮤추얼펀드, 보험회사의 자산 운용사 등 Passive Funds들이 내부적인 자산 배분에 대한 가이드라인을 지키기위해 리밸런싱을 하는데 이로인해 대규모 매도·매수가 발생</li>
          <li>개인은 이런 흐름을 미리 인지하고 감안하면 되는데 이를 이용해 직후에 ETF 가격 방향을 예측해서 콜옵션(상승), 풋옵션(하락)으로 레버리지 수익을 추구할 수도 있음. 단, 시장 방향을 예측할 줄 알아야 함</li>
        </ul>
      </li>
      <li>투자 원칙을 반드시 지킬 것</li>
    </ul>
  </li>
</ul>

<h2 id="6-미국-주식-트레이딩-전략과-기본">6. 미국 주식 트레이딩 전략과 기본</h2>

<h3 id="61-주가-변동에-대응하는-투자-전략의-기본">6.1 주가 변동에 대응하는 투자 전략의 기본</h3>
<ul>
  <li>개인투자자에게 가장 현실적인 투자수익은 주식을 사고파는 매매수익이 아닌 장기 보유에서 얻는 수익</li>
  <li>기업의 펀더멘털과 무관하게 시장이 반응하는 데는 크게 Headline Effects(뉴스 헤드라인만으로 긍정/부정적으로 인식하여 주식을 매매), Catalysts Trading(투자자들이 이미 숙지하고 있는 기업 이벤트에 대해 호재/악재를 판단하여 주식을 매매)이 있음</li>
  <li>Catalysts(촉매)는 주가가 크게 상승하는 계기가 될 수 있는 기업의 특별 이벤트로 중/장기, 단기, 하드, 소프트 캐털리스트로 구분
    <ul>
      <li>장기 캐털리스트 : 인수합병, 기업분할, 흑자 전환, 신사업 개발 등 시간이 걸리는 기업 자체적인 주가 동인</li>
      <li>하드 캐털리스트 : 실적 발표, 투자자의 날, 애널리스트의 날, 인수의향/인수합경 발표, 자사주 매입, 자산 매입/매각, 배당 뉴스, 경영진 또는 이사회 멤버 교체, 행동주의 헤지펀드 지분 업데이트 등 주가에 직접적인 영향을 미치고 구체적인 날짜와 재무적 영향을 미치는 실행 아이템이 있음</li>
      <li>소프트 캐털리스트 : 애널리스트의 투자 의견 변화, 관련 산업 규제, 신사업 개발, 신약/신상품시장 확대, 원자재 가격의 변동, 기타 기업에 영향을 미치는 매크로 변수의 변화 등 기점이 되는 특정 날짜나 기업의 구체적인 액션이 없어 간접적인 효과를 줌. 다른 주가 동인들과 복합적으로 작용하여 영향이 상쇄되기도 함</li>
    </ul>
  </li>
  <li>단기 캐털리스트의 대표 예는 어닝 시즌의 실적발표날로, 해당 날짜에 실적이 컨센서스보다 높게 나오는지, 낮게 나오는지에 따라 변동성이 크게 나타나며, 이를 노리고하는 어닝 플레이 전략도 있음. 단, 이 경우 목표 수익률 이상으로 주가가 움직였을 경우 반드시 수익실현을 해야 함. 주가가 금방 제자리를 찾아가는 경우가 많음. 투자자의 날이나 애널리스트 날에도 동일</li>
  <li>장기투자자들에게도 추가 매수 또는 수익실현을 위해 일부 자금을 움직일 기회가 되므로 이런 큰 촉매의 실현 여부가 결정되는 이벤트는 반드시 기억해야 하며, 예상대로 혹은 예상과 반대로 움직일 수 있으므로 목표 수익 실현 또는 손실 방어를 위해 익절 또는 손절 주문을 걸어두는게 좋음. 장기투자 기조에 영향을 주지 않은 촉매라도 주가가 단기적으로 왜 그렇게 크게 움직였는지는 이해할 수 있어야 리스크 관리가 가능함</li>
  <li>실적 발표 내용이 내 밸류에이션과 일치하지 않으면 포지션을 뒤집어야 할 수 있고, 반대로 밸류에이션에 변화가 없는데 시장이 이상할 정도로 과잉 반응했다면 추가매수/매도 실행</li>
</ul>

<h3 id="62-매크로거시경제-트레이딩">6.2 매크로(거시경제) 트레이딩</h3>
<ul>
  <li>개인 투자자는 적어도 시장을 움직이는 매크로 팩터들과 그게 내 포트폴리오에 어떤 영향을 미치는지 정도는 이해해야 함</li>
  <li>채권의 경우 10년물 국채(10-Year Treasury)를 주시. 일반적으로 채권 수익률이 상승하는 경우(금리 인하) 달러가 강세를 보임. 채권 수요가 커지면서 세계 자본이 미국 채권으로 몰리며 달러 수요도 증가하기 때문</li>
  <li>인플레이션 우려가 있을 경우 중앙은행이 긴축 통화정책(Tight Monetary Policy)를 시행하여 연방기금의 금리를 올려 통화 공급량을 줄이고 물가 상승폭 제한</li>
  <li>금리 상승기에는 기술성장주 등 롱 듀레이션 주식이 하락하고 가치주 등 숏 듀레이션 주식과 고배당주, 고수익 단기채는 상승. 주가는 미래 현금흐름(이익, 배당 등)을 현재가치로 환산한 값인데 롱 듀레이션 주식은 매출과 이익이 멀리 떨어진 시점에 주로 발생하므로 금리가 높을수록 가치가 하락</li>
  <li>인플레이션이 너무 가파르게 진행될 경우 보통 금, 원유, 원자재, 부동산 및 기타 등등 인플레이션에 대한 헤지 자산 수요가 급증하고 채권 가격도 하락
    <ul>
      <li>단, 원자재에 대한 공급 체인 이슈와 그로 인한 인플레이션으로 스테그플레이션이 일어날 경우 기업 실적 전망치가 하락하여 주식 시장이 무너지고 리스크 자산 수요 하락 -&gt; 더 안전한 국채로 수요가 몰려 채권 가격이 상승할 수 있음</li>
      <li>공급체인 이슈에는 코로나 19 같은 상황이나 중국의 내수/공급 지표 등이 영향을 끼침</li>
    </ul>
  </li>
  <li>기관투자자들은 가장 효율적인 인플레이션 방어자산으로 원자재를 꼽음. 원자재 선물 및 관련 주식에 투자하는 것.</li>
  <li>연준 의장의 금리 관련 발언이나 재무부 장관의 정책 방향성을 암시하는 발언에 따라 증시가 하락할 경우 매크로 쇼크에 의한 것. 이 경우에도 원자재 관련주, 에너지주들이 강세를 보임</li>
  <li>미국 시장에서는 애널리스트들이 분기별 보고서 외에 주요 매크로 이벤트나 매크로 쇼크가 있을 때도 수시로 매크로 전망 관련 보고서를 발표하므로 참고
    <ul>
      <li>키워드 : Macro Forecast, Macro Out-look, Commodities Futures, US 10YrBond Yield Outlook</li>
    </ul>
  </li>
  <li>벨웨더 주식(경제 전반적인 상황과 해당 섹터에 대한 선행지표 역할을 하는 주식)으로는 주로 경기순환주가 있음. 벨웨더 주식이 어닝 시즌에 좋은 실적을 발표한다는 것은 경제 상황이 호전되리라는 강한 시그널
    <ul>
      <li>이를 코로나 19 이수 증시에 적용해보면, 경제 재개 관련 뉴스 및 기대심리와 함께 다우 지수나 S&amp;P 500 지수가 상승한 것은 벨웨더 주식이 이끄는 경기순환주나 가치주 등의 주가 상승으로 인한 것</li>
      <li>인플레이션, 미국 정부 정책 방향성, 중앙은행의 통화정책 등 여러가지 매크로 상황에 따라 높은 상관관계로 움직이므로 기본적인 매크로 경제를 이해하고 주가 흐름을 읽을 수 있다면 중단기적 트레이딩 수익을 낼 수 있음</li>
      <li>항공/호텔 및 숙박업 주식들은 여행 수요는 물론 비즈니스 수요(호텔 산업 주요 수익원은 출장이나 콘퍼런스 등)를 가장 먼저 반영하므로 이들의 주가 추이는 전반적인 경기회복 또는 침체의 시그널을 줌. 또한 건설업, 건설장비 업체 역시 글로벌 경제 흐름을 선반영할 수 있으며 그외에도 섹터 별 먼저 시장의 방향성을 보여주는 기업들이 해당함</li>
    </ul>
  </li>
</ul>

<h3 id="63-상시적-변수에-대응하는-매매-전략">6.3 상시적 변수에 대응하는 매매 전략</h3>
<ul>
  <li>내 포트폴리오 변동성에 가장 큰 영향을 미치는 요인 중 하나가 기존 투자 종목과 높은 상관관계에 있는 다른 기업 주식들. 유사/경재 기업군들의 트레이딩을 파악하여 같은 방향으로 움직일 것인지, 반대 방향으로 움직일지 정도는 파악해야 함
    <ul>
      <li>어펌 홀딩스(분할 결제=BNPL를 지원하는 핀테크 기업)의 관련 기업으로 페이팔, 스퀘어, 애프터페이.. 카드사로는 비자, 마스터.. 더 넓은 범위에서는 애플페이, 구글페이 등이 있음. 그외에도 어펌 매출의 3분의 1이 상을 차지하는 펠로톤(고가 운동기구를 판매, 분할 결제가 잦음)도 관련이 있음</li>
      <li>어펌 자체적으로 특별한 이벤트나 공시가 없었으나 애플이 어펌을 견제하기 위해 골드만삭스와 파트너십을 맺어 BNPL 서비스 제공을 발표하며 주가가 하루에 10% 이상 하락</li>
      <li>그 다음달 스퀘어가 애프터페이 인수 건에 대하여 자사 IR 사이트와 SEC에 8-K, 보도자료를 공시하며 다음날 어펌 주가가 15% 가까이 폭등. 공시에 인수 목적이 BNPL 사업 확장 및 성장이라고 설명됨. 유사/경쟁 기업군의 두 기업이 인수합병을 발표하며 어펌 역시도 같은 목적으로 인수 대상이 될 가능성이 시사되고, 그렇지 않더라도 BNPL 비즈니스에 대한 시장 관심도가 높아졌기 때문</li>
    </ul>
  </li>
  <li>정기적 어닝 시즌 및 기업 주요 이벤트 외에 갑자기 뜬 뉴스 헤드라인 만으로도 주가가 크게 움직임. 이 변동 폭은 프리마켓과 애프터마켓에서 가장 큼</li>
  <li>8-K는 예기치 않은 상황에 대해 주주에게 보고하는 내용으로, SEC에 업로드됨과 동시에 보도 자료도 함께 공시됨. 어펌이 아마존과의 파트너십을 체결하여 앞으로 아마존에서 소비한 금액이 50달러 이상일 경우 어펌의 BNPL 모델에 따라 월 할부로 지불하게 되었다는 8-K 공시가 뜬 다음 거래일날, 주가가 50%이상 폭등한 적이 있음. 장기 투자자 입장에서도 일시적인 수익실현 기회로 볼 수 있음</li>
  <li>재무부 장관이 상원 청문회에서 국가 부도 위기를 언급했을 때 국채 금리가 상승(국가가 빛을 못 갚을까봐 국채 가격 하락 + 위험자산이 되버린 국채에게 프리미엄 요구 -&gt; 국채 금리 상승)하고 인플레이션 장기화 우려(정부가 돈이 부족해지면 중앙은행에 돈을 찍어내서 돈이 과도하게 풀릴 수 있음)가 겹쳐 금리에 민감한(인플레이션 때문에 정책 금리를 올릴수도 있음) 기술 성장주들이 급락함, 어펌의 경우 마스터 카드가 BNPL 시장에 뛰어든다는 뉴스로 매크로 팩터와 개별 주식 타격이라는 두 요소가 한꺼번에 작용해 악재</li>
  <li>매크로 변수에 의해 주가 변동성이 나타날 경우 특정 섹터 비중을 축소하거나 확대하는 방식으로 포트폴리오를 리밸런싱하는 게 좋음. 일시적인 변동성이 아닐 경우가 많음</li>
</ul>

<h3 id="64-어닝-시즌을-활용한-매매">6.4 어닝 시즌을 활용한 매매</h3>
<ul>
  <li>실적과 무관하게 섹터 단위로 시장이 부과하는 프리미엄이 높아지거나 낮아질 수 있음. 같은 섹터 내 특정 기업 매출 성장률이 눈에 띄게 높아지만 비교 기업 주가에 조정이 오기도 함</li>
  <li>실적 발표를 앞두고 미결제 약정액(시장에서 아직 청산되지 않고 남아있는 콜옵션과 풋옵션 계약의 총 개수)을 확인하여 전망을 알 수 있음. 콜옵션 체결 물량이 우세하면서 옵션 프리미엄 가격 또한 상승하고, 풋옵션 매도 포지션 신규 진입자가 증가(현재 주가에서 더 안내릴거라 배팅)했다면 실적에 대한 긍정적 투자자 정서가 반영된 것</li>
  <li>주가를 움직이는 실적 발표의 주요 포인트
    <ul>
      <li>당기 실적이 애널리스트 컨센서스를 넘어섰는지, 아니면 못미치는지?</li>
      <li>당기 실적이 경영진이 예상한 목표치, 가이던스를 달성했는지?</li>
      <li>실적 수치들에 반영 또는 미반영된 요소는 무엇이며, 그 이유는 무엇인지?</li>
      <li>경영진의 실적 가이던스에 어떤 변화가 있었는지?</li>
      <li>실적 외 사업에 영향을 미치는 새로운 뉴스가 있는지? (자산 매입/매각, 파트너십, 경영진 변경, 규제, 소송 등)</li>
      <li>검색 키워드 : Beat Estimate, Financial Outlook, Guidance, Revised Up/Down, Street Estimate/Consensus, Earnings Beat, Earnings Surprise, Fall Short of Expectations</li>
    </ul>
  </li>
  <li>실적이 기대치를 훨씬 넘어설 경우 프리마켓부터 형성된 매수세로 모든 뉴스가 선반영된 가격이 된 후 수익실현을 하는 단기 트레이더의 매도세에 의해 익일 주가에 조정이 오기도 함. 이런 상황에서 매매 손실을 줄이려면 지정가 주문을 걸어두거나 반대로 주가가 이미 충분히 상승한 만큼 차익 실현 세력을 예상하여 공매도를 취하는 방법이 있음</li>
</ul>

<h3 id="65-미국의-매매정지-제도">6.5 미국의 매매정지 제도</h3>
<ul>
  <li>Trading Halt : 미국 각 증권거래소에서 변동성이 심하거나 심할 것으로 예상되는 주식에 대해 5분 동안 매매를 정지시키는 것. Single Stock Circuit Breaker라고도 함</li>
  <li>Held at Open : 증권거래소에서 개장 직후 매매가 정지되도록 제한한 경우. 많은 기업들이 개장 전이나 장 마감 이후에 실적 발표나 8-K 공시 같은 중요 발표를 하는데, 투자자들이 내용을 충분히 숙지하고 트레이딩 결정을 내리게 하기 위함이나 매수/매도세가 한쪽으로 크게 기운 상태에서 주문 실행까지 지연되며 변동성이 더 증폭되기도 함</li>
  <li>Volatility Halt : 특정 주식 등락폭이 ATPR(거래가격 범위, 지난 5분 동안 거래된 주가의 평균 가격이 기준)를 넘어선 수준에서 15초 이상 거래가 지속될 경우 5분동안 취해지는 매매정지. 일반 우량주 기준 개장 후 15분과 장 마감 이전 25분까지는 ATPR을 10%이상 벗어난 경우, 그외에는 5% 이상 벗어난 경우 시행됨</li>
  <li>News Halts : 주가 등락폭이 클 것으로 예상되는 특정 캐털리스트 발표를 앞두고 기업 측에서 해당 증권거래소에 직접 요청해 이뤄지는 매매정지. 공시 직후 주가가 요동치는걸 방지하기 위함으로, 이런 경우 8-K 공시가 뜸</li>
  <li>Compliance Halts : SEC, FINRA 같은 규제 당국과 NYSE, NASDAQ, AMEX 등의 증권거래소 자체적으로 규제상의 이유를 들어 매매정지. 대표적으로 상장폐지 발표, 비정상적 매매에 대한 조사 착수, 의무 공시 자료 누락 등의 예가 있음. 이런 종류의 매매정지는 악재로 작용하여 정지가 풀린 후 주가 폭락</li>
  <li>Circuit Breaker : 개별주에 대한 상/하방 변동성 약화가 아닌, 증권거래소에서 증시 폭락사태 발생 시 증시 전체에 대해 시행하는 매매정지. 강도에 따라 레벨 1, 2, 3으로 나뉘며 레벨 1은 S&amp;P500 지수 7% 이상 하락, 레벨2는 13%이상 하락, 레벨3은 20% 이상 하락 시 시행됨. 미국 동부 시간으로 오후 3시 25분까지 레벨 1, 2 서킷 브레이커 발동가능. 레벨 3에서는 아예 그날 매매가 종료됨</li>
  <li>Uptick Rule : 공매도의 남용이나 공매도 자체로 인한 하락 모멘텀을 제한하여 낙폭이 심한 변동성을 줄이기 위해, 숏 셀링 서킷 브레이커가 발동한 주식은 그다음 거래일까지 자동으로 업틱 룰이 적용됨. 업틱 룰 발동 시 해당 주식의 공매도는 현재 주가보다 높은 가격으로만 가능함
    <ul>
      <li>공매도는 버블 제거를 통한 적정 가격 형성이라는 순기능도 있으나, 주가 폭락을 겨냥하고 의도적인 공매도 공시를 하는 숏 셀러가 있을 수 있음</li>
      <li>어느 헤지펀드가 공매도 포지션을 잡았다는 뉴스가 뜨면 그 헤드라인 자체만으로 주주에게 악재. 기관투자자는 개인투자자보다 정보상 우위에 있다는 인식때문에 개인투자자들의 매도를 유발하기도 함</li>
      <li>숏 셀링 서킷 브레이커는 해당 거래일 장중 하락폭이 전일 종가(마감가격) 대비 10% 이상일 때 발동</li>
      <li>증권 매매 플랫폼에서 급등률이 높은 순, 급락률이 높은 순으로 주식 리스트들을 나열해 보면 빨간색으로 Warning 심볼이 붙어 있는 게 있음. 업틱 룰이 적용된 주식이라는 의미로, 급락률이 높은 주식뿐만아니라 급상승 주식에도 종종 붙어있는데, 대게 이전 거래일에 주가가 많이 빠져서 업틱 룰이 발동하고 이튿날 회복을 넘어 급등세를 보인 것. 단순히 급등한 주식을 매수하고 급락한 주식을 매도 및 공매도하는 건 이미 주가를 움직인 모멘텀이 반영되어 있는 경우가 많아 위험함</li>
    </ul>
  </li>
</ul>

<h3 id="66-개인투자자-필수-레퍼런스로-유용한-미국-주식-사이트">6.6 개인투자자 필수 레퍼런스로 유용한 미국 주식 사이트</h3>
<ul>
  <li>SEC 기업 공시자료 열람
    <ul>
      <li>BAMSEC : bamsec.com</li>
      <li>EDGAR : sec.gov</li>
    </ul>
  </li>
  <li>전반적인 시황, 매크로 뉴스 확인
    <ul>
      <li>Bloomberg : bloomberg.com</li>
      <li>CNBC : cnbc.com</li>
      <li>CNN business : edition.cnn.com/business</li>
      <li>Market Watch : marketwatch.com</li>
    </ul>
  </li>
  <li>애널리스트 투자 의견과 컨센서스 수치 확인
    <ul>
      <li>Benzinga : benzinga.com</li>
      <li>Finviz : finviz.com</li>
      <li>Google Finance : google.com/finance</li>
      <li>Investing.com : investing.com</li>
      <li>Koyfin : koyfin.com</li>
      <li>MarketBeat : marketbeat.com/stocks</li>
      <li>TradingView : tradingview.com</li>
      <li>Yahoo!Finance : Finance.yahoo.com</li>
    </ul>
  </li>
  <li>종목 스크리닝과 재무제표 정리
    <ul>
      <li>Macrotrends : macrotrends.net</li>
      <li>Stockrow.com : stockrow.com</li>
    </ul>
  </li>
  <li>헤지펀드 및 유명 기관투자자들의 포트폴리오(일부) 확인
    <ul>
      <li>Gurufocus : gurufocus.com</li>
      <li>WhaleWisdom : Whalewisdom.com</li>
    </ul>
  </li>
  <li>개별 종목 분석과 투자 아이디어 제공
    <ul>
      <li>Finbos : finbox.com</li>
      <li>MarketScreener : marketscreener.com</li>
      <li>Seeking Alpha : seekingalpha.com</li>
      <li>The Motley Fool : fool.com</li>
      <li>VIC : valueinvestorsclub.com</li>
    </ul>
  </li>
  <li>개별 종목 혹은 펀드의 기술적 분석
    <ul>
      <li>Barchart : barchart.com</li>
      <li>MorningStar : morningstar.com</li>
      <li>StockChart : stockcharts.com</li>
      <li>Zachs : zacks.com</li>
    </ul>
  </li>
  <li>ETF 관련 사이트
    <ul>
      <li>ETF database : etfdb.com</li>
      <li>ETF Trends : etftrends.com</li>
    </ul>
  </li>
  <li>배당주 관련 사이트
    <ul>
      <li>Dividend.com : dividend.com</li>
      <li>Dividend Investor : dividendinvestor.com</li>
    </ul>
  </li>
  <li>기업 실적 발표와 캘린더 제공
    <ul>
      <li>Alpha Street : news.alphastreet.com</li>
      <li>Earnings Whisper : earningswhispers.com</li>
      <li>Fidelity eResearch : eresearch.fidelity.com/eresearch/goto/conferenceCalls.jhtml</li>
      <li>TipRanks : tipranks.com</li>
    </ul>
  </li>
  <li>IPO와 SPAC, 비장상 기업 관련 사이트
    <ul>
      <li>CB Insights : cbinsights.com/research-unicorn-companies</li>
      <li>Nasdaq IPO : nasdaq.com/market-activity/ipos</li>
      <li>NYSE IPO : nyse.com/ipo-center/filings</li>
      <li>SPAC Analytics : spacanalytics.com</li>
      <li>SPAC Insider : spacinsider.com</li>
      <li>SPAC Research : spacresearch.com</li>
    </ul>
  </li>
  <li>포트폴리오 시뮬레이션
    <ul>
      <li>Portfolio Visualizer : portfoliovisualizer.com</li>
    </ul>
  </li>
  <li>매크로 경제 지표
    <ul>
      <li>Fed : federalreserve.gov/releases/h15</li>
      <li>FRED : fred.stlouisfed.org</li>
    </ul>
  </li>
</ul>]]></content><author><name>Toyo</name></author><category term="Investments" /><category term="U.S. stocks" /><summary type="html"><![CDATA[1. 미국 주식시장 구조 미국 주식시장은 3개의 시장 플레이어로 구성됨. 미국증권거래위원회(SEC) : 매매 관리 감독, 규제. 셀사이드 : 유가 증권을 유통하는 증권사. 미국에서는 투자은행IB가 담당. 매매 중개자이자 딜러에 속함. 바이사이드 : 투자 대상을 선별해 자산을 투자하는 운용 주체. 개인 또는 외부 투자자의 자금을 운영하는 펀드회사. 헤지펀드, 사모펀드, 자산운용자, 보험사 등 을의 입장인 셀사이드는 갑인 바이사이드에게 매매 수수료를 받는 대신 기본 매매 업무뿐 아니라 기업 연계 서비스도 제공 셀사이드 애널리스트 : 증권사, 투자은행 등에서 일하며 기업 분석 리포트를 작성하고 기관/개인에게 투자 의견을 제공. 투자자의 셀사이드 리서치 의존도가 예전에 비해 낮아지자 증권사 측에서는 셀사이드 애널리스트를 줄이는 추세 바이사이드 애널리스트 : 연기금, 자산운용사, 보험사, 헤지펀드 등에서 내부 투자 판단을 위한 분석을 수행하는 전문가. 외부에 분석 결과를 공개하지 않음 공시 자료를 정확히 이해하고 미래 손익을 추정하는 작업이 어려운 이유는 기업이 보고한 숫자를 그대로 받아들여서는 안되기 때문. 기업이 특정 비용을 예외로 간주해 누락한 이유가 무엇인지, 의도적으로 제외한 요소는 없는지, 경영진이 말하는 계속사업이익은 정말 지속가능한지, 재무상태표에 숨은 부채나 자산은 없는지 등 합리적인 의심 요소는 수없이 많음 특별손익(Extraorinary Gains,/Losses), 일회성 비용(One-time Expenses; Non-recurring Charges) 같은 용어가 보이면 그 항목의 자금흐름을 정확히 이해할 필요가 있음. 회계기준을 위반하지 않으면서 경영진이 보여주고 싶은 부분만 보여주고 특정 비용을 잘 포장해 재무제표상의 숫자를 크게 왜곡할 수 있음]]></summary></entry><entry><title type="html">SSE</title><link href="/cs/2025/01/01/SSE.html" rel="alternate" type="text/html" title="SSE" /><published>2025-01-01T00:00:00+00:00</published><updated>2025-01-01T00:00:00+00:00</updated><id>/cs/2025/01/01/SSE</id><content type="html" xml:base="/cs/2025/01/01/SSE.html"><![CDATA[<h2 id="1-실시간-웹의-필요성과-통신-기술">1. 실시간 웹의 필요성과 통신 기술</h2>

<h3 id="11-실시간-페이지의-필요성-및-활용-사례">1.1 실시간 페이지의 필요성 및 활용 사례</h3>

<ul>
  <li><strong>실시간 페이지</strong>는 사용자가 페이지를 새로고침하지 않고도 실시간으로 데이터를 확인할 수 있게 합니다.</li>
  <li>주요 활용 사례:
    <ul>
      <li><strong>주식 시장</strong>: 실시간으로 주가 변동 정보를 제공.</li>
      <li><strong>채팅 애플리케이션</strong>: 새로운 메시지를 즉시 전송 및 수신.</li>
      <li><strong>라이브 알림 시스템</strong>: 긴급 알림, 주문 상태 업데이트 등 실시간 알림 제공.</li>
      <li><strong>게임 및 스포츠 이벤트</strong>: 점수, 진행 상황 등의 실시간 업데이트.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="12-실시간-서버-클라이언트-통신-기술">1.2 실시간 서버-클라이언트 통신 기술</h3>

<h4 id="121-long-polling">1.2.1 Long-Polling</h4>
<ul>
  <li><strong>개념</strong>:
    <ul>
      <li>클라이언트가 서버에 요청을 보내고, 새로운 데이터가 준비될 때까지 서버가 응답을 지연시킴.</li>
      <li>새로운 데이터가 준비되면 서버는 응답을 반환, 클라이언트는 즉시 새로운 요청을 보냄.</li>
    </ul>
  </li>
  <li><strong>특징</strong>:
    <ul>
      <li>실시간 데이터를 제공할 수 있지만, <strong>불필요한 요청/응답 반복</strong>으로 비효율적.</li>
      <li>각 데이터 전송마다 새로운 연결을 설정해야 하므로 서버와 클라이언트 모두 리소스를 많이 사용.</li>
    </ul>
  </li>
</ul>

<h4 id="122-websocket">1.2.2 WebSocket</h4>
<ul>
  <li>클라이언트-서버 간의 양방향 통신</li>
  <li>양방향 연결이므로 3-way handshake 필요. 핸드셰이크가 성공하면 HTTP 연결을 WebSocket으로 프로토콜 전환</li>
  <li>연결이 여전히 사용 가능한지에 대한 확인 및 재연결 처리 로직을 직접 구현해야 함</li>
  <li>라이브 채팅, 게임, 금융 거래 플랫폼 등 지연 시간이 짧고 빈번한 업데이트가 필요한 경우 사용</li>
</ul>

<h4 id="123-웹-트랜스-포트-api">1.2.3 웹 트랜스 포트 API</h4>
<ul>
  <li>웹소켓과 마찬가지로 양방향 통신</li>
  <li>웹 클라이언트와 서버 간의 효율적이고 지연 시간이 짧은 통신을 위해 설계된 최첨단 API</li>
  <li>HTTP/3와 QUIC 프로토콜을 기반으로 함. QUIC는 기본적으로 UDP를 사용하지만, 신뢰성 있는 데이터 전송을 위해 TCP와 유사한 기능을 제공</li>
  <li>여러 개의 스트림을 통해 동시에 여러 파일이나 데이터를 보낼 수 있음</li>
  <li>웹 트랜트 포트 API가 매우 복잡하기 소스 코드에서 직접 웹 트랜스포트를 사용하기 보다 웹 트랜스포트를 기반으로 한 라이브러리 사용 필요</li>
  <li>하나의 연결 안에서 단방향과 양방향 스트림 모두에 대해 높은 처리량을 지원하며, 여러 스트림이 필요한 시나리오에서 웹 소켓보다 우수한 성능을 발휘할 것으로 예상</li>
  <li>Node.js를 포함한 다른 서버 프레임워크에서 널리 지원되지 않고, safari와의 호환성이 떨어지기 때문입니다. 게다가 이 기술은 HTTP/3에 의존하는데, nginx와 같은 많은 웹서버들은 HTTP/3 연결을 아직 실험적으로 제공</li>
</ul>

<h4 id="124-server-sent-events-sse">1.2.4 Server-Sent Events (SSE)</h4>
<ul>
  <li>http를 통해 서버 -&gt; 클라이언트로 단방향 통신</li>
  <li>라이브 뉴스 피드, 스포츠 점수 등 서버 -&gt; 클라이언트 단방향으로의 실시간 업데이트에 적합</li>
  <li>클라이언트에서 이벤트를 생성하는 서버의 url로 EventSource 인스턴스 초기화, 해당 인스턴스에 이벤트 핸들러(onMessage)달아 수신</li>
  <li>서버 측에서는 스크립트에 반드시 Content-Type 헤더가 text/event-stream으로 설정되어 있어야 하고, 각 메시지를 SSE 사양에 맞춰야 함
    <ul>
      <li>이 사양은 이벤트 타입, 데이터 페이로드를 명시해야 하고 이벤트 ID나 재시도 타이밍 등의 선택적인 필드를 포함</li>
    </ul>
  </li>
  <li>클라이언트에서 서버로 요청을 보내 연결을 맺고, 이후 서버에서 필요할 때마다 연결된 클라이언트들로 데이터 전송</li>
  <li>연결이 끊길 경우 클라이언트의 EventSource 객체에서 Last-Event-ID 헤더를 통해 서버에 마지막으로 수신한 이벤트 ID를 전달하여 자동 재연결</li>
  <li>기본 EventSource API를 사용하면 http 본문에서 POST와 같은 데이터를 보낼 수 없어 모든 데이터를 URL 파라미터에 포함해야 함
    <ul>
      <li>기본 EventSource API 대신 eventsource polyfill 라이브러리를 사용하면 커스텀 http 헤더를 보내는 등의 추가 기능을 제공</li>
      <li>본문 데이터를 전송하고 GET 대신 POST 요청을 사용할 수 있는 Microsoft의 fetch-event-source 라이브러리도 있음</li>
    </ul>
  </li>
  <li>대부분의 최신 브라우저는 도메인 당 6개의 연결을 허용하므로 모든 안정적인 서버-클라이언트 메시징 방법의 사용성이 제한됨
    <ul>
      <li>HTTP를 통해서 할 때는 브라우저당 6개 까지 가능 / HTTP2로는 100개가 기본?</li>
      <li>열려 있는 탭 수에 상관없이 하나의 연결만 열어서 탭 간에 공유하는 방식으로 해결 가능 broadcast-channel npm 패키지의 LeaderElection</li>
    </ul>
  </li>
  <li>IE 브라우저에선 SSE를 지원하지 않지만? polyfills 이용하여 해결 가능</li>
  <li>회사에서 프록시와 방화벽에 비 HTTP 연결을 차단하기 때문에 Server-Sent Events나 롱폴링이 더 사용하기 쉬움</li>
  <li>웹 소켓보다 오버헤드가 적어서 많은 클라이언트에게 메시지를 브로드캐스팅하는 데에 효율적. 그에 따라 서버에서 클라이언트로의 단방향 통신에서 처리량이 더 높을 수 있음
    <ul>
      <li>http 프로토콜을 사용하기 때문에 http -&gt; 웹소켓 프로토콜을 위한 핸드셰이크 작업이 필요 없음</li>
      <li>연결 상태 확인 로직 필요 없음</li>
      <li>데이터 전송 방식이 http로 WebSocket 프레임 포맷보다 단순함</li>
      <li>소켓 연결 방식은 서버에서 클라이언트마다 고유한 소켓 리소스를 소모</li>
    </ul>
  </li>
  <li>웹 소켓과 달리 프로토콜 업데이트 같은 작업 없이 “일반” HTTP 요청을 사용하기 때문에 확장성이 좋음</li>
  <li>클라이언트 재연결 시 이벤트를 놓칠 수 있음. 이벤트를 놓쳐선 안되는 경우 서버에 이벤트들을 버퍼링하거나 저장해둬야 할 수 있음</li>
</ul>

<hr />

<h2 id="2-sse의-데이터-전송-방식과-제약">2. SSE의 데이터 전송 방식과 제약</h2>

<h3 id="21-sse의-데이터-전송-방식">2.1 SSE의 데이터 전송 방식</h3>
<h3 id="22-sse와-다른-실시간-통신-기술-비교">2.2 SSE와 다른 실시간 통신 기술 비교</h3>
<h3 id="23-sse의-제약">2.3 SSE의 제약</h3>

<hr />

<h2 id="3-sse-구현">3. SSE 구현</h2>

<h3 id="31-spring-boot-js-환경에서-sse-통신-구현-방법">3.1 Spring Boot, JS 환경에서 SSE 통신 구현 방법</h3>

<h3 id="32-간단한-실시간-웹-예제">3.2 간단한 실시간 웹 예제</h3>]]></content><author><name>Toyo</name></author><category term="CS" /><category term="SSE" /><summary type="html"><![CDATA[1. 실시간 웹의 필요성과 통신 기술]]></summary></entry></feed>