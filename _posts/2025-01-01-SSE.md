---
layout: post
title: SSE
subtitle: SSE 발표 조사 자료
categories: CS
tags: [SSE]
---

## 1. 실시간 웹의 필요성과 통신 기술 

### 1.1 실시간 페이지의 필요성 및 활용 사례 


- **실시간 페이지**는 사용자가 페이지를 새로고침하지 않고도 실시간으로 데이터를 확인할 수 있게 합니다.
- 주요 활용 사례:
  - **주식 시장**: 실시간으로 주가 변동 정보를 제공.
  - **채팅 애플리케이션**: 새로운 메시지를 즉시 전송 및 수신.
  - **라이브 알림 시스템**: 긴급 알림, 주문 상태 업데이트 등 실시간 알림 제공.
  - **게임 및 스포츠 이벤트**: 점수, 진행 상황 등의 실시간 업데이트.

---

### 1.2 실시간 서버-클라이언트 통신 기술

#### 1.2.1 Long-Polling
- **개념**:
  - 클라이언트가 서버에 요청을 보내고, 새로운 데이터가 준비될 때까지 서버가 응답을 지연시킴.
  - 새로운 데이터가 준비되면 서버는 응답을 반환, 클라이언트는 즉시 새로운 요청을 보냄.
- **특징**:
  - 실시간 데이터를 제공할 수 있지만, **불필요한 요청/응답 반복**으로 비효율적.
  - 각 데이터 전송마다 새로운 연결을 설정해야 하므로 서버와 클라이언트 모두 리소스를 많이 사용.

#### 1.2.2 WebSocket
- 클라이언트-서버 간의 양방향 통신
- 양방향 연결이므로 3-way handshake 필요. 핸드셰이크가 성공하면 HTTP 연결을 WebSocket으로 프로토콜 전환
- 연결이 여전히 사용 가능한지에 대한 확인 및 재연결 처리 로직을 직접 구현해야 함
- 라이브 채팅, 게임, 금융 거래 플랫폼 등 지연 시간이 짧고 빈번한 업데이트가 필요한 경우 사용

#### 1.2.3 웹 트랜스 포트 API
- 웹소켓과 마찬가지로 양방향 통신
- 웹 클라이언트와 서버 간의 효율적이고 지연 시간이 짧은 통신을 위해 설계된 최첨단 API
- HTTP/3와 QUIC 프로토콜을 기반으로 함. QUIC는 기본적으로 UDP를 사용하지만, 신뢰성 있는 데이터 전송을 위해 TCP와 유사한 기능을 제공
- 여러 개의 스트림을 통해 동시에 여러 파일이나 데이터를 보낼 수 있음
- 웹 트랜트 포트 API가 매우 복잡하기 소스 코드에서 직접 웹 트랜스포트를 사용하기 보다 웹 트랜스포트를 기반으로 한 라이브러리 사용 필요
- 하나의 연결 안에서 단방향과 양방향 스트림 모두에 대해 높은 처리량을 지원하며, 여러 스트림이 필요한 시나리오에서 웹 소켓보다 우수한 성능을 발휘할 것으로 예상
-  Node.js를 포함한 다른 서버 프레임워크에서 널리 지원되지 않고, safari와의 호환성이 떨어지기 때문입니다. 게다가 이 기술은 HTTP/3에 의존하는데, nginx와 같은 많은 웹서버들은 HTTP/3 연결을 아직 실험적으로 제공

#### 1.2.4 Server-Sent Events (SSE)
- http를 통해 서버 -> 클라이언트로 단방향 통신
- 라이브 뉴스 피드, 스포츠 점수 등 서버 -> 클라이언트 단방향으로의 실시간 업데이트에 적합
- 클라이언트에서 이벤트를 생성하는 서버의 url로 EventSource 인스턴스 초기화, 해당 인스턴스에 이벤트 핸들러(onMessage)달아 수신
- 서버 측에서는 스크립트에 반드시 Content-Type 헤더가 text/event-stream으로 설정되어 있어야 하고, 각 메시지를 SSE 사양에 맞춰야 함
  -  이 사양은 이벤트 타입, 데이터 페이로드를 명시해야 하고 이벤트 ID나 재시도 타이밍 등의 선택적인 필드를 포함
- 클라이언트에서 서버로 요청을 보내 연결을 맺고, 이후 서버에서 필요할 때마다 연결된 클라이언트들로 데이터 전송
- 연결이 끊길 경우 클라이언트의 EventSource 객체에서 Last-Event-ID 헤더를 통해 서버에 마지막으로 수신한 이벤트 ID를 전달하여 자동 재연결
- 기본 EventSource API를 사용하면 http 본문에서 POST와 같은 데이터를 보낼 수 없어 모든 데이터를 URL 파라미터에 포함해야 함
  - 기본 EventSource API 대신 eventsource polyfill 라이브러리를 사용하면 커스텀 http 헤더를 보내는 등의 추가 기능을 제공
  - 본문 데이터를 전송하고 GET 대신 POST 요청을 사용할 수 있는 Microsoft의 fetch-event-source 라이브러리도 있음
- 대부분의 최신 브라우저는 도메인 당 6개의 연결을 허용하므로 모든 안정적인 서버-클라이언트 메시징 방법의 사용성이 제한됨
  - HTTP를 통해서 할 때는 브라우저당 6개 까지 가능 / HTTP2로는 100개가 기본?
  - 열려 있는 탭 수에 상관없이 하나의 연결만 열어서 탭 간에 공유하는 방식으로 해결 가능 broadcast-channel npm 패키지의 LeaderElection
- IE 브라우저에선 SSE를 지원하지 않지만? polyfills 이용하여 해결 가능
- 회사에서 프록시와 방화벽에 비 HTTP 연결을 차단하기 때문에 Server-Sent Events나 롱폴링이 더 사용하기 쉬움
- 웹 소켓보다 오버헤드가 적어서 많은 클라이언트에게 메시지를 브로드캐스팅하는 데에 효율적. 그에 따라 서버에서 클라이언트로의 단방향 통신에서 처리량이 더 높을 수 있음
  - http 프로토콜을 사용하기 때문에 http -> 웹소켓 프로토콜을 위한 핸드셰이크 작업이 필요 없음
  - 연결 상태 확인 로직 필요 없음
  - 데이터 전송 방식이 http로 WebSocket 프레임 포맷보다 단순함
  - 소켓 연결 방식은 서버에서 클라이언트마다 고유한 소켓 리소스를 소모
- 웹 소켓과 달리 프로토콜 업데이트 같은 작업 없이 “일반” HTTP 요청을 사용하기 때문에 확장성이 좋음
- 클라이언트 재연결 시 이벤트를 놓칠 수 있음. 이벤트를 놓쳐선 안되는 경우 서버에 이벤트들을 버퍼링하거나 저장해둬야 할 수 있음

---

## 2. SSE의 데이터 전송 방식과 제약

### 2.1 SSE의 데이터 전송 방식
### 2.2 SSE와 다른 실시간 통신 기술 비교
### 2.3 SSE의 제약

---

## 3. SSE 구현

### 3.1 Spring Boot, JS 환경에서 SSE 통신 구현 방법

### 3.2 간단한 실시간 웹 예제
