---
layout: post
title: 자바 기초 정리2 (자바의 신 vol.2)
subtitle: 자바의 신 vol.2을 참고하여 자바 기초 문법 정리 및 보완
categories: CS
tags: [java]
---

## 1. 자바 역사와 JVM

### 1.1 자바 명칭의 역사
- 1996년 JDK 1.0 출시. 이후 출시된 JDK 1.1에서는 JavaBeans, JDBC, 원격 JVM에 있는 메소드를 호출하기 위한 RMI(자바 원격 메소드 호출)가 추가됨
- 1998년 12월 명칭이 변경된 J2SE 1.2(Java 2 Standard Edition) 출시. 기업에서 만드는 시스템을 개발하기 위한 Enterprise 에디션과 블랙베리와 같은 전화기에서 사용하고 있는 J2ME와의 혼동을 막기 위해 명칭 변경
    - JIT(Just-In-Time)가 추가됨. JIT는 자주 사용되는 바이트코드를 실행 중에 네이티브 코드로 컴파일하여
이후에는 인터프리팅 없이 바로 실행할 수 있도록 하여 성능을 향상
    - JVM의 실행 방식은 인터프리터 + JIT 하이브리드 구조 : JVM은 바이트코드를 인터프리터를 통해 실행하며, 실행 중 자주 호출되는 코드는 JIT 컴파일러가 기계어로 변환하여 성능을 향상시킴
    - JIT는 자바와 .NET이라는 언어에서 사용
- J2SE 1.3에서는 HotSpot JVM, JNDI가 추가됨. JNDI는 어떤 객체를 쉽게 찾을 수 있도록 도와주는 이름을 지정하여 나중에 그 이름으로 객체를 찾아감
    - HotSpot 컴파일러
        - 예전에는 cpu 코어가 제한적이었기에 애플리케이션 시작 시간을 빠르게 하고 적은 메모리를 점유하는 클라이언트 컴파일러와 코어가 많은 장비에서 애플리케이션을 돌리기 위한 서버 컴파일러를 따로 제공했음
        - 자바가 시작할 때 장비의 스펙을 확인하여 알아서 클라이언트 장비인지 서버 장비인지를 구분함. 명시적으로 지정하려면 java 명령 실행 시 -client, -server 옵션을 주면 됨
- J2SE 1.4에서는 정규식, NIO가 추가됨. NIO는 이전 버전까지의 IO를 처리할 때 사용한 java.io 패키지에서 제공하는 기능의 단점을 보완하기 위한 것으로, 기존 IO보다 성능이 훨씬 더 빠름
- J2SE 1.5 버전부터는 앞의 1.을 빼고 J2SE 5라고 호칭. 이전 버전과 많은게 달라짐
    - 제네릭
    - 어노테이션
    - 기본 자료형과 기본 자료형을 객체로 다루는 클래스 간의 데이터 변환이 자동으로 발생하는 autoboxing/unboxing 기능
    - enum, 매개 변수의 개수를 가변적으로 선언하는 varargs
    - 향상된 for 루프
    - static import
    - 스레드 처리를 쉽게 하는 java.util.concurrent 패키지
    - Scanner 클래스
- 이후 출시된 Java SE 6 부터는 호칭을 쉽게하기 위해 Java에서 2가 빠짐. Java SE 6까지는 Sun Microsystems에서 만들었지만, Java SE 7부터는 Oracle이 인수하여 관리
- Java SE 8에서는 람다 표현식 사용이 가능해짐
- 명칭이 계속 변경되었지만 일반적으로 JDK 1 ~ 1.4, Java 5 ~ 로 호칭 가능
- Oracle에서 관리하는 것 외에도 IBM, HP에서 각각의 운영체제에 맞게 최적화 된 JDK를 개발하여 사용하고 있음. 이 외에도 몇가지 JDK가 더 있는데, 소스에 라이선스 문제가 되는 부분을 제거한 완전 오픈소스 Open JDK도 있음
- 각 Java 버전에서 제공되어야 하는 표준 문서가 만들어지면 그 기준에 해당하는 각 벤더에 맞는 JDK가 별도로 만들어짐. 어떤 OS에서 개발하든 JRE 버전만 맞으면 적용할 OS가 달라도 앱 실행 가능
- 본인이 사용하는 JDK에서 어떤 것이 제공되고, 제공 안 되는지 정도는 확인해두는게 좋음

### 1.2 자바 언어의 특징
- 자바는 단순하고 객체지향적이며 친숙해야 함
    - 다른 언어를 배운 사람이라면 자바에 대한 기본 컨셉을 배우는 것이 어렵지 않음
    - 처음 만들때부터 객체지향으로 디자인 된 언어
    - 개발하면서 필요한 여러 기능들을 라이브러리를 통해 쉽게 개발 가능

- 자바는 견고하며 보안상 안전함
    - 자바는 컴파일할 때와 실행할 때 문법적 오류에 대한 체크를 함. 메모리 관리 모델이 매우 단순하고 복잡한 포인터의 개념이 없음. 이러한 특징들이 자바를 믿을 수 있고 견고한 소프트웨어가 될 수 있게 해줌
    - 자바는 분산환경에서 사용하기 위해 설계되었기 때문에 보안이 매우 중요함. 따라서 외부에서 침입이 불가능한 애플리케이션을 만들 수 있고 네트위크 환경에서 클라이언트로 다운로드 한 승인받지 않은 프로그램은 실행할 수 없게 되어 있음. 단, 내부 오류로 인해 보안 취약점이 발견되기도 함
- 자바는 아키텍처에 중립적이어야 하며 포터블 해야 함
    - 자바는 아키텍처에 중립적인 바이트 코드를 생성
    - 기본 데이터 타입의 크기를 지정해 놓고 숫자 연산자에 대한 행위들을 정의해 둠. 따라서 프로그램이 어떤 플랫폼에서도 동일한 결과가 나오고 하드웨어/소프트웨어 아키텍처에 따른 데이터 타입의 호환성에 문제가 발생하지 않음
- 자바는 높은 성능을 제공해야 함
    - 실행환경에서 최대한의 성능을 냄. 자동화된 가비지 컬렉터는 낮은 우선 순위의 스레드로 동작함
    - 네이티브한 언어로 작성한 부분을 자바에서 사용할 수 있도록 되어있음
- 자바는 인터프리트 언어이며 스레드를 제공하고 동적인 언어임
    - 자바 컴파일러는 컴파일 시 매우 엄격한 정적인 점검을 수행하고 실행 시에 동적으로 필요한 프로그램들을 링크시킴. 이후 실행단계에서 인터프리터+JIT를 사용하여 코드를 실행

### 1.3 JVM과 GC
- JVM은 개발자가 작성한 자바 프로그램이 수행되는 프로세스. 자바에선 메모리 관리를 JVM이 알아서 해주는데 이것을 가비지 컬렉터(GC)라고 부름
- JVM은 아래와 같이 영역을 나눠 힙이라는 공간에 객체들을 관리함. 가장 왼쪽에 있는 Young 영역에는 젊은 객체들이, Old 영역에는 늙은 객체들이 자리잡으며 Perm 영역에는 클래스나 메소드에 대한 정보가 쌓임
![힙구조](/assets/images/힙구조.png)
- Young 영역은 Eden과 2개의 Survivor 영역으로 나뉘는데 객체를 생성하자마자 저장되는 장소는 Eden. 일반적으로 자바에서 메모리가 살아가는 과정은 아래와 같음
    1. Eden 영역에서 객체가 생성됨
    2. Eden 영역이 꽉 차면 살아있는 객체만 다른 Survivor 영역으로 객체가 복사됨. Eden 영역에 있는 객체들 중 살아있는 객체들도 다른 Survivor 영역으로 감. 따라서 Survivor 영역의 둘 중 하나는 반드시 비어있게 됨 -> Young GC
    3. 오래 살아있는 객체들은 Old 영역으로 가며 지속적으로 이동하다가 Old 영역이 꽉찰 때 GC가 발생 -> Old GC

## 2. java.lang 패키지

### 2.1 개요
- 자바의 패키지 중에서 유일하게 java.lang 패키지에 있는 클래스들은 import 없이 사용 가능. 자바에서 꼭 필요한 여러 기능들을 제공
- 언어 관련 기본적인것, 문자열 관련, 기본 자료형 및 숫자 관련, 스레드 관련, 예외/런타임 관련하여 인터페이스, 클래스, 예외 클래스 등을 제공함
- 예외 중 알아둬야 할 2가지로 OutOfMemortError와 StackOverflowError가 있음. 
    - 자바는 가상 머신에서 메모리를 관리하지만 프로그램을 잘못 작성하거나 설정이 제대로 되어 있지 않을 경우 OutOfMemortError가 발생 가능
    - StackOverflowError는 호출된 메소드의 깊이가 너무 깊을 때 발생하는 에러. 자바에서는 스택 영역에 어떤 메소드가 어떤 메소드를 호출했는지에 대한 정보를 관리하는데 재귀 메소드를 잘못 작성할 경우 스택에 쌓이는 메소드가 호출 정보의 한계를 넘어설 수도 있음
- 1편에서 언급된 자바의 기본 어노테이션인 Deprecated, Override, Suppress Warnings도 선언되어 있음

### 2.2 숫자를 처리하는 클래스
- 자바에서 기본 자료형은 힙 영역이 아닌 스택 영역에 저장되어 관리됨. 따라서 계산할 때 보다 빠른 처리 가능
- 기본 자료형의 숫자를 객체로 처리해야 할 필요가 있을 경우, 자바에서 제공하는 기본 자료형처럼 선언되어 있는 클래스들이 있음. 대부분 기본 자료형에서 첫 문자만 대문자로 바뀜
    - Byte
    - Short
    - Integer
    - Long
    - Float
    - Double
    - Character
    - Boolean
- Character, Boolean을 제외한 숫자를 처리하는 클래스들은 Wrapper 클래스라 불리며 모두 Number라는 추상클래스를 확장함
- Wrapper 클래스는 자바 컴파일러에서 자동 형 변환을 해주기 때문에 참조 자료형이지만 기본 자료형처럼 사용 가능. 따라서 new를 사용하여 객체를 만들지 않아도 값을 할당할 수 있으며, String 클래스나 기본 자료형이 아님에도 + 연산가능
- Character 클래스 빼고 모두 parse타입이름() 메소드와 valueOf() 메소드를 제공함. 둘다 String과 같은 문자열을 숫자 타입으로 변환한다는 공통점이 있으나 parse는 기본 자료형을, valueOf는 참조 자료형을 리턴함
- 이런 Wrapper 클래스가 만들어진 목적은
    - 매개 변수를 참조형으로만 받는 메소드 처리
    - 제네릭에 사용하려면 참조 자료형이어야 함
    - MIN_VALUE, MAX_VALUE (각 타입이 나타낼 수 있는 값의 범위) 같은 각 Wrapper 클래스에 선언된 상수 값을 사용하기 위해
    - 숫자와 문자열 간의 변환이나 2, 8, 10, 16 진수 변환을 쉽게 처리하기 위해
        - 예를 들어 Integer에서 제공하는 toBinaryString(), toHexString() 메소드
    - 그 외에 숫자 참조 자료형에서 제공하는 많은 메소드를 사용하기 위함 
- 참고로 중요한 숫자 연산을 수행할 때 Wrapper 클래스는 아니지만 범위를 넘거나 부동소수점 오차를 방지하기 위해 정수형은 BigInteger, 소수형은 BigDecimal을 사용해야 정확한 계산이 가능함 

### 2.3 System 클래스
- System 클래스에는 생성자가 없으며, 아래와 같이 3개의 static 변수가 선언되어 있음
    - static PrintStream err
    - static InputStream in
    - static PrintStream out
- System.out.println()에서 out은 System 클래스에 static으로 선언된 변수 이름이며 println() 메소드는 PrintStream 클래스에 선언된 static 메소드. 모두 static이라 사용 시 별도의 클래스 객체를 생성할 필요가 없음
- PrintStream과 InputStream은 모두 java.io 패키지에 선언되어 있음
- System.out.println()을 출력을 위해 많이 사용하지만 출력은 System이 아닌 PrintStream과 연관되어 있으며 System은 시스템에 대한 정보를 확인하는 클래스
- System 클래스의 역할
    - 시스템 속성(Property)값 관리
        - static Properties getProperties(), static String getProperty(String key), static Properties setProperties()... 및 기타 등등
        - Properties는 java.util 패키지에 속하며 Hashtable의 상속을 받은 클래스. Map처럼 특정 key 값에 대한 value를 가짐
        - 자바 프로그램을 실행하면 Properties 객체가 생성되며 그 값은 언제 어디서든지 같은 JVM 내에서는 꺼내서 사용할 수 있음
    - 시스템 환경값 조회
        - static Map<String,String> getenv(), static String getenv(String name) 등
        - 환경값(env)은 Properties와 달리 변경이 불가능하고 읽기만 할 수 있음. 대부분 OS나 장비와 관련된 것들
            - 예 : System.getenv("JAVA_HOME")
    - GC 수행
        - static void gc(), static void runFinalization() 등
        - 호출하지 않아도 JVM이 알아서 더이상 필요없는 객체를 처리하기위해 GC를 수행함. 위의 함수들은 알아두되 사용하지 말 것 
    - JVM 종료
        - static void exit(int status)
        - 마찬가지로 절대 호출하면 안됨
    - 현재 시간 조회
        - static long currentTimeMillis() : 현재 시간을 나타낼 때 유용한 메소드. UTC 기준 1970년 1월 1일 00:00부터 지금까지의 밀리초(1/1,000초) 단위의 차이를 출력함
        - static long nanoTime() : 시간의 차이를 측정하기 위한 메소드. 마찬가지로 현재 시간을 출력하지만 currentTimeMillis와 달리 단위가 나노초(1/1,000,000,000초)
    - 기타 관리용 메소드들
- System 클래스에 선언된 out, err 변수는 동일하게 PrintStream 클래스의 객체로 정상적인 출력인지, 에러가 났을 때의 출력 결과인지의 차이만 존재
- PrintStream 클래스의 출력을 위한 주요 메소드 : print(), println(), format(), printf(), write() 등
    - print(), println() 
        - 모두 기본 자료형과 참조 자료형을 매개 변수로 사용할 수 있음
        - byte나 short 타입을 매개 변수로 받는 메소드는 없으나 둘다 정수형이므로 int 타입을 매개 변수로 받는 메소드에서 처리해줌
        - String.valueOf(obj)라는 static 메소드를 호출해 받은 결과를 출력함. obj.toString()과 달리 valueOf는 null이 들어가도 오류가 발생하지 않고 그냥 null이라 출력함. 따라서 객체를 출력할 때는 toString()보다 valueOf()를 사용하는 게 훨씬 더 안전 
        - System.out.println(null + "is object's value")와 같이 null에 더하기 연산을 해도 컴파일러에서 이 더하기 문장을 StringBuilder로 변환하여 new StringBuilder().append(obj).append(" is object's value")로 수행하므로 예외를 발생시키지 않음
    - println 메소드는 매개 변수가 없는 메소드가 존재. 만약 줄바꿈만 처리하고 싶다면 println("") 대신 println()으로 처리하는게 불필요한 String 객체를 생성하지 않아 깔끔함

## 3. 제네릭

### 3.1 개요
- 타입 형 변환에서 발생할 수 있는 문제점을 사전에 없애기 위해 만들어짐
- Object 객체는 어느 참조 자료형이든 넣을 수 있지만 값을 꺼낼 때 형 변환을 해야하며, 어느 타입인지 확인하려면 instanceof 예약어로 확인해야함
    ```
    public class Box {
        private Object value;

        public void set(Object value) {
            this.value = value;
        }

        public Object get() {
            return value;
        }
    }
    ```
- 제네릭을 사용할 경우 클래스나 메서드가 사용할 타입을 미리 지정하지 않고, 사용할 때 어느 타입이든 지정할 수 있음.
 T 타입 매개변수는 선언된 범위 안에서만 의미가 있음
    - 클래스의 경우
        ```
        public class Box<T> {   // T는 타입 매개변수 (Type Parameter)
            private T value;

            public void set(T value) {
                this.value = value;
            }

            public T get() {
                return value;
            }
        }
        ```
    - 메소드의 경우
        ```
        public <T> void printList(List<T> list) {
            for (T item : list) System.out.println(item);
        }
        ```
- 꺾쇠 안에 있는 타입 매개변수로는 현재 존재하는 클래스를 사용해도 되고 존재하지 않는 것을 사용해도 됨. 가상의 타입 이름
    - 단, 꼭 지켜야 하는 건 아니지만 자바에서 정의한 기본 규칙은 아래와 같음
        - E : 요소
        - K : 키
        - N : 숫자
        - T : 타입
        - V : 값
        - S, U, V : 두 번째, 세 번째, 네 번째에 선언된 타입
- 제네릭으로 사용할 때 지정한 타입의 변수를 일치하지 않는 타입의 참조 자료형에 넣으려고 하면 컴파일 자체가 안됨. "실행 시"에 다른 타입으로 잘못 형 변환하여 예외가 발생하는 일은 없음
- 제네릭 타입은 여러개를 정의할 수 있음
    ```
    public <T, U> void printPair(T first, U second) {
        System.out.println("First: " + first);
        System.out.println("Second: " + second);
    }
    ```

### 3.2 와일드 카드
- 와일드 카드는 제네릭 타입의 클래스나 메소드를 사용할 때 꺾쇠 안에 구체적인 클래스 대신 \<?\>을 넣음. 어떤 타입이 제네릭 타입이 될지 모르거나 상관 없을 경우 사용함
- 와일드 카드를 사용하여 선언한 객체는 읽기만 가능하고 쓸 수는 없음. 클래스/메소드 내부에서 ?가 어떤 타입인지 모르기 때문에 Object로 받아야 하며, 매개 변수로만 사용하는 것이 추천됨
- 제네릭, 와일드 카드는 각각 \<T extends Number\>, \<? extends Car\> 와 같이 타입에 대하여 경계를 지정할 수 있음. 특정 클래스를 상속 받은 클래스만 타입으로 사용할 수 있게 제한하는 것.
 후자를 Bounded Wildcards라고 부름

## 4. 컬렉션

### 4.1 자료구조와 Collection
- 자바에서 자료 구조는 여러 데이터를 담을 때 사용하며, 아래와 같은 것들이 있음
    - 순서가 있는 List 형
    - 순서가 중요하지 않는 Set 형
    - 먼저 들어온 것이 먼저 나가는 Queue 형
    - 키-값으로 저장되는 Map 형
- List, Set, Queue는 Collection이라는 인터페이스를 구현하고 있음. Collection 인터페이스는 java.util 패키지에 선언되어 있으며 어러 개의 객체를 하나의 객체에 담아 처리할 때 공통적으로 사용되는 여러 메소드들을 선언해놓음
- Map 만이 Collection과 관련 없는 별도의 인터페이스로 선언됨
- Collection 인터페이스 : public interface Collection\<E\> extends Iterable\<E\>
- Collection 인터페이스가 확장하는 Iterable 인터페이스에 선언되어 있는 메소드는 Iterator\<T\> iterator() 하나로, 이 메소드를 이용하여 데이터를 순차적으로 가져올 수 있음
- Collection 인터페이스에 선언된 주요 메소드
    - boolean add(E e)
    - boolean addAll(Collection)
    - void clear()
    - boolean contains(Object)
    - boolean containsAll(Collection)
    - boolean equals(Object)
    - int hashCode()
    - boolean isEmpty()
    - Iterator iterator()
    - boolean remove()
    - boolean removeAll(Collection)
    - boolean retainAll(Collection)
    - int size()
    - Object[] toArray()
    - \<T\> T[] toArray(T[])
- E = Element는 컬렉션에 저장되는 각각의 데이터를 말함
- List와 Collection 인터페이스를 확장한 다른 인터페이스들과의 차이는 배열처럼 순서가 있다는 것. List를 구현한 클래스들은 ArrayList, Vector, Stack, LinkedList 등이 있음
- ArrayList와 Vector 클래스의 사용법은 거의 동일하고 기능도 거의 비슷. 둘다 확장 가능한 배열인데, ArrayList는 Thread safe하지 않고 Vector는 Thread safe하다는 차이가 있음. 보통 ArrayList가 많이 선호됨
- Stack 클래스는 Vector 클래스의 확장으로 LIFO를 지원하기 위해 만들어짐
- LinkedList 클래스는 List와 Queue를 구현함

### 4.2 List

#### 4.2.1 ArrayList
- 상속 관계는 java.lang.Object > java.util.AbstractCollection\<E\> > java.util.AbstractList\<E\> > java.util.ArrayList\<E\>
    - AbstractCollection은 Collection 인터페이스, AbstractList는 List 인터페이스 중 일부 공통적인 메소드를 구현함
- ArrayList가 구현한 인터페이스로는 Serializable, Cloneable, Iterable\<E\>(= foreach 사용 가능), Collection\<E\>, List\<E\>, RandomAccess(=빠르게 임의로 접근하는 알고리즘이 적용됨) 등이 있음
- 배열처럼 사용하지만 대괄호는 사용하지 않고 메소드를 통해 객체를 넣고 빼고 조회
- ArrayList의 생성자
    - ArrayList() : 객체 저장 공간이 10개인 ArrayList 생성
    - ArrayList(Collection\<? extends E\> c)
    - ArrayList(int initialCapacity) : 매개 변수만큼의 저장 공간을 갖는 ArrayList 생성
- 대부분 서로 다른 종류의 객체가 아닌 한가지 종류의 객체만 저장. 한가지 종류를 지정하기 위해 생성 시 제네릭을 사용하면 좋음
- 선언 시 매개 변수를 넣지 않으면 초기 크기는 10으로, 그 이상의 데이터가 들어가면 자동으로 크기를 늘리는 작업이 수행됨. 이는 성능에 영향을 주므로 예측 가능하다면 예측한 초기 크기를 지정하는게 좋음
- 데이터를 담는 메소드
    - boolean add(E e)
    - void add(int index, E e)
    - boolean addAll(Collection\<? extends E\> c)
    - boolean addAll(int index, Collection\<? extends E\> c)
- 하나의 Collection 관련 객체를 복사할 일이 있을 때는 생성자를 사용하거나 addAll 메소드를 사용하는 것이 권장됨
- Collection 타입의 매개변수로 제공하는 이유는 Set이나 Queue 같은 Collection을 구현한 다른 객체도 받아들이기 위함
- 데이터를 꺼내는 메소드
    - int size()
    - E get(int index)
    - int indexOf(Object o)
    - int lastIndexOf()
- ArrayList에 들어가 있는 데이터 개수를 확인하려면 size() 메소드 사용. 배열이나 String 문자열의 길이를 가져오는 length()와 달리 저장공간 개수가 아님
- ArrayList에는 중복된 데이터를 넣을 수 있으며 앞에서부터 찾을 때는 indexOf, 뒤부터 찾을 때는 lastIndexOf 사용
- ArrayList 객체에 있는 데이터들을 배열로 뽑아내려면 toArray() 메소드 사용
    - Object[] toArray()
    - <T> T[] toArray(T[] a)
- 제네릭을 사용하여 선언한 ArrayList 객체를 배열로 생성할 때는 두 번째 메소드를 사용해야 함
- toArray는 ArrayList 객체에 있는 값들을 매개 변수로 넘어온 T 타입의 배열로 만듦. 따라서 보통 new String[0]같은 값을 넘겨 타입만 지정해줌
- 데이터 삭제하는 메소드
    - void clear() : 모든 데이터 삭제
    - E remove(int index) : 지정한 위치에 있는 데이터 삭제 후 삭제한 데이터 리턴
    - boolean remove(Object o) : 매개 변수와 동일한 첫 번째 데이터 삭제
    - boolean removeAll(Collection\<?\> c) : 매개 변수 컬렉션에 있는 데이터와 동일한 모든 데이터 삭제
- 값을 변경하는 메소드
    - E set(int index, E element) : index 위치에 있는 데이터를 element 값으로 변경하고 기존의 값을 리턴
- 추가로 ArrayList 객체 공간의 크기를 데이터 개수만큼으로 변경하는 trimToSize() 메소드가 있음
- ArrrayList를 Thread safe하게 만드려면 아래와 같이 생성
    ```
    List list = Collections.synchronizedList(new ArrayList(...));
    ```

#### 4.2.2 LinkedList
- ArrayList와 다르게 AbstractSequentialList를 상속받음. AbstractSequentialList은 AbstractList와 add(), set(), remove() 메소드에 대한 구현이 상이함
- 구현한 인터페이스는 List와 유사하나, List\<E>뿐만 아니라 Deque\<E>와 Queue\<E>를 상속받음. Deque는 Queue 인터페이스의 확장으로 맨 앞/뒤에 값을 넣거나 빼는 작업을 하기 용이하게 되어있음
- 생성자
    - LinkedList()
    - LinkedList(Collection<? extends E> c)
- 주요 메소드
    - LinkedList는 여러 종류의 인터페이스를 구현했기 때문에 중복된 기능을 수행하는 메소드가 많음. 예를 들면 데이터를 추가하는 메소드들은 아래와 같음
        - LinkedList의 가장 앞에 데이터 추가
            - void addFirst(Object)
            - boolean offerFirst(Object)
            - void push(Object)
        - LinkedList 객체의 가장 뒤에 데이터 추가
            - void addLast(Object)
            - boolean offer(Object)
            - offerLast(Object)
        - LinkedList 객체의 특정 위치에 데이터 추가
            - void add(int, Object)
        - LinkedList 객체의 특정 위치에 있는 데이터를 수정하고 기존 데이터 리턴
            - set(int, Object)
        - 매개 변수로 넘긴 컬렉션의 데이터 추가
            - addAll(Collection)
        - 매개 변수로 넘긴 컬렉션의 데이터를 지정된 위치에 추가
            - addAll(int, Collection)
    - 데이터를 맨 앞에 추가하는 메소드는 동일한 기능을 수행하는 어떤 메소드를 호출해도 addFirst()를 호출하도록 구현됨. 또한 맨 뒤에 추가하는 메소드는 무조건 add()나 addLast() 메소드를 호출하게 되어 있으므로 add가 붙은 메소드로 통일하여 사용하는 것이 좋음
    - 그 밖에 맨 앞 데이터를 가져오는 메소드는 모두 내부적으로 getFirst() 메소드를 호출하고, 맨 앞 데이터를 삭제하는 메소드들은 모두 removeFirst() 메소드들을 내부적으로 호출함. 또한 맨 뒤 데이터를 삭제하는 메소드들은 모두 removeLast() 메소드를 내부적으로 호출하므로 혼동을 피하려면 remove가 붙은 메소드를 사용하는 것이 좋음
    - LinkedList 객체를 하나씩 검색하기 위한 Iterator 객체는 아래와 같음
        - ListIterator listIterator(int)
        - Iterator descendingIterator()
    - Iterator 객체는 앞에서 언급한 것과 같고, ListIterator는 다음 데이터만 검색할 수 있는 Iterator를 보완하여 previous()로 이전 데이터도 검색할 수 있게 만든 것

#### 4.2.3 Stack
- LIFO 기능을 위해서라면 더 빠른 ArrayDeque 클래스가 있으나 Thread safe하진 못함
- 취지가 LIFO라는 걸 고려했을 때 Vector를 상속 받아선 안되었으나 자바의 하위 호환성을 위해 현재 상속관계 유지
- 객체의 가장 위에 있는 데이터를 리턴하는 peek(), 객체의 가장 위에 있는 데이터를 지우고 리턴하는 pop(), 그 밖에 push(), 객체가 비어있는지 확인하는 empty(), 매개 변수로 넘어온 데이터의 위치를 리턴하는 search()가 있음

### 4.3 Set
- 순서에 상관없이 어떤 데이터가 존재하는지를 확인하는 용도로 자주 사용됨. 데이터가 중복되어 저장되지 않음
- Set 인터페이스를 구현한 주요 클래스로 HashSet, TreeSet, LinkedHashSet이 있음
    - HashSet
        - 상속 관계 : java.lang.Object -> java.util.AbstractCollection -> java.util.AbstractSet\<E\> -> java.util.HashSet\<E\>
        - AbstractSet 추상 클래스는 Object 클래스의 equals(), hashCode() 메소드를 구현하고, removeAll() 메소드를 추가함. Set은 데이터 중복을 허용하지 않으므로 equals() 메소드가 필수이며 equals()는 hashCode()와 떨어질 수 없는 불가분의 관계 (Object 클래스 내용 참고)
        - Set이 구현한 인터페이스는 List와 유사하나, 순서가 없으므로 get(int index)나 indexOf(Object o)와 같은 메소드들은 구현되지 않음
        - 생성자
            - HashSet()	: 기본 생성자. 초기 용량 16, 로드 팩터 0.75 사용
            - HashSet(Collection<? extends E> c) : 다른 컬렉션 객체의 데이터를 Set으로. 중복은 자동 제거됨
            - HashSet(int initialCapacity) : 지정한 초기 용량으로 HashSet 생성. 로드 팩터는 기본값 0.75 사용
            - HashSet(int initialCapacity, float loadFactor) : 초기 용량과 로드 팩터를 모두 지정해서 HashSet 생성
            - 여기서 로드 팩터는 데이터의 개수/저장 공간으로, 해시 테이블이 얼마나 가득 찼을 때 크기를 두 배로 늘릴지를 결정하는 값. 크기를 늘리게 될 경우 해시 재정리 작업에 들어가는데 내부 자료 구조를 다시 생성하는 단계를 거치므로 성능에 영향이 감. 따라서 initialCapacity와 loadFactor는 총 데이터의 크기보다 큰 임계값을 갖도록 설정하는 게 좋음
        - 주요 메소드
            - boolean add(E e)
            - boolean remove(Object o)
            - void clear()
            - boolean contains(Object o)
            - int size()
            - boolean isEmpty()
            - Iterator\<E\> iterator()
            - Object clone()
        - Iterator 메소드가 구현되었으므로 for 루프를 사용하거나 아래와 같이 직접 iterator 객체를 생성하여 순회할 수 있음
            ```
            Set<String> set = new HashSet<>(Arrays.asList("A", "B", "C"));
            Iterator<String> it = set.iterator();
            while (it.hasNext()) {
                String value = it.next();
                System.out.println(value);
            }
            ```

### 4.4 Map

#### 4.4.1 HashTable
- Map 인터페이스를 구현한 클래스로 유명한건 HashMap, TreeMap, LinkedHashMap인데 그 외에도 Hashtable이라는 클래스가 있음
- 일반적인 Map 인터페이스를 구현한 클래스들과는 다름
    - Map은 컬렉션 뷰를 사용하지만 Hashtable은 Enumeration 객체를 통해 데이터를 처리
    - Map은 키, 값, 키-값 쌍으로 데이터를 순환하여 처리할 수 있으나 Hashtable은 키-값 쌍으로는 데이터를 처리할 수 없음
    - Map은 이터레이션을 처리하는 도중 데이터를 삭제하는 안전한 방법을 제공하지만 Hashtable은 그렇지 않음
- HashMap 클래스와 달리 Hashtable은 키나 값에 null 값을 저장할 수 없고 멀티스레드에 안전하다는 차이가 있
음
- HashTable이 Collection 인터페이스보다 더 먼저 생겼고 나중에 생긴 Map에 맞춰 보완되었기에 이러한 차이가 생김
- HashTable을 제외한 Map으로 끝나는 클래스들을 멀티 스레드에서 동시 접근하여 처리하려면 아래와 같이 선언해서 사용해야 함. JDK 1.2부터 제공되는 대부분의 Collection 관련 클래스들이 그러함
    ```
    Map m = Collections.synchronizedMap(new HashMap(...));
    ```
- Map은 put(), get(), remove() 메소드로 데이터를 넣고 조회하고 제거함

#### 4.4.2 HashMap
- 생성자
    - HashMap()	: 초기 용량(capacity)을 16으로 생성
    - HashMap(int initialCapacity)
    - HashMap(int initialCapacity, float loadFactor)
    - HashMap(Map<? extends K, ? extends V> m) : 다른 Map의 모든 데이터를 복사해 새 HashMap을 생성
- HashMap에 담을 데이터 개수가 많은 경우에는 초기 크기를 지정해 주는 것이 좋음
- HashMap의 키는 기본 자료형과 참조 자료형 모두 될 수 있는데, 직접 정의한 클래스를 키로 사용할 땐 Object 클래스의 hashCode(), equals() 메소드를 잘 구현해 놓아야 함
- HashMap은 내부적으로 배열을 사용하는데, 이 배열의 각 칸을 버킷이라고 부르고
각 버킷 안에는 연결리스트 또는 트리 구조가 들어감. 새로운 값을 추가할 때 어떤 버킷에 저장할지는 hashCode() 값으로 결정됨
- get(키 값)으로 값을 조회할 때도 hashCode()로 먼저 버킷을 확인한 후 해시코드가 같은 키-값이 여러개이면 equals()로 키 값 비교
- Map은 존재하지 않는 키로 get()을 하면 outOfBound 예외를 발생시키는 Collection과 달리 null을 반환함
- 이미 존재하는 키로 값을 넣을 경우엔(put) 새로운 값으로 대치함
- HashMap에 있는 키 목록을 Set으로 반환하는 keySet(), 값 목록을 Collection 타입 목록으로 반환하는 values() 메소드가 있음
- entrySet() 메소드는 Entry 타입 객체들의 Set을 반환. Map에 선언된 Entry 객체는 하나의 키-값 쌍을 저장하는 하며, 키와 값을 가져오는 getKey(), getValue()를 제공함
    ```
    public class EntrySetExample {
        public static void main(String[] args) {
            // HashMap 생성 및 데이터 추가
            Map<String, Integer> map = new HashMap<>();
            map.put("apple", 3);
            map.put("banana", 2);
            map.put("cherry", 5);

            // entrySet()을 이용한 순회
            for (Map.Entry<String, Integer> entry : map.entrySet()) {
                String key = entry.getKey();
                Integer value = entry.getValue();
                System.out.println(key + " = " + value);
            }
        }
    }
    ```
- 그 밖에 boolean 리턴 타입을 가지는 containsKey(), containsValue()와 키 값을 매개변수로 삭제하는 remove() 메소드, 데이터 개수를 확인하는 size() 메소드가 있음

#### 4.4.3 TreeMap
- 데이터 저장 시 키를 정렬하는 맵. String 타입의 키일 때 기본 정렬 순서는 숫자 > 알파벳 대문자 > 알파벳 소문자 > 한글 순인데, 키가 객체나 숫자일 경우에는 순서가 다름
- 많은 데이터를 보관하면 HashMap보다는 느리나, 정렬이 필요할 때는 TreeMap을 사용하는 것이 유리함
- TreeMap이 키를 정렬하는 것은 SortedMap 인터페이스를 구현했기 때문인데, 키가 정렬 되었을 때의 장점은 firstKey(), lastKey() 외에도 특정 키 뒤에 있는 키 higherKey(), 특정 키 앞에 있는 키 lowerKey() 등의 메소드들을 제공하여 키를 검색하는 프로그램을 작성할 때 유리하다는 것

#### 4.4.4 Properties 클래스
- Properties 클래스는 HashTable을 확장하였으므로 Map 인터페이스에서 제공하는 모든 메소드 사용 가능
- 기본적으로 자바에서는 Properties 클래스를 사용하여 시스템의 속성을 제공. System 클래스에 static으로 선언되어 있는 getProperties() 메소드를 호출하면 Properties 타입의 객체를 리턴
    ```
    public class SystemKeySetExample {
        public static void main(String[] args) {
            // 시스템 속성 가져오기
            Properties props = System.getProperties();

            // keySet()으로 모든 키 조회
            Set<Object> keys = props.keySet();

            // 모든 키와 값 출력
            for (Object key : keys) {
                System.out.println(key + " = " + props.get(key));
            }
        }
    }
    ```
- Properties 객체에는 시스템 속성 외에도 애플리케이션에서 사용하기 위해 필요한 여러 속성값들을 저장하고, 빼고, 읽어들일 수 있음
- Properties 클래스에서 추가로 제공하는 메소드
    - load(InputStream inStream)
    - load(Reader reader)
    - loadFromXML(InputStream in)
    - store(OutputStream out, String comments)
    - store(Writer writer, String comments)
    - storeToXML(OutputStream os, String comment)
    - storeToXML(OutputStream os, String comment, String encoding)
- load 메소드는 파일에서 속성을, loadFromXML는 xml로 되어 있는 속성을 읽음. store는 파일에 속성을 저장하고 storeToXML는 xml로 구성되는 속성 파일을 생성함
- comment 매개 변수는 속성 파일에 주석으로 저장되는 값
- 아래는 .properties 파일과 Properties 객체 간에 저장된 속성 내용을 주고 받는 예제
    ```
    public class PropertiesStoreLoadExample {
        public static void main(String[] args) {
            // 1. Properties 객체 생성 및 값 설정
            Properties props = new Properties();
            props.setProperty("username", "admin");
            props.setProperty("password", "1234");
            props.setProperty("server", "localhost");
            props.setProperty("greeting", "안녕하세요");

            String fileName = "config.properties";

            // 2. 파일에 저장 (UTF-8)
            try (OutputStream out = new FileOutputStream(fileName)) {
                props.store(out, "Sample Config File");
                System.out.println("Properties 저장 완료!");
            } catch (IOException e) {
                e.printStackTrace();
            }

            // 3. 파일에서 읽어오기
            Properties loadedProps = new Properties();
            try (InputStream in = new FileInputStream(fileName)) {
                loadedProps.load(in);

                System.out.println("\n=== Properties 읽기 결과 ===");
                // 전체 속성 출력
                loadedProps.forEach((key, value) -> 
                    System.out.println(key + " = " + value)
                );
                ...
            }
            ...
        }
    }
    ```
- .properties 파일의 내용은 키=값들이 나열된 형태로 되어 있음. 위의 예제에서 loadFromXML, storeToXML를 대신 사용하면 Properties 객체를 xml 파일로 내보내거나 xml 파일 내용을 Properties 객체로 읽어올 수 있음
- xml은 .properties와 달리 태그 형식으로 구성됨. html도 xml의 일종

## 5. 스레드

### 5.1 개요
- java 명령어를 사용하여 클래스를 실행시키는 순간 main() 메소드가 수행되면서 하나의 스레드가 시작됨
- WAS도 똑같이 Tomcat의 main() 메소드를 호출하여 하나의 main()에서 시작된 스레드들이 만들어져서 동작하는 것
- 아무런 스레드를 생성하지 않아도 JVM을 관리하기 위한 여러 스레드가 존재함. GC 관련 스레드가 여기에 속함
- 프로세스 하나가 시작하는데 많은 자원이 드는데 스레드는 훨씬 더 적은 물리 메모리를 점유함. 또한 지금같은 멀티코어 시대에는 다중 스레드로 실행하는게 더 빠른 결과를 가져다 줌

### 5.2 Runnable 인터페이스, Thread 클래스
- 스레드를 생성하려면 Runnable 인터페이스를 구현하거나, Runnable 인터페이스를 구현한 Thread 클래스를 사용하는 방법이 있음
- Runnable 인터페이스는 스레드가 시작되면 수행되는 메소드 void run() 하나만을 정의한 반면 Thread 클래스는 매우 많은 생성자와 메소드들을 제공하여 편리함
- 자바에선 클래스가 하나의 클래스만 상속할 수 있으므로, 다른 클래스를 확장해야 하는 클래스에서 스레드를 사용하려면 Thread 클래스 대신 Runnable 인터페이스를 구현해야 함. 만약 그럴 필요가 없다면 스레드 클래스를 사용하는 것이 편함
- 스레드가 수행할 동작을 구현하는 메소드는 run()이지만, 스레드를 시작하는 메소드는 start()임. start() 메소드는 직접 구현하지 않아도 알아서 run()을 수행하도록 자바에서 구현함
    ```
    public class ThreadExample {
        public static void main(String[] args) {

            // 1. Runnable 구현 방식
            Runnable runnableTask = new Runnable() {
                @Override
                public void run() {
                    System.out.println("Runnable 스레드 실행 중: " + Thread.currentThread().getName());
                }
            };
            Thread t1 = new Thread(runnableTask);
            t1.start(); // 새로운 스레드 시작

            // 2. Thread 클래스 상속 방식
            Thread t2 = new Thread() {
                @Override
                public void run() {
                    System.out.println("Thread 상속 스레드 실행 중: " + Thread.currentThread().getName());
                }
            };
            t2.start(); // 또 다른 스레드 시작

            // main 스레드
            System.out.println("메인 스레드 실행 중: " + Thread.currentThread().getName());
        }
    }
    ```
- 위의 예제와 같이 Runnable 인터페이스를 구현한 스레드 클래스는 start() 메소드로 바로 시작할 수 없으며 Thread 클래스의 생성자에 해당 객체를 추가하여 시작해야 함
- 위의 예제에 있는 3가지 출력문은 코드 순서대로 출력되지 않음. 스레드를 start() 메소드로 시작하면 프로세스가 아닌 하나의 스레드가 JVM에 추가되어 실행되므로 각 스레드는 비동기적으로 실행됨

### 5.3 Thread 클래스 생성자
- 생성자
    - Thread()
    - Thread(Runnable target) : 지정한 Runnable 객체를 실행할 스레드를 생성
    - Thread(Runnable target, String name) : 실행할 Runnable과 스레드 이름을 함께 지정
    - Thread(String name) : 스레드 이름만 지정. run()은 오버라이드해서 사용
    - Thread(ThreadGroup group, Runnable target) : 특정 스레드 그룹에 속하는 스레드를 생성하고, 실행할 Runnable 지정. 해당 group에 속하는 스레드를 target 기반으로 생성하는 것
    - Thread(ThreadGroup group, Runnable target, String name) : 스레드 그룹, 실행 대상, 스레드 이름을 모두 지정
    - Thread(ThreadGroup group, Runnable target, String name, long stackSize) : 스레드 그룹, 실행 대상, 이름, 스택 크기까지 지정
    - Thread(ThreadGroup group, String name) : 스레드 그룹과 이름만 지정
- 모든 스레드는 이름이 있음. 특별히 지정하지 않으면 "Thread-n"으로 지어지며 n은 스레드가 생성된 순서에 따라 증가. 스레드 이름은 겹쳐도 에러가 예외가 발생하진 않음
- 스레드의 그룹을 묶으면 ThreadGroup 클래스에서 제공하는 메소드들을 통해 여러 정보를 얻을 수 있음
- stackSize는 스택의 크기를 정의하지만, 스레드에서 얼마나 많은 메소드를 호출하는지 또는 얼마나 많은 스레드가 동시에 처리되는지는 JVM이 실행되는 OS 플랫폼에 따라 많이 다르므로 이 값은 무시될 수 있음
- Thread 클래스를 상속하여 구현할 경우 생성자는 아래와 같이 호출
    ```
    class MyThread extends Thread {
        public MyThread(String name) {
            super(name); // 해당 이름을 가진 스레드 생성
        }

        @Override
        public void run() {
            System.out.println("스레드 실행 중: " + Thread.currentThread().getName());
        }
    }
    ```
- 스레드를 시작할 때 어떤 값(아래에선 message)을 전달하고 싶을 경우 아래와 같이 구현할 수 있음
    ```
    class MyThread extends Thread {
        private String message;

        public MyThread(String name, String message) {
            super(name);
            this.message = message;
        }

        @Override
        public void run() {
            System.out.println(getName() + " : " + message);
        }
    }
    ```

### 5.4 synchronized
- 여러 스레드가 한 객체에 선언된 메소드에 접근하여 데이터를 처리하려 하면 값이 꼬일 수 있음. 메소드에서 인스턴스 변수를 수정할려고 할 때 발생하는 문제로, 매개변수나 메소드에서만 사용하는 지역변수만 다루는 메소드는 무관함
- synchronized는 2가지 방법으로 사용가능
    - 메소드 자체를 synchronized로 선언
    - 메소드 내의 특정 문장만 synchronized로 감싸기
- synchronized를 사용하면 이 메소드에 몇 개의 스레드가 접근하든 한 순간에는 하나의 스레드만 이 메소드를 수행하게 됨
    ```
    public class CommonCalculate {
        private int amount = 0;

        public void plus(int value) {
            amount += value;
        }

        // 현재 값 조회
        public int getAmount() {
            return amount;
        }
    }

    public class ModifyAmountThread extends Thread {
        private CommonCalculate calc;

        public ModifyAmountThread(CommonCalculate calc) {
            this.calc = calc;
        }

        @Override
        public void run() {
            for (int i = 0; i < 10000; i++) {
                calc.plus(1);
            }
        }
    }

    public class RunSync {
        public static void main(String[] args){
            RunSync runSync = new RunSync();
            runSync.runCommonCalculate();
        }
        public void runCommonCalculate(){
            CommonCalculate calc = new CommonCalculate();
            ModifyAmountThread thread1= new ModifyAmountThread(calc);
            ModifyAmountThread thread2= new ModifyAmountThread(calc);

            thread1.start();
            thread2.start();
            try {
                // join 메소드는 스레드가 종료될 때까지 기다리는 메소드
                thread1.join();
                thread2.join();
                System.out.println("Final value is " + calc.getAmount());
            } catch(InterruptedException e){
                e.printStackTrace();
            }
        }
    }
    ```
- RunSync를 5번 실행하면 정상적이지 않은 결과를 확인할 수 있음. 한 스레드에서 plus(1)을 수행한 amount 값을 amount 인스턴수 변수에 치환하기전에 다른 스레드가 또 들어와 이 연산을 수행하려 하게 되고, 결과적으로 꼬이게 됨
    ```
    Final value is 16447
    Final value is 19782
    Final value is 13399
    Final value is 14543
    Final value is 20000
    ```
- 아래와 같이 plus() 메소드를 synchronized 함수로 만들면 동일한 20000이라는 결과를 받을 수 있음
    ```
        public synchronized void plus(int value) {
            amount += value;
        }
    ```
- 그러나 만약 synchronized 메소드에 여러 로직이 있고, 그중 amount 인스턴수 변수를 한 줄에서만 다룬다고 하면 나머지 로직들을 수행하는데 불필요한 대기 시간이 발생하여 성능에 문제가 발생함. 이런 경우 synchronized 블록이 권장됨
    ```
    private final Object lock = new Object();

    public void plus(int value) {
        // synchronized 블록: lock 객체를 문지기로 사용
        synchronized (lock) {
            amount += value;
        }
    }
    ```
- 위에 선언된 lock 객체는 monitor 객체라 불리며, synchronized 블록의 공동 열쇠와 같음. 코드를 보호하려면 여러 스레드가 반드시 같은 monitor 객체를 공유해야 함
- 만약 인스턴스 변수가 2개 이상이고, 2개의 메소드에서 각각 다른 인스턴스 변수만 수정한다면 서로 독립적으로 실행되도록 해야 함. 같은 monitor 객체를 두 개의 메소드에서 사용하면 락이 같이 걸리므로 각 메소드별로 다른 monitor 객체를 만들어야 함
    ```
    public class SeparateLockExample {
        private int value1 = 0;
        private int value2 = 0;

        // 메소드별 다른 monitor 객체
        private final Object lock1 = new Object();
        private final Object lock2 = new Object();

        public void incrementValue1() {
            synchronized (lock1) { // lock1을 문지기로 사용
                value1++;
                System.out.println(Thread.currentThread().getName() + " incrementValue1: " + value1);
            }
        }

        public void incrementValue2() {
            synchronized (lock2) { // lock2를 문지기로 사용
                value2++;
                System.out.println(Thread.currentThread().getName() + " incrementValue2: " + value2);
            }
        }
    }
    ```
- 위의 예제들에서 CommonCalculate를 사용하여 스레드 객체를 생성할 때는 당연히 같은 CommonCalculate 객체를 생성자에 전달해야 함. 동일한 객체를 참조하는 것이 아니라면 synchronized를 사용하는 의미가 없음
- 자바의 신 vol.1에서 StringBuffer는 스레드에 안전하고 StringBuilder는 안전하지 않다고 언급되었는데, StringBuffer는 synchronized 블록으로 주요 데이터 처리 부분을 감싸두었고 StringBuilder는 그렇지 않기 때문. 따라서 StringBuffer는 하나의 문자열 객체를 여러 스레드에서 공유하는 경우에만 사용하고, 그렇지 않은 경우 StringBuilder를 사용하면 됨


### 5.5 Thread 클래스 주요 메소드

#### 5.5.1 sleep 메소드
- Thread에 있는 static 메소드는 대부분 해당 스레드보다는 JVM에 있는 스레드를 관리하기 위한 용도로 사용되나, sleep 메소드는 예외
- 종류
    - static void sleep(long millis) : 지정한 밀리초(ms) 동안 현재 스레드를 일시 정지
    - static void sleep(long millis, int nanos) : 지정한 밀리초 + 나노초(ns) 동안 현재 스레드를 일시 정지
- Thread.sleep() 메소드를 사용할 때는 항상 try-catch로 묶어 주어야 함. 또한 적어도 InterruptedException으로 catch 해주어야 함 (적어도라는 건 InterruptedException이나 해당 예외가 아니더라도 그 상위에 있는 예외로 받아주어야 한다는 의미)
- main() 메소드 수행이 끝나더라도 main() 메소드나 다른 메소드에서 시작한 스레드가 종료하지 않으면 자바 프로세스는 끝나지 않는데, 데몬 스레드는 예외임

#### 5.5.2 스레드의 속성을 확인하고 지정하는 메소드
- 종류
    - void run()
    - long getId() : 스레드의 고유 id 리턴. id는 JVM에서 자동으로 생성해줌
    - String getName()
    - void setName(String name)
    - int getPriority() : 스레드 우선순위 확인
    - void setPriority(int newPriority) : 스레드 우선순위 지정
    - boolean isDaemon(boolean on) : 스레드가 데몬인지 확인
    - StackTraceElement[] getStackTrace() : 스레드를 데몬으로 설정할지 말지 설정
    - Thread.State getState()
    - ThreadGroup getThreadGroup()
- 스레드의 우선 순위는 대기하고 있는 상황에서 더 먼저 수행할 수 있는 순위. 직접 설정하기 보단 기본값으로 사용하는 것이 권장됨
- Thread 클래스에 정의된 우선 순위와 관련된 3개의 상수가 있음. 우선 순위는 되도록 지정하지 않는 것이 좋으나 정할 일이 있다면 숫자보단 아래의 상수를 사용
    - MAX_PRIORITY : 가장 높은 우선순위로 값은 10
    - NORM_PRIORITY : 일반 스레드의 우선순위로 값은 5
    - MIN_PRIORITY : 가장 낮은 우선순위로 값은 1
- 스레드를 데몬 스레드로 지정하면 그 스레드가 수행되고 있든 아니든 상관없이 JVM이 종료될 수 있음. 단, 해당 스레드가 start()로 시작되기 전에 데몬 스레드로 지정되어야 함. 다른 스레드들의 종료 여부와는 별개로 별도의 모니터링 스레드 등을 띄우기 위해 사용

#### 5.5.3 스레드를 통제하는 메소드
- 종류
    - Thread.State getState(): 스레드의 상태 확인
        - 리턴하는 Thread.State는 Thread 클래스에 선언된 enum 클래스. 이 클래스에 선언된 상수들은 아래와 같음
            - NEW : 스레드 객체는 생성되었지만 시작되지 않음
            - RUNNABLE : 실행 중 또는 실행 대기 상태
            - BLOCKED : 모니터 락을 기다리는 중
            - WAITING : 다른 스레드의 특정 작업을 무기한 기다리는 중
            - TIMED_WAITING : 일정 시간 동안 기다리는 상태
            - TERMINATED : 실행 종료
        - 이 enum 클래스는 public static으로 선언되어 Thread.State.NEW와 같이 사용 가능
        - 어떤 스레드든 NEW -> [RUNNABLE, BLOCKED, WAITING, TIMED_WAITING] -> TERMINATED 라이프 사이클을 가짐
    - void join() : 끝날 때까지 무제한 대기
    - void join(long millis) : 특정 시간(ms) 동안만 대기
    - void join(long millis, int nanos) : 더 정밀한 대기. 매개변수로 받은 millis + nanos만큼 대기하며, nanos는 1 밀리초 미만의 0~999,999까지만 지정 가능. 이 범위를 벗어나면 IllegalArgumentException을 발생시키며 중단됨 
    - void interrupt() : 수행중인 스레드 중지. InterruptedException을 발생시키면서 중단됨. (InterruptedException는 스레드가 sleep() 또는 join() 등으로 일시 정지된 상태일 때, 다른 스레드가 interrupt()를 호출하면 발생) 스레드가 시작하기 전이나 종료된 후에 호출하면 예외나 에러 없이 그냥 다음 문장으로 넘어감. 이전에는 stop()라는 메소드가 있었는데 안전상의 이유로 deprecated 됨

    ```
    public class SleepThread extends Thread {
        long sleepTime;
        public SleepThread(long sleepTime) {
            this.sleepTime = sleepTime;
        }
        @Override
        public void run() {
            try {
                // Thread-0
                System.out.println("Sleeping " + getName());
                Thread.sleep(sleepTime);
                System.out.println("Stopping " + getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public class RunSupportThreads {
        public static void main(String[] args) {
            RunSupportThreads sample = new RunSupportThreads();
            sample.checkThreadState1();
        }
        public void checkThreadState1() {
            SleepThread thread = new SleepThread(2000);

            try {
                // NEW
                System.out.println("thread state = " + thread.getState());
                thread.start();

                // RUNNABLE
                System.out.println("thread state (after start) = " + thread.getState());
                Thread.sleep(1000);

                // TIME_WAITING
                System.out.println("thread state (after 1 sec) = " + thread.getState());

                thread.join();
                thread.interrupt();

                // TERMINATED
                System.out.println("thread state (after join) = " + thread.getState());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    ```

- 위 예제의 RunSupportThreads 출력 결과는 아래와 같음

    ```
    thread state=NEW
    thread state(after start)=RUNNABLE
    Sleeping Thread-0
    thread state(after notify)=TIMED_WAITING
    Stopping Thread-0
    thread state(after join)=TERMINATED
    ```

- 스레드 내부적으로 2초 동안 sleep하므로 메인 스레드에서 해당 스레드를 시작하고 1초 sleep 후 상태 출력하면 TIME_WAITING

    ```
    public void checkJoin() {
        SleepThread thread = new SleepThread(2000);

        try {
            thread.start();
            thread.join(500);   // 0.5초 동안만 join
            thread.interrupt(); // 인터럽트 요청
            System.out.println("thread state (after join) = " + thread.getState());
        } catch (InterruptedException ie) {
            ie.printStackTrace();
        }
    }
    ```

- 위와 같이 스레드가 종료되기전에 interrupt()를 호출하면 InterruptedException가 발생하게 됨.

    ```
    java.lang.InterruptedException: sleep interrupted
    thread state(after join)=TIMED_WAITING
        at java.lang.Thread.sleep(Native Method)
        at e.thread.support.SleepThread.run(SleepThread.java:11)
    ```

- InterruptedException이 던져지는 순간 스레드가 곧바로 TERMINATED가 되는 게 아니라 예외가 끝나고 run() 메소드가 종료될 때 비로소 TERMINATED가 됨
- thread.join(5000)으로 늘리면 스레드가 종료될때까지 기다린 후 interrupt()하게 되므로 정상적인 결과 출력
- 그 밖에 상태 확인을 위한 메소드로 현재 스레드가 해당 스레드에 대한 수정권한이 있는지 확인하는 checkAccess(), isAlive(), 다른 스레드가 interrupt로 종료되었는지 확인하는 isInterrupted(), 자신의 스레드가 interrupt로 종료되었는지 확인하는 interupted() 등이 있음
- Object 클래스에 선언된, 스레드와 관련있는 메소드 (synchronized 블록의 monitor 객체 기반으로 동작)
    - void wait() : monitor lock을 반납하고 스레드를 WAITING 상태로 만듦. 다른 스레드가 notify(), notifyAll() 호출할 때까지 대기
    - void wait(long timeout) : 지정한 시간동안 대기(ms)
    - void wait(long timeout, int nanos)
    - void notify() : monitor에 대해 WAITING 중인 스레드 1개를 깨움
    - void notifyAll() : monitor에 대해 WAITING 중인 모든 스레드를 깨움

    ```
    public class StateThread extends Thread {

        private Object monitor;

        public StateThread(Object monitor) {
            this.monitor = monitor;
        }

        @Override
        public void run() {
            try {
                // 루프 동안 스레드를 실행중인 상태로 유지
                for (int loop = 0; loop < 10000; loop++) {
                    String a = "A"; 
                }

                synchronized (monitor) {
                    monitor.wait();  // WAITING 상태 진입
                }

                System.out.println(getName() + " is notified.");

                Thread.sleep(1000); // TIMED_WAITING 상태
            } catch (InterruptedException ie) {
                ie.printStackTrace();
            }
        }
    }

    public class RunObjectThreads {
        public static void main(String args[]) {
            RunObjectThreads sample = new RunObjectThreads();
            sample.checkThreadState3();
        }
    }

    public void checkThreadState3() {
        Object monitor = new Object();
        StateThread thread = new StateThread(monitor);
        StateThread thread2 = new StateThread(monitor);

        try {
            System.out.println("thread state = " + thread.getState());

            thread.start();
            thread2.start();

            System.out.println("thread state (after start) = " + thread.getState());

            Thread.sleep(100);
            System.out.println("thread state (after 0.1 sec) = " + thread.getState());

            // notify는 반드시 synchronized(monitor) 블록 내부에서 수행해야 함
            synchronized (monitor) {
                monitor.notify();     // WAITING 중인 스레드 깨움
            }

            Thread.sleep(100);
            System.out.println("thread state (after notify) = " + thread.getState());

            thread.join();
            System.out.println("thread state (after join) = " + thread.getState());

            thread2.join();
            System.out.println("thread2 state (after join) = " + thread2.getState());
        } catch (InterruptedException ie) {
            ie.printStackTrace();
        }
    }
    ```

- 스레드 2개를 시작 후 스레드 내부와 메인 스레드 각각에 같은 monitor 객체를 공유하는 synchronized 블록이 있으므로 한 스레드가 wait 상태에 돌입하면 다른 한 스레드는 바로 notify()를 실행하여 깨우게 됨
- 출력 결과는 아래와 같음

    ```
    thread state=NEW
    thread state(after start)=RUNNABLE
    thread state(after 0.1 sec)=WAITING
    Thread-0 is notified.
    thread state(after notify)=TIMED_WAITING
    thread state(after join)=TERMINATED
    ```

- 맨 마지막 출력인 "thread2 state (after join) = " + thread2.getState()가 출력되지 않았는데 notify()를 호출하면 먼저 대기하고 있는 것부터 풀어주기 때문. synchronized 블록에서 notify()를 연달아 실행해도 되지만 wait 상태가 여러개인 경우도 있으므로 notifyAll()을 사용하는 것이 좋음
- wait()로 WAITING 상태가 된 경우 interrupt()로 대기 상태에서 풀려날 수도 있지만 notify()로 풀어야 예외도 발생하지 않고 wait() 이후의 문장도 정상적으로 수행함

#### 5.5.4 ThreadGroup에서 제공하는 메소드
- 종류
    - int activeCount()	: 활성 스레드 수 리턴
    - int activeGroupCount() : 활성 스레드 그룹의 개수 리턴
    - int enumerate(Thread[] list) : list 매개변수로 현재 그룹 내 활성 스레드 목록 복사. 그룹에 있는 모든 스레드의 객체를 제대로 담으려면 activeCount() 메소드를 통해 활성 스레드 수를 정확히 파악한 후 그 개수만큼 배열을 생성해 넘겨야 함
    - int enumerate(ThreadGroup[] list)	list 매개변수로 현재 스레드 그룹에 있는 모든 스레드 그룹 목록 복사
    - String getName() : 그룹 이름 반환
    - ThreadGroup getParent() : 부모 ThreadGroup 반환
    - void list() : 스레드 그룹의 상세 정보 출력
    - void setDaemon(boolean daemon) : 현재 스레드 그룹에 속한 스레드들을 데몬으로 지정

    ```
    public class RunGroupThreads {

        public static void main(String[] args) {
            RunGroupThreads sample = new RunGroupThreads();
            sample.groupThread();
        }

        public void groupThread() {
            try {
                // SleepThread는 Thread를 상속한 클래스라고 가정
                SleepThread sleep1 = new SleepThread(5000);
                SleepThread sleep2 = new SleepThread(5000);

                // ThreadGroup 생성
                ThreadGroup group = new ThreadGroup("Group1");

                // Thread 생성, 그룹 지정, SleepThread(Runnable) 지정
                Thread thread1 = new Thread(group, sleep1, "Thread-1");
                Thread thread2 = new Thread(group, sleep2, "Thread-2");

                // 스레드 시작
                thread1.start();
                thread2.start();

                Thread.sleep(1000); // 잠시 대기

                // 그룹 정보 출력
                System.out.println("Group name = " + group.getName());

                int activeCount = group.activeCount();
                System.out.println("Active count = " + activeCount);

                group.list(); // 그룹 상태 출력

                // enumerate로 스레드 목록 가져오기
                Thread[] tempThreadList = new Thread[activeCount];
                int result = group.enumerate(tempThreadList);
                System.out.println("Enumerate result = " + result);

                // 스레드 이름 출력
                for (Thread thread : tempThreadList) {
                    System.out.println(thread);
                }

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    ```

- 출력된 결과는 아래와 같음

    ```
    Sleeping Thread-0
    Sleeping Thread-1
    Group name=Group1
    Active count=2
    java.lang.ThreadGroup[name=Group1,maxpri=10]
        Thread [Thread-2,5,Group1]
        Thread [Thread-3,5,Group1]
    Enumerate result=2
    Thread [Thread-2,5,Group1]
    Thread [Thread-3,5,Group1]
    Stopping Thread-0
    Stopping Thread-1
    ```

## 6. 자바 I/O

### 6.1 개요
- I/O는 프로그램에 있는 내용을 파일에 읽거나 저장할 일이 있을 때, 또는 다른 서버나 디바이스로 보낼 일이 있을 때 사용
- JVM을 기준으로 읽을 때에는 Input, 파일로 쓰거나 외부로 전송할 때에는 Output
- 초기 단계의 자바에서는 I/O 처리를 위해 java.io 패키지에 있는 클래스를 제공했는데, 바이트 기반의 데이터를 처리하기 위해 여러 종류의 스트림이라는 클래스를 제공
- 스트림은 끊기지 않고 연속적인 데이터를 말하며, 읽는 작업은 InputStream, 쓰는 작업은 OutputStream을 통해서 작업하도록 함
- 바이트가 아닌 char 기반 문자열은 Reader, Writer를 사용
- JDK 1.4부터는 빠른 I/O를 위해 버퍼와 채널기반으로 데이터를 처리하는 NIO가, Java 7에서는 NIO2가 추가됨

### 6.2 File 클래스
- java.io 패키지에 있는 File 클래스. Java 7부터는 NIO2가 등장하며 java.nio.file 패키지의 Files 클래스가 더 많이 쓰임. 모든 메소드가 static으로 선언된 Files 클래스와 달리 File 클래스는 객체를 생성하여 사용해야 함
- 생성자
    - File(String pathname)	단일 문자열 경로
    - File(String parent, String child)	부모·자식 문자열 조합
    - File(File parent, String child)	부모를 File 객체로 사용

    ```
    import java.io.File;

    public class FileSample {
        public static void main(String[] args) {
            FileSample sample = new FileSample();

            String pathName = "C:\\godofjava\\text";
            // String pathName = "/godofjava/text";  // 유닉스

            sample.checkPath(pathName);
        }

        public void checkPath(String pathName) {
            File file = new File(pathName);
            file.mkdirs();
            System.out.println(pathName + " is exists? = " + file.exists());
        }
    }
    ```

    - pathName을 보면 역슬래시가 연달아 \\사용되고 있는데 자바에서 String 안에 역슬래시를 한 번만 쓰면 그 뒤에 단에 따라 약속된 특수기호로 인식하기 때문(\t, \n 등). 별개로 유닉스 계열 OS는 /로 디렉토리를 구분함
    - 위 예제에서 pathName은 디렉토리 경로이며 해당 경로의 디렉토리들(godofjava, text)을 생성하기 위해 mkdirs()메소드 사용. 만약 하나의 디렉토리만 생성하면 된다면 mkdir()을 사용하면 됨
    - 경로를 생성했으므로 \godofjava\text is exists = true가 출력됨
- 파일 종류나 권한, 생성일을 확인하는 메소드는 아래 예제로 확인

    ```
    public void checkFileMethods(String pathName) {
        File file = new File(pathName);

        System.out.println(pathName + " is directory? = " + file.isDirectory());
        System.out.println(pathName + " is file? = " + file.isFile());
        System.out.println(pathName + " is hidden? = " + file.isHidden());

        // 실행중인 자바 프로그램이 해당 File 객체에 대한 읽기/쓰기/실행 권한이 있는지 확인
        System.out.println(pathName + " can read? = " + file.canRead());
        System.out.println(pathName + " can write? = " + file.canWrite());
        System.out.println(pathName + " can execute? = " + file.canExecute());

        System.out.println(pathName + " last modified = " + new Date(file.lastModified()));
    }
    ```

- 파일을 삭제하려면 delete() 메소드 사용. 정상삭제된 경우 true를 반환함
- 디렉토리 파일이 아닌 일반 파일을 처리하고 확인하는 메소드는 아래 예제로 확인

    ```
    public class FileManageClass {

        public static void main(String[] args) {
            FileManageClass sample = new FileManageClass();

            String pathName = File.separator + "godofjava" + File.separator + "text";
            String fileName = "test.txt";

            sample.checkFile(pathName, fileName);
        }

        public void checkFile(String pathName, String fileName) {
            File file = new File(pathName, fileName);

            try {
                System.out.println("Create result = " + file.createNewFile());
                getFileInfo(file);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        public void getFileInfo(File file) throws IOException {
            System.out.println("Absolute path = " + file.getAbsolutePath());
            System.out.println("Absolute file = " + file.getAbsoluteFile());

            System.out.println("Canonical path = " + file.getCanonicalPath());
            System.out.println("Canonical file = " + file.getCanonicalFile());

            System.out.println("Name = " + file.getName());
            System.out.println("Path = " + file.getPath());
        }
    }
    ```

    - createNewFile()로 비어있는 새 파일 생성. IOExcetpion을 던지므로 try-catch로 묶어줘야 함
    - 출력 결과는 아래와 같음

        ```
        Create result = true    // 파일 생성 성공. 만약 이미 파일이 있었다면 false가 됨
        Absolute path = C:\godofjava\text\test.txt
        Absolute file = C:\godofjava\text\test.txt
        Canonical path= C:\godofjava\text\test.txt
        Canonical file = C:\godofjava\text\test.txt
        Name = test.txt
        Path = \godofjava\text\test.txt
        ```

    - getFileInfo()에서 ~Path()메소드는 전체 경로를 ~File() 메소드는 File 객체 리턴
    - absolute path와 canonical path는 둘 다 절대경로이지만 표현 방식에 차이가 있음. absolute path가 현재 경로 기준으로 계산한 절대경로라면 canonical path는 파일 시스템 기준 유일하게 표현할 수 있는 절대경로
        - absolute path = C:\temp\..\real\test.txt
        - canonical path = C:\real\test.txt
    - File 객체가 일반 파일을 담고 있을 때 getPath()를 사용하면 경로+파일이름을 출력함. 경로만 출력하려면 file.getParent() 사용
- 디렉토리에 있는 목록을 확인하는 list 메소드
    - static File[] listRoots() : 파일 시스템의 루트 디렉터리 목록을 리턴. (예: "C:\\", "D:\\")
    - String[] list() : 현재 디렉터리 하위 목록 리턴
    - String[] list(FilenameFilter filter)
    - File[] listFiles()
    - File[] listFiles(FileFilter filter)
    - File[] listFiles(FilenameFilter filter)
- FileFilter와 FilenameFilter는 각각 accept라는 메소드가 정의된 인터페이스
    - FileFilter : boolean accept(File pathname)
    - FilenameFilter : boolean accept(File dir, String name)
        - 여기서 dir은 부모 디렉토리
    - 인터페이스를 상속받아 accept를 구현한 필터를 정의하면서 필요한 목록만 검색하도록 할 수 있음. FilenameFilter가 파일 이름을 바로 알 수 있어 파일 확장자로 거르는 작업을 하기 용이해보이지만, 디렉터리와 파일을 구분하지 못하기 때문에 .jpg로 끝나는 디렉터리가 있으면 걸러낼 수가 없음
    - fileName.endWith(".jpg") 같이 확장자를 걸러내는 필터 구현 가능

### 6.3 InputStream과 OutputStream
- 자바 I/O는 기본적으로 InputStream과 OutputStream이라는 abstract 클래스를 통해 제공됨. 해당 클래스들의 자식 클래스들을 통해 읽고 쓸 수 있음
- InputStream은 Closeable 인터페이스를 구현하는데, 이 인터페이스를 구현하면 해당 리소스는 close() 메소드로 닫으라는 것을 의미함
- java.io 패키지에 있는 클래스를 사용할 때는 작업이 종료되면 해당 리소스를 다른 클래스에서 작업할 수 있도록 닫아줘야 함
- 리소스는 스트림을 통해 작업할 수 있는 모든 것을 말하며 파일이 될 수도, 네트워크 연결이 될 수도 있음
- InputStream 클래스에는 다양한 메소드들이 선언되어 있는데, 가장 중요한 건 read(), close() 메소드
- InputStream을 확장한 클래스 중 주로 많이 사용되는 클래스로 FileInputStream, FilterInputStream, ObjectInputStream 등이 있음
- FilterInputStream의 생성자는 FileInputStream, ObjectInputStream와 달리 protected로 선언되어 상속 받은 클래스에서만 객체를 생성할 수 있음
- OutputStream은 Closeable, Flushable 인터페이스를 추가로 구현함. Flushable 인터페이스에는 flush() 메소드가 선언되어 있음. 리소스에 데이터를 쓸 때 매번 쓰기 작업을 요청할때 마다 저장하면 효율이 안 좋으므로 버퍼를 두고 어느정도 차게 되면 한번에 저장하는데 flush()는 현재 버퍼에 있는 내용을 기다리지 말고 바로 저장하는 것
- OutputStream는 write(), flush(), close() 메소드를 가지며 OutputStream을 확장한 자식클래스는 InputStream와 종류가 비슷함
- 스트림은 byte를 다루기 위한 것으로 주로 네트워크를 처리할 때 사용되며 char 기반의 문자열을 처리할 때는 Reader, Writer을 쓰는 편이 좋음

### 6.4 Reader와 Writer
- Reader는 Readable, Closeable 인터페이스를 구현한 추상 클래스로 InputStream과 유사한 메소드들을 가짐. Reader를 확장한 클래스들 중에서는 BufferedReader, InputStreamReader가 많이 사용됨
- Writer는 Appendable, Closeable, Flushable 인터페이스를 구현한 추상 클래스. OutputStream와 유사한 메소드를 갖고 있지만 append()라는 메소드가 존재한다는 점이 다름
    - Writer append(char c)
    - Writer append(CharSequence csq)
    - Writer append(CharSequence scq, int start, int end) : 매개 변수로 넘어온 CharSequence 값을 해당 CharSequence 값의 start 인덱스부터 end 인덱스까지만 추가
    - CharSequence 인터페이스의 대표적인 구현 클래스에는 StringBuilder, StringBuffer가 있으며 이것은 대부분의 문자열을 다 받아서 처리한다는 의미
    - 문자열이 String 타입이면 write() 메소드를 사용해도 무방하나 StringBuilder, StringBuffer로 문자열을 만들면 append() 사용하는 게 훨씬 편함
- 아래는 Writer 추상 클래스의 구현 중 하나인 FileWriter 클래스 예제. FileWriter는 파일에 문자 단위로 데이터를 기록할 때 주로 사용됨

    ```
    public class ManageTextFile {

        public static void main(String[] args) {
            ManageTextFile manager = new ManageTextFile();

            int numberCount = 10;
            String fullPath = File.separator + "godofjava" + File.separator + "text"
                    + File.separator + "numbers.txt";

            manager.writeFile(fullPath, numberCount);
        }

        public void writeFile(String fileName, int numberCount) {
            FileWriter fileWriter = null;
            BufferedWriter bufferedWriter = null;

            try {
                File file = new File(fileName);

                // 현재 파일 객체의 상위 디렉토리 경로를 생성
                file.getParentFile().mkdirs();

                // Writer는 파일이 없으면 새로 생성해줌
                fileWriter = new FileWriter(file);  

                // Writer 객체를 매개변수로 받아 BufferedWriter 객체 생성
                bufferedWriter = new BufferedWriter(fileWriter);    

                for (int i = 0; i <= numberCount; i++) {
                    bufferedWriter.write(Integer.toString(i));
                    bufferedWriter.newLine();   // 줄 바꿈
                }

                System.out.println("Write success !!!");

            } catch (IOException ioe) {
                ioe.printStackTrace();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (bufferedWriter != null) {
                    try {
                        bufferedWriter.close();
                    } catch (IOException ioe) {
                        ioe.printStackTrace();
                    }
                }

                if (fileWriter != null) {
                    try {
                        fileWriter.close();
                    } catch (IOException ioe) {
                        ioe.printStackTrace();
                    }
                }
            }
        }
    }
    ```

    - Writer의 write(), append()는 버퍼없이 바로 쓰므로 대신 BufferedWriter 클래스를 사용함
    - FileWriter 객체 생성 시 IOException이 발생할 수 있으므로 try-catch로 감싸줘야 함. 여기서 IOException은 다음의 상황에서 발생할 수 있음
        - 매개 변수로 넘어온 파일 이름이 파일이 아닌 경로
        - 해당 파일을 권한 등의 문제로 생성 불가
        - 파일이 존재하지만 여러 이유로 파일을 열 수가 없음
    - try 블록에 close()를 넣으면 중간에 예외가 발생할 경우 호출되지 않을 수 있으므로 finally 블록에 넣어줘야 함. finally에서 FileWriter, BufferedWriter 객체를 close()하려면 try 문장 전에 선언해줘야 함
    - 예제에서 FileWriter, BufferedWriter 순으로 객체를 생성했는데, 닫아줄대는 생성할때의 역순으로 닫아줘야 정상적인 처리가 가능함
    - FileWriter 생성자는 FileWriter(File)외에도 여러가지가 있는데 FileWriter(File file, boolean append)에서 append 값을 true로 지정하면 다시 생성자를 실행할 때 기존 파일에 붙여쓰기가 되고, false이면 덮어쓰기가 됨
- FileReader 클래스를 이용한 텍스트 파일 읽기 예제는 위의 FileWriter 예제에서 Writer를 Reader로 변경해주면 나머지는 유사하며, try 블록에서 데이터를 읽는 부분만 다름

    ```
    String data;
    while ((data=bufferedReader.readLine()) != null){
        System.out.println(data);
    }
    ```

    - while 소괄호 안에 두개 이상의 문장이 포함될 수 없기때문에 readLine()으로 읽어들인 데이터를 data에 담아 null인지 확인하는 위와 같은 방법을 주로 사용
- java.util 패키지의 Scanner 클래스나 Java 7에서 제공하는 Files 클래스를 사용하면 훨씬 쉽게 파일을 읽을 수 있음. Scanner 클래스는 텍스트 기반의 기본 자료형이나 문자열 데이터를 처리하기 위한 클래스로 정규 표현식을 사용하여 데이터를 잘라 처리할 수도 있음

## 7. Serializable과 NIO

### 7.1 Serializable
- Serializable 인터페이스 자체에는 아무런 메소드도 정의되어 있지 않지만, 만든 클래스가 파일에 읽거나 쓸 수 있게 하거나 다른 서버로 보내거나 받을 수 있게 하려면 이 인터페이스를 구현해야 함
- Serializable 인터페이스를 구현한 후에는 serialVersionUID 값을 지정해 주는 것이 좋음. 별도로 지정하지 않으면 자바 소스가 컴파일될 때 자동 생성됨
- static final long serialVersionUID = 1L; 과 같이 반드시 static final long serialVersionUID으로 선언해야 함. serialVersionUID는 해당 객체의 버전을 명시하는데 사용
- 코드에서 해당 객체를 읽어올 때 읽어오는 쪽에서도 해당 클래스가 존재하여 현재 JVM에 로드되어야 함. 이 때 클래스 이름이 같더라도 이 ID가 다르면 다른 클래스로 인식함. 또한 같은 ID라도 변수의 개수나 타입 등이 다르면 다른 클래스로 인식함

#### 7.1.1 객체 저장 및 읽기
- ObjectOutputStream 클래스를 이용하여 객체를 저장할 수 있음

    ```
    public class SerialDTO implements Serializable {

        private String bookName;
        private int bookOrder;
        private boolean bestSeller;
        private long soldPerDay;

        public SerialDTO(String bookName, int bookOrder, boolean bestSeller, long soldPerDay) {
            super();
            this.bookName = bookName;
            this.bookOrder = bookOrder;
            this.bestSeller = bestSeller;
            this.soldPerDay = soldPerDay;
        }

        @Override
        public String toString() {
            return "SerialDTO [bookName=" + bookName +
                    ", bookOrder=" + bookOrder +
                    ", bestSeller=" + bestSeller +
                    ", soldPerDay=" + soldPerDay +
                    "]";
        }
    }
    ```

    ```
    public class ManageObject {

        public static void main(String[] args) {
            ManageObject manager = new ManageObject();

            String fullPath = separator + "godofjava" + separator + "text"
                    + separator + "serial.obj"; // 객체는 .obj 파일에 저장

            SerialDTO dto = new SerialDTO("GodOfJavaBook", 1, true, 100);

            manager.saveObject(fullPath, dto);
        }

        public void saveObject(String fullPath, SerialDTO dto) {
            FileOutputStream fos = null;
            ObjectOutputStream oos = null;

            try {
                fos = new FileOutputStream(fullPath);   // FileOutputStream 객체 생성
                oos = new ObjectOutputStream(fos);       // 생성한 FileOutputStream 객체를 매개변수로 넘겨 해당 객체가 fullPath 파일에 저장되게 함

                oos.writeObject(dto);                    // 직렬화하여 파일에 쓰기
                System.out.println("Write Success");

            } catch (Exception e) {
                e.printStackTrace();

            } finally {
                // ObjectOutputStream 닫기
                if (oos != null) {
                    try {
                        oos.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }

                // FileOutputStream 닫기
                if (fos != null) {
                    try {
                        fos.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
    ```

-  만약 위의 SerialDTO에서 Serializable 인터페이스를 구현하지 않았을경우 실행하면 NotSerializableException 발생
- 위 예제 실행 시 C:\godofjava\text 디렉터리에 serial.obj 파일이 생성됨. 객체는 바이너리로 저장되어 확인해보긴 어려움
- 객체를 읽어오려면 앞 예제와 동일하게 Output 대신 Input으로 된 클래스들을 사용하면 됨. 달리 바뀐 부분은 try 블록의 아래와 같음

    ```
    // saveObject() 메소드와 유사
    public void loadObject(String fullPath){
        ...
        try {
            fis = new FileInputStream(fullPath);
            ois = new ObjectInputStream(fis); 

            // readObject() 메소드의 리턴 타입이 Object이므로 형 변환
            Object obj = ois.readObject();
            SerialDTO dto = (SerialDTO)obj;
            System.out.println(dto);
        }
        ...
    }
    ```

- 출력 결과는 아래와 같음
    
    ```
    SerialDTO [bookName=GodOfJavaBook, bookOrder=1, bestSeller=true, soldPerDay=100]
    ```
- 만약 SerialDTO 클래스에 인스턴스 변수를 새로 추가해서 다시 실행하면 SerialVersionUID가 다르다는 InvalidClassException 예외 메시지가 출력됨. Serializable을 구현한 객체의 형태가 변경되면 컴파일 시 serialVersionUID가 다시 생성됨
- SerialDTO 클래스에 private static final long serialVersionUID = 1L;를 추가하고 saveObject()를 다시 실행하여 obj 파일 내용 갱신 후 loadObject() 재실행하면 정상 실행됨
- 만약 serialVersionUID는 같은데 저장되어 있는 객체(현재 JVM에 로드된 객체)에 bookName 인스턴스 변수명을 bookNames로 읽는 객체와 다르게 하면 해당 값은 null로 처리됨. 저장되어 있는 객체에서 찾지 못하기 때문

    ```
    SerialDTO [bookNames=null, bookOrder=1, bestSeller=true, soldPerDay=100]
    ```

- 위와 같이 null로 처리될 뿐 예외가 발생하진 않지만, 내용이 바뀌어도 알 수가 없으므로 데이터가 바뀌면 serialVersionUID의 값도 바꾸는 습관을 가져야 함

#### 7.1.2 transient 예약어
- 아래와 같이 Serializable을 구현한 클래스 인스턴스 변수의 선언문 앞에 transient 예약어 추가

    ```
    transient private int bookOrder;
    ```

- transient 예약어를 사용하여 선언한 변수는 Serializable 대상(저장 대상)에서 제외됨. 따라서 출력이 아래와 같이 0으로 됨

    ```
    SerialDTO [bookName=GodOfJavaBook, bookOrder=0, bestSeller=true, soldPerDay=100]
    ```

- 패스워드 변수처럼 보안상 중요한 변수나 꼭 저장해야 할 필요가 없는 변수에 사용

### 7.2 NIO
- JDK 1.4부터 제공되는 NIO는 오로지 속도 때문에 추가됨
- NIO는 스트림 대신 채널과 버퍼를 사용함. 채널은 물건을 중간에서 처리하는 도매상, 버퍼는 도매상에게서 물건을 사고 소비자에게 파는 소매상과 비슷함. 데이터를 주고받을 때는 소매상인 버퍼를 통해 처리
- NIO에서 제공하는 Buffer는 java.nio.Buffer 클래스를 확장하여 제공되며, ByteBuffer, CharBuffer, DoubleBuffer.. 및 기타 등등 여러 확장이 있음
- 버퍼의 상태 및 속성을 확인하기 위한 메소드
    - int capacity() : 버퍼 크기 리턴
    - int limit() : 읽기 또는 쓰기 가능한 최대 위치 리턴
    - int position() : 현재 버퍼의 위치 리턴
- 버퍼에서 위치를 변경하는 메소드
    - Buffer flip() : limit 값을 현재 position으로 변경 후 position을 0으로 이동
    - Buffer mark() : 현재 position을 mark
    - Buffer reset() : 버퍼의 position을 mark한 곳으로 이동
    - Buffer rewind() : 현재 버퍼의 position을 0으로 이동
    - int remaining() : limit - position 계산 결과 리턴
    - boolean hasRemaining() : postion과 limit 값에 차이가 있을 경우 true 리턴
    - Buffer clear() : 버퍼 내용을 지우고 현재 position 0으로 이동, limit 값을 버퍼 크기로 변경
- NIO는 파일을 읽고 쓰거나 복사 또는 네트워크로 데이터를 주고 받을 때도 사용할 수 있음
- 파일 read/write 예제

    ```
    public void writeFile(String fileName, String data) throws Exception {
        FileChannel channel = new FileOutputStream(fileName).getChannel();

        byte[] byteData = data.getBytes();
        ByteBuffer buffer = ByteBuffer.wrap(byteData);

        channel.write(buffer);
        channel.close();
    }
    ```

    1. FileOutputStream 클래스의 getChannel() 메소드를 호출하여 FileChannel 객체 생성
    2. ByteBuffer의 wrap() static 메소드를 호출하여 ByteBuffer 객체 생성. wrap()은 이미 있는 배열을 그대로 버퍼로 감싸서 사용함
    3. FileChannel 객체의 write() 메소드에 ByteBuffer 객체를 넘겨 파일에 쓰도록 함

    ```
    public void readFile(String fileName) throws Exception {
        FileChannel channel = new FileInputStream(fileName).getChannel();

        ByteBuffer buffer = ByteBuffer.allocate(1024);

        channel.read(buffer);
        buffer.flip();

        while (buffer.hasRemaining()) {
            System.out.print((char) buffer.get());
        }

        channel.close();         // 마지막에 닫기
    }
    ```

    1. FileInputStream 클래스의 getChannel() 메소드를 호출하여 FileChannel 객체 생성
    2. 지정한 크기의 byte 버퍼를 생성하는 ByteBuffer의 allocate() 메소드 실행
    3. FileChannel 객체의 read() 메소드에 ByteBuffer 객체를 넘겨 데이터가 담기게 함
    4. ByteBuffer의 get() 메소드는 한 바이트씩 데이터 읽는 작업 수행

## 8. 네트워크 프로그래밍

### 8.1 Socket 클래스를 사용한 TCP 통신
- 데이터 전송을 보장하는 TCP 통신을 위해 java.net 패키지의 Socket 클래스를 사용하여 데이터 전송
- Socket 클래스 객체를 데이터를 보내는 쪽(주로 클라이언트)에서 생성해서 사용하면, 데이터를 받는 쪽(주로 서버)에서 요청에 대한 Socket 객체를 생성하여 데이터를 처리. Socket 객체는 서로 원격에 있는 장비와의 연결 상태를 보관함
- 데이터를 보내는 쪽에서는 Socket 클래스를, 받는 쪽에서는 ServerSocket 클래스를 사용. 받는 쪽에선 new로 Socket 객체 생성할 것 없이 ServerSocket 클래스가 제공하는 메소드에서 클라이언트 요청을 감지하면 Socket 객체를 자동 생성하여 전달해줌
- ServerSocket 생성자
    - ServerSocket()	포트 없이 생성 → 나중에 bind() 가능
    - ServerSocket(int port)	포트 지정
    - ServerSocket(int port, int backlog)	포트 + 대기 큐 크기 지정
    - ServerSocket(int port, int backlog, InetAddress bindAddr)	포트 + 대기 큐 + 특정 IP 에 바인딩
- backlog는 ServerSocket 객체가 바빠서 연결 요청을 바로 처리하지 못하고 대기시킬 때 대기 큐의 크기. 지정하지 않으면 50개가 기본값
- bindAddr는 특정 주소에서만 접근이 가능하도록 지정할 때 사용
- ServerSocket()을 제외한 생성자들을 사용하면 객체 생성 즉시 연결을 대기할 수 있는 상태가 되며, ServerSocket()는 accept 메소드를 통해 별도의 연결작업을 해야 함
    - Socket accept() : 새로운 소켓 연결을 기다리고 연결되면 Socket 객체 리턴
    - void close() : 소켓 연결을 종료
- close() 안하면 JVM에서 계속 동작되므로 해당 포트를 다른 프로그램에서 사용할 수 없음
- Socket 클래스 생성자
    - Socket()
    - Socket(Proxy proxy)
    - Socket(SocketImpl impl)
    - Socket(InetAddress address, int port)
    - Socket(InetAddress address, int port, InetAddress localAddr, int localPort)
    - Socket(String host, int port)
    - Socket(String host, int port, InetAddress localAddr, int localPort)
- 위의 3개 생성자를 제외한 나머지 생성자들은 모두 객체 생성과 함께 지정된 서버에 접속함
- Socket(String host, int port)가 가장 사용하기 편리함
- 마찬가지로 close()는 필수
- 아래는 소켓을 대기하는 서버 예제

    ```
    public void startServer() {
        ServerSocket server = null;
        Socket client = null;

        try {
            server = new ServerSocket(9999);
            System.out.println("Server started.");

            while (true) {
                System.out.println("Server: Waiting for request.");
                client = server.accept();
                System.out.println("Server: Accepted.");

                InputStream stream = client.getInputStream();
                BufferedReader in = new BufferedReader(
                        new InputStreamReader(stream));

                String data;
                StringBuilder receivedData = new StringBuilder();

                while ((data = in.readLine()) != null) {
                    receivedData.append(data);
                }

                System.out.println("Received data: " + receivedData);

                in.close();
                stream.close();
                client.close();

                // EXIT 메시지 받으면 서버 종료
                if ("EXIT".equals(receivedData.toString())) {
                    System.out.println("Stop SocketServer");
                    break;
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (server != null) {
                try {
                    server.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }  
    ```

- 9999번 포트에서 대기. accept()로 원격 호출 대기상태로 전환하고 socket 객체를 리턴받아 client 변수에 할당
- Socket 클래스의 getInputStream() 메소드로 데이터를 읽기 위한 InputStream 객체를 받음. 상대에게 데이터를 쓰는(전송하는) 쪽은 getOutputStream() 사용
- 아래는 데이터를 전송하는 클라이언트 예제

    ```
    public void sendSocketSample() {
        for (int loop = 0; loop < 3; loop++) {
            sendSocketData("I liked java at " + new Date());
        }
        sendSocketData("EXIT");
    }

    public void sendSocketData(String data) {
        Socket socket = null;

        try {
            System.out.println("Client: Connecting");
            socket = new Socket("127.0.0.1", 9999);   // 서버 접속
            System.out.println("Client: Connect status=" + socket.isConnected());

            Thread.sleep(1000); // 현재 실행 중인 스레드를 1초 동안 멈춤

            OutputStream stream = socket.getOutputStream();
            BufferedOutputStream out = new BufferedOutputStream(stream);

            byte[] bytes = data.getBytes();
            out.write(bytes);                         // 데이터 전송
            out.flush();

            System.out.println("Client: Sent data" + data);

            out.close();
            stream.close();

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (socket != null) {
                try {
                    socket.close();                   // 소켓 종료
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }    
    ```

- 같은 장비의 같은 포트로 소켓 객체 생성(127.0.0.1, 9999)
- out.close() 를 호출하면 out 이 감싸고 있는 기반(OutputStream)도 같이 닫히지만 BufferedOutputStream 을 제거하거나 구조가 바뀔 때를 대비하여 명시적으로 해주는 게 좋음
- 위의 예제를 실행하며 발생할 수 있는 예외는 2가지가 있음
    - java.net.BindException (Address already in use) : 이미 해당 포트로 서버를 띄워놓음
    - java.net.ConnectException (Connection refused) : 서버 실행 안하고 클라이언트 프로그램만 실행했을 때

### 8.2 DatagramSocket 클래스를 사용한 UDP 통신
- 데이터의 유실이 있어도 문제가 없을 때 사용. TCP보다 빠름
- DatagramSocket 클래스 하나에서 보내는 역할과 받는 역할을 모두 수행하며, 스트림을 사용하지 않고 DatagramPacket이라는 클래스를 사용함
- DatagramSocket 클래스 생성자
    - DatagramSocket() : 포트 자동 배정
    - DatagramSocket(DatagramSocketImpl impl)
    - DatagramSocket(int port)
    - DatagramSocket(int port, InetAddress laddr)
    - DatagramSocket(SocketAddress bindaddr) : IP+포트 혼합 바인딩
- 마찬가지로 close() 메소드로 닫아주어야 하며, 데이터를 주고 받기위해 아래 메소드 제공
    - void receive(DatagramPacket packet) : 데이터를 받기 위해 대기. 데이터를 받으면 packet 객체에 저장
    - void send(DatagramPacket packet) : packet 객체에 있는 데이터 전송
- DatagramPacket 클래스 생성자
    - DatagramPacket(byte[] buf, int length) : 유일한 수신용 객체 생성자
    - DatagramPacket(byte[] buf, int length, InetAddress addr, int port)
    - DatagramPacket(byte[] buf, int offset, int length)
    - DatagramPacket(byte[] buf, int offset, int length, InetAddress addr, int port)
    - DatagramPacket(byte[] buf, int offset, int length, InetAddress addr)
    - DatagramPacket(byte[] buf, int length, InetAddress addr)
- byte[] buf는 전송되는 데이터. offset을 넣을 경우 해당 offset (위치)값부터 데이터를 전송
- length는 byte[] buf에서 몇 바이트를 전송하거나 수신하는 데 사용할 것인지를 지정하므로, length가 byte[] buf 크기보다 크게 설정되면 IllegalArgumentException 발생
- DatagramPacket 클래스의 주요 메소드로 getData()는 바이트 배열로 전송받은 데이터를 리턴하고 getLength()는 전송받은 데이터의 길이를 int 타입으로 리턴
- 아래는 UDP 통신 서버 쪽 예제

    ```
    public void startServer() {
        DatagramSocket server = null;

        try {
            server = new DatagramSocket(9999);
            int bufferLength = 256;
            byte[] buffer = new byte[bufferLength];

            DatagramPacket packet = new DatagramPacket(buffer, bufferLength);

            while (true) {
                System.out.println("Server: Waiting for request.");

                server.receive(packet);

                int dataLength = packet.getLength();  // 실제 수신 데이터 길이
                System.out.println("Server: received. Data length=" + dataLength);

                String data = new String(packet.getData(), 0, dataLength);
                System.out.println("Received data: " + data);

                if ("EXIT".equals(data)) {
                    System.out.println("Stop DatagramServer");
                    break;
                }
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (server != null) {
                server.close();
            }
            ...
        }
    }
    ```
- new String(packet.getData(), 0, dataLength);로 UDP로 받은 바이트 데이터를 실제 수신 길이만큼 문자열로 변환
- 아래는 UDP 통신 클라이언트 쪽 예제

    ```
    public void sendDatagramData(String data) {
        DatagramSocket client = null;
        try {
            client = new DatagramSocket();
            InetAddress address = InetAddress.getByName("127.0.0.1");
            byte[] buffer = data.getBytes();
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 9999);

            client.send(packet);
            System.out.println("Client: Sent data");

            client.close();
            Thread.sleep(1000);

        } catch (Exception e) {
            e.printStackTrace();
        }
        ...
    ```
    
- UDP는 TCP와 다르게 데이터가 성공적으로 전송되지 않아도 예외를 발생시키지 않으므로, 서버 프로그램 없이 클라이언트만 실행시켜도 System.out.println("Client: Sent data");가 정상 출력됨

## 9. Java 7

### 9.1 Java 7에서 달라진 것들
- 숫자 표시 방법 보완
    - byte, short, int, long과 같은 정수형은 원래 8, 10, 16 진수로 표현이 가능했음. 숫자 앞에 아무런 접두사가 없으면 10진수, 숫자 앞에 0을 넣으면 8진수, 0x를 숫자 앞에 넣으면 16진수
    
        ```
        int decVal = 1106;
        int octVal = 02122;
        int hexVal = 0x452;
        ```

    - 위의 값들을 println으로 출력하면 모두 10진수로 출력됨(1106)
    - Java 7부터는 2진수 표현이 추가됨. 숫자 앞에 0b를 추가

        ```
        int binaryVal = 0b10001010010;
        ```
    - 또한 숫자 단위에 구분자 _ 를 추가할 수 있음. _는 무조건 숫자 사이에만 넣어줄 수 있음
        - 숫자 사이면 가능하므로 진수 표현 접두사를 예시로 들면
            - 0b_101010 -> 불가능
            - 0_101010 -> 가능

        ```
        int binary = 0b100_0101_0010;
        int million = 1_000_000;
        ```

- switch 문에서 String 사용 가능
    - Java 6까지는 switch-case 문장에 정수형만 사용 가능했는데, 7부터는 String도 사용가능
    - String 을 사용할 경우 문자열이 null이면 NullPointerException 발생하므로 null 체크 필수
- 제네릭을 쉽게 사용할 수 있는 Diamond <>
    - 이전까지는 제네릭을 사용할 때 생성자에도 해당 타입들을 상세하게 명시했어야 했음

        ```
        HashMap<String, Integer> map = HashMap<String, Integer>();
        ```

    - Java 7부터는 <>를 쓰면 변수 선언에 명시된 타입으로 자동으로 채워짐

        ```
        HashMap<String, Integer> map = HashMap<>();
        ```

    - 유의할 점
        - 아래와 같이 <> 없이 모두 명시적으로 지정하면 당연히 문제가 없음. 생성자에 <>를 빼먹어도 경고가 발생하긴 하지만 실행엔 큰 문제가 없음
            
            ```
            public class GenericClass <X> {
                private X x;
                private Object o;
                public <T> GenericClass (T t){
                    this.o=t;
                    System.out.println("T type="+t.getClass().getName());
                }
                
                public void setValue(X x){
                    this.x = x;
                    System.out.println("X type="+x.getClass().getName());
                }
            }

            public void makeObjects3(){
                GenericClass<Integer> generic1 = new <String> GenericClass<Integer>("String");  // <> 없이 모두 명시
                GenericClass<Integer> generic2 = new <String> GenericClass("String");   // 생성자에 <> 빼먹음
                GenericClass<Integer> generic3 = new <String> GenericClass<>("String"); // 에러
                generic1.setValue(999);
            }
            ```

        - 단, 생성자에 있는 new와 클래스 이름 사이에 타입 이름을 명시적으로 두려면 <>를 사용하면 안됨. 따라서 generic3 생성자 부분은 에러가 발생함
- @SafeVarargs 어노테이션
    - 제네릭 사용 시 발생 가능한 문제 중 하나로 reifiable 하지 않은 가변 매개변수(varargs) 타입이 있음
    - reifiable 하다는 건 런타임에도 타입 정보가 남아있는 타입. int 같은 기본형, String, List, List<?> 같은 타입이 해당함
    - non reifiable은 컴파일 시 타입 정보가 손실되는 타입으로 List<String> 같은 제네릭이 해당함
    - Collections.addAll() 메소드는 가변 매개 변수를 사용하는데, 매개 변수로 제네릭 타입 객체를 넘기면 경고가 발생함. 제네릭 매개 변수가 내부적으로는 Object 배열로 처리되기 때문
        
        ```
        // api 문서 상의 addAll
        public static <T> boolean addAll(Collection<? super T> c, T... elements)

        // 내부적으로는 Object 배열로 처리
        public static <T> boolean addAll(Collection<? super T> c, java.lang.Object[] elements)
        ```
    
    - 제네릭 <T>은 한 가지 타입인데 Object 배열로 매개변수를 받게되며 여러 타입 객체들이 들어가게 될 수 있으므로, 잠재적으로 문제가 발생할 수 있음
    - 이러한 경고를 없애려면 @SafeVarargs 어노테이션을 메소드 선언부에 추가하면 됨. 컴파일러에게 이 메서드는 가변 제네릭 매개변수 배열을 안전하게 다룬다고 알려주는 것
    - @SafeVarargs는 아래의 조건일 때 사용 가능
        - 가변 매개 변수를 사용하고
        - final이나 static 또는 private(이건 Java 9부터)로 선언되어 있음
            - 부모 메서드에 안전하다는 의미로 @SafeVarargs를 붙여도 자식 클래스에서 오버라이딩하면서 heap pollution이 발생할 수 있음 
            - 해당 메소드를 오바라이딩 할 수 없게 해야함
    - 단, @SafeVarargs 어노테이션을 사용해도 가변 매개 변수가 reifiable 타입이고 메소드 내에서 매개 변수를 다른 변수에 대입하는 작업을 수행할 경우 경고가 발생함
- 예외 처리 시 다중 처리 기능
    - Java 7부터 catch 블록에서 처리하는 방식이 동일하다면 아래와 같이 파이프(`|`) 로 묶을 수 있음
        
        ```
        Scanner scanner = null;
        try {
            scanner = new Scanner(new File(fileName), encoding);
            System.out.println(scanner.nextLine());
        } catch(IllegalArgumentException | FileNotFoundException | NullPointer Exception exception){
            exception.printStackTrace();
        } finally {
            ...
        }
        ```
    - AutoCloseable 인터페이스가 추가됨. java.io.Closable 인터페이스를 구현한 클래스 중 이 인터페이스를 구현한 클래스는 별도의 close() 호출이 필요없는 try-with-resource 사용 가능
    - try-with-resource를 사용하여 위의 예제를 아래와 같이 단순화
        ```
        try (Scanner scanner=new Scanner(new File(fileName), encoding)){
            System.out.println(scanner.nextLine());
        } catch(IllegalArgumentException | FileNotFoundException | NullPointer Exception exception){
            exception.printStackTrace();
        } 
        ```
    - finally 문장에서 close()를 처리하기 위해 선언문을 try 위로 올려 가독성을 떨어뜨릴 필요가 없어짐
    - try의 소괄호 내에서 2개 객체를 생성할 필요가 있으면 세미콜론(;)으로 구분하여 같이 생성해주면 됨

### 9.2 Java 7에서 추가된 것들

#### 9.2.1 Work Stealing
- Work Stealing은 다중 스레드 환경에서 각 스레드가 자신의 작업 큐(Deque)를 가지고 작업을 처리하다가, 작업이 부족한 스레드가 다른 스레드의 Deque에서 남은 작업을 반대쪽 끝(top)에서 가져가는 방식
    - Deque는 양방향 큐로 양쪽 끝에서 삽입/삭제 가능
- 각 스레드는 자신의 Deque의 bottom에서 작업을 꺼내 처리하며, 다른 스레드가 훔쳐갈 때는 top에서 가져가므로 경합을 최소화할 수 있음
- 자바에서 Fork/Join을 사용하면 해당 라이브러리에서 Work steal 작업을 알아서 수행함
- Fork는 작업을 여러 개로 나누어 여러 스레드에서 실행되게 하고, Join은 여러 스레드에서 수행한 결과를 모으는 것
- Fork/Join 작업의 기본 수행 개념은 아래와 같음

    ```
    if(작업의 단위가 충분히 작을 경우){
        해당 작업을 수행 (연산을 수행)
    } else {
        작업을 반으로 쪼개어 두 개의 작업으로 나눔 <- 시작와 끝 값을 반으로 쪼개 해당 함수를 다시 실행해야함 (Recursive)
        두 작업을 동시 실행시키고, 두 작업이 끝날 때까지 결과를 기다림
    }
    ```

- 위와 같은 방식으로 Fork/Join이 실행되기 때문에 이 연산은 Recursive하게 수행될 때 많이 사용됨
- Fork/Join 기능은 java.util.concurrent 패키지의 RecursiveAction과 RecursiveTask라는 abstract 클래스를 사용해야 함
    - public abstract class RecursiveAction extends ForkJoinTask\<Void\>
    - public abstract class RecursiveTask\<V\> extends ForkJoinTask\<V\>
- 두 클래스가 확장한 ForkJoinTask이라는 abstract 클래스는 Future라는 인터페이스를 구현했는데, 비동기적인 요청을 하고 응답을 기다릴 때 사용되는 인터페이스임
- Fork/Join 작업을 수행하려면 RecursiveAction 또는 RecursiveTask 클래스를 확장하여 연산을 처리하는 compute() 메소드 구현
- 작업을 수행하는 클래스는 ForkJoinPool 클래스를 사용하여 시작되게 함


    |            | Fork/Join 클라이언트 밖에서 호출 | Fork/Join 클라이언트 내에서 호출 |
    |----------------|------------------------|--------------------------|
    | 비동기적 호출 수행    | execute(ForkJoinTask) | ForkJoinTask.fork() |
    | 호출 후 결과 대기(동기) | invoke(ForkJoinTask) | ForkJoinTask.invoke()  |
    | 호출 후 Future 객체 수신 | submit(ForkJoinTask) | ForkJoinTask.fork() |


- 아래는 0부터 10까지 더하는 연산을 Fork/Join으로 작업하는 예제

    ```
    public class GetSum2 extends RecursiveTask<Long> {
        long from, to;

        public GetSum2(long from, long to) {
            this.from = from;
            this.to = to;
        }

        @Override
        public Long compute() {
            long gap = to - from;

            // Sleep for logging clarity
            try {
                Thread.sleep(1000);
            } catch (Exception e) {
                e.printStackTrace();
            }

            log("From=" + from + " To=" + to);

            // Base condition: small range -> direct computation
            if (gap <= 3) {
                long tempSum = 0;
                for (long loop = from; loop <= to; loop++) {
                    tempSum += loop;
                }
                log("Return !! " + from + " ~ " + to + " = " + tempSum);
                return tempSum;
            }

            long middle = (from + to) / 2;

            // First half
            GetSum2 sumPre = new GetSum2(from, middle);
            log("Pre  From=" + from + " To=" + middle);
            sumPre.fork();  // async

            // Second half
            GetSum2 sumPost = new GetSum2(middle + 1, to);
            log("Post From=" + (middle + 1) + " To=" + to);

            // Combine result
            return sumPost.compute() + sumPre.join();
        }

        public void log(String message) {
            String threadName = Thread.currentThread().getName();
            System.out.println("[" + threadName + "] " + message);
        }
    }
    ```

    ```
    public class ForkJoinSample2 {
        static final ForkJoinPool mainPool = new ForkJoinPool();

        public static void main(String[] args) {
            ForkJoinSample2 sample = new ForkJoinSample2();
            sample.calculate();
        }

        public void calculate() {
            long from = 0;
            long to = 10;

            GetSum2 sum = new GetSum2(from, to);
            Long result = mainPool.invoke(sum);

            System.out.println("Fork Join: Total sum of " + from + " ~ " + to + " = " + result);
        }
    }
    ```

    - 작업이 빠르게 처리되어 출력이 안정적으로 되지 않을 수 있어 Thread.sleep(1000)로 지연 추가
    - .compute()는 작업을 즉시 수행하고 .fork()는 비동기 작업 수행이므로 작업을 대기큐에 쌓아둠. 따라서 .compute()로 수행한 작업이 더 먼저 시작됨
    - 동시 실행을 위해 .compute()로 현재 스레드에서 작업을 처리하는 동시에 .join()으로 다른 쪽의 작업 완료를 기다림
    - 직접 실행했을 때 결과는 아래와 같이 출력됨. 출력 순서는 실행 시마다 조금씩 달라질 수 있음

        ```
        [ForkJoinPool-1-worker-1] From=0 To=10
        [ForkJoinPool-1-worker-1] Pre  From=0 To=5
        [ForkJoinPool-1-worker-1] Post From=6 To=10
        [ForkJoinPool-1-worker-1] From=6 To=10
        [ForkJoinPool-1-worker-2] From=0 To=5
        [ForkJoinPool-1-worker-1] Pre  From=6 To=8
        [ForkJoinPool-1-worker-2] Pre  From=0 To=2
        [ForkJoinPool-1-worker-1] Post From=9 To=10
        [ForkJoinPool-1-worker-2] Post From=3 To=5
        [ForkJoinPool-1-worker-2] From=3 To=5
        [ForkJoinPool-1-worker-4] From=0 To=2
        [ForkJoinPool-1-worker-1] From=9 To=10
        [ForkJoinPool-1-worker-3] From=6 To=8
        [ForkJoinPool-1-worker-3] Return !! 6 ~ 8 = 21
        [ForkJoinPool-1-worker-2] Return !! 3 ~ 5 = 12
        [ForkJoinPool-1-worker-4] Return !! 0 ~ 2 = 3
        [ForkJoinPool-1-worker-1] Return !! 9 ~ 10 = 19
        Fork Join: Total sum of 0 ~ 10 = 55
        ```
            
#### 9.2.2 NIO2
- Java 7부터 제공되는 NIO2는 java.io 패키지의 File 클래스의 미흡한 부분을 보완하기 위해 나왔으며 NIO와 이름은 비슷하지만 크게 관련은 없음. 패키지도 java.io인 NIO와 달리 java.nio
- 이전에 지원하지 않았던 파일의 속성, 심볼릭 링크 처리, 파일의 권한을 처리할 수 있고 파일을 삭제하는 delete() 메소드가 실패 시에도 아무런 예외를 발생시키지 않던 문제 보완. 또한 파일이 변경되었는지 여부를 연계된 클래스가 많아 성능상 지장을 주던 lastModified() 메소드를 호출하지 않고도 확인할 수 있게 함
- NIO2에서 File 클래스를 대체하는 클래스
    - Paths
        - 생성자가 없지만 대신 get()이라는 static 메소드로 Path 인터페이스 객체 생성 가능
            - static Path get(String first, String... more)
            - static Path get(URI uri)
            - Java 7부터 java.io 패키지의 File 클래스의 toPath() 메소드를 통해서도 얻을 수 있음
        - Path는 파일과 경로에 대한 정보를 가짐
    - Files
    - FileSystems
        - 현재 사용중인 파일 시스템에 대한 정보를 처리하는 메소드들 제공. getDefault() 메소드로 FileSystem 인터페이스 객체를 얻을 수 있음
    - FileStore
        - 파일을 저장하는 디바이스, 파티션, 볼륨 등에 대한 정보 확인
- 아래는 Path의 메소드를 확인할 수 있는 예제
        
    ```
    public class PathsAndFiles {
        public static void main(String[] args) {
            PathsAndFiles sample = new PathsAndFiles();

            String dir = "C:\\godofjava\\nio\\nio2";
            String dir2 = "C:\\WINDOWS";

            sample.checkPath2(dir, dir2);
        }

        public void checkPath(String dir) {
            Path path = Paths.get(dir);
            System.out.println(path.toString());      // C:\godofjava\nio\nio2
            System.out.println(path.getFileName());   // nio2
            System.out.println(path.getNameCount());  // 3
            System.out.println(path.getParent());     // C:\godofjava\nio
            System.out.println(path.getRoot());       // C:\         
        }

        public void checkPath2(String dir1, String dir2) {
            Path path1 = Paths.get(dir1);
            Path path2 = Paths.get(dir2);

            // 상대 경로 계산 ..\..\..\WINDOWS
            Path relativized = path1.relativize(path2);

                   
            System.out.println("relativized path = " + relativized);

            // 절대 경로 C:\godofjava\..\..\..\WINDOWS
            Path absolute = relativized.toAbsolutePath();
            System.out.println("toAbsolutePath path = " + absolute);

            // 정규화 C:\WINDOWS
            Path normalized = absolute.normalize();
            System.out.println("normalized path = " + normalized);

            // 경로 결합 C:\godofjava\nio\nio2\godofjava
            Path resolved = path1.resolve("godofjava");
            System.out.println("resolved path = " + resolved);
        }
    }
    ```

- Files 클래스 주요 기능
    - 파일, 디렉터리 등 생성 : createDirectory(), createFile(), createSymbolicLink().. 및 기타 등등
    - 삭제 : delete(), deleteIfExists()
        - 실패 시 지우지 않고 예외 발생
    - 읽기와 쓰기 : readAllBytes(), readAllLines(), readAttributes(), write().. 및 기타 등등
        - write() 메소드는 두가지
            - public static Path write(Path path, byte[] bytes, OpenOption... options)
            - public static Path write(Path path, Iterable<? extends CharSequence> lines, Charset cs, OpenOption... options)
        - readAllLines()는 크기가 큰 파일에 사용하면 OutOfMemoryError가 발생할 수 있음
        - Iterable<? extends CharSequence> lines 매개변수에는 Iterable을 구현한 ArrayList, 제네릭으로 String 같은 값이 들어갈 수 있음 (ArrayList\<String\>)
        - OpenOption은 파일을 열 때의 조건으로 StandardOpenOption이라는 Enum 클래스 값이 들어갈 수 있음. 선언된 항목은 아래와 같음
            - APPEND
            - CREATE : 파일이 존재하지 않으면 새로 생성
            - CREATE_NEW
            - DELETE_ON_CLOSE
            - DSYNC
            - READ
            - SPARSE
            - SYNC
            - TRUNCATE_EXISTING
            - WRITE
    - 복사 및 이동 : copy(), move()
        - 아래는 copy() 메소드 매개변수로 들어가는 StandardCopyOption Enum 클래스 항목들
            - ATOMIC_MOVE
            - COPY_ATTRIBUTES
            - REPLACE_EXISTING
    - Stream 및 객체 생성
        - 위의 읽기와 쓰기 메소드를 사용할 때보다 코드가 길어질 수 있지만, 여러 번에 걸쳐 파일에 데이터를 쓰거나, 버퍼 제어나 flush 제어 등 세밀한 조정 가능
        - newBufferedReader(), newBufferedWriter(), newInputStream.. 및 기타 등등
    - 각종 확인 : get으로 시작하는 메소드와 is로 시작하는 메소드들로 파일의 상태를 확인
    - 임시 디렉터리, 파일 생성
        - createTempDirectory(), createTempFile()
- WatchService 클래스
    - 이전에는 파일이 변경되었는지 확인하기 위해 성능상 비효율적인 lastModified() 함수를 호출하여 기존에 저장된 시간과 비교해야 했으나, 주기적으로 호출해야한다는 단점 존재
    - Java 7부터는 WatchService 인터페이스를 사용하여 파일 생성, 수정, 삭제 작업 모니터링 가능

        ```
        public class WatcherSample extends Thread {
            String dirName;

            public static void main(String args[]) throws Exception {
                String dirName = "C:\\godofjava";
                String fileName = "WatcherSample.txt";

                WatcherSample sample = new WatcherSample(dirName);
                sample.setDaemon(true);
                sample.start(); // 스레드 시작

                Thread.sleep(1000);

                for (int loop = 0; loop < 10; loop++) {
                    sample.fileWriteDelete(dirName, fileName + loop);
                }
            }

            public WatcherSample(String dirName) {
                this.dirName = dirName;
            }

            @Override
            public void run() {
                System.out.println("### Watcher thread is started ###");
                System.out.format("Dir=%s\n", dirName);
                addWatcher();
            }

            public void addWatcher() {
                try {
                    Path dir = Paths.get(dirName);
                    WatchService watcher = FileSystems.getDefault().newWatchService();

                    // 디렉토리에 watcher 등록
                    WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);

                    while (true) {
                        System.out.println("Watcher waiting for events...");

                        // 이벤트 발생까지 대기 (blocking)
                        key = watcher.take();

                        // 발생한 이벤트 목록 가져오기
                        List<WatchEvent<?>> eventList = key.pollEvents();

                        for (WatchEvent<?> event : eventList) {
                            Kind<?> kind = event.kind();
                            Path name = (Path) event.context();

                            if (kind == ENTRY_CREATE) {
                                System.out.format("%s created%n", name);
                            } else if (kind == ENTRY_DELETE) {
                                System.out.format("%s deleted%n", name);
                            } else if (kind == ENTRY_MODIFY) {
                                System.out.format("%s modified%n", name);
                            }
                        }

                        // 다시 감시하도록 reset
                        key.reset();
                    }

                } catch (IOException | InterruptedException e) {
                    e.printStackTrace();
                }
            }
            ...
        }
        ```

        - WatchService 객체를 얻는 가장 쉬운 방법은 FileSystems.getDefault()로 기본 파일 시스템 객체를 얻은 후 newWatchService() 호출하여 얻는 것
        - register() 메소드로 어떤 작업에 대해 감시할지 지정. 위의 예제에선 Path와 관련된 StandardWatchEventKinds 클래스의 상수 3가지를 지정함
            - public WatchKey register(WatchService watcher, WatchEvent.Kind<?>... events) 
            - public WatchKey register(WatchService watcher, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers)
        - WatchEvent 인터페이스에 선언된 context() 메소드 호출하면 객체 선언 시 선언했던 제네릭 타입 객체를 리턴하는데, 일반적으로 dir.register(...)로 Path dir을 등록하므로 Path 객체가 리턴됨
        - 데몬 스레드로 실행했으므로 메인스레드에서 while 메소드가 종료되지 않아도 프로그램이 자동으로 멈추며, 데몬 스레드는 다른 모든 일반스레드가 종료되어 JVM이 종료될 때 끝남
        
## 10. Java 8

### 10.1 Java 8에서 추가된 것들
- Optional
    - NullPointerException을 방지하고 null 처리를 간편하게 하기 위해 만들어진 클래스
    - public final class Optional\<T> extends Object로, final 클래스이므로 확장이 불가능
    - 생성자로 객체를 생성하지 않고 대신 Optional 객체를 리턴하는 아래의 메소드 사용
        - empty() : 데이터가 없는 Optional 객체 생성
        - ofNullable() : value가 null일 수도, 아닐 수도 있는 경우 사용
        - of() : null이 아닌 값을 담은 Optional 객체를 생성
    - Optional 객체가 비어있는지는 isPresent() 메소드로 확인
    - 값을 꺼내는 메소드
        - get()
        - orElse() : 값이 없을 경우 매개변수의 데이터로 기본값 지정
        - orElseGeta() : 매개변수에 Supplier\<T>라는 Functional 인터페이스를 활용. Supplier\<T>의 get 메소드에서 기본값을 리턴하도록 구현
        - orElseThrow() : 데이터가 없을 경우 예외를 발생. Supplier\<T>의 get 메소드가 예외를 리턴하도록 구현
- Default method
    - 인터페이스에 아래와 같이 default를 붙인 구현된 메소드를 추가할 수 있게 됨
        ```
        public interface DefaultStaticInterface {
            default String getEmail(){
                return "@godofjava.com";
            }
        }
        ``` 
    - 전세계 사람들이 사용하는 오픈 소스 코드가 있을 때, 해당 인터페이스에 새로운 메소드를 추가해야 할 경우 사용중인 사람들은 모두 오류가 발생하여 코드를 고쳐야 하는 일이 발생할 수 있음. default 메소드는 새로 구현할 필요가 없기때문에 그런 위험을 방지함
- 날짜 관련 클래스들
    - 이전에 사용하던 Date나 SimpleDateFormatter 클래스는 스레드에 안전하지 않으며, 불변객체가 아니어서 지속적으로 값 변경이 가능. 또한 API 구성이 복잡하게 되어있어 달은 1, 일은 0부터 시작함
    - 이러한 이슈때문에 Java 8에서는 java.time이라는 패키지를 만듦
    <table border="1" cellspacing="0" cellpadding="6">
    <tr>
        <th>내용</th>
        <th>버전</th>
        <th>패키지</th>
        <th>설명</th>
    </tr>
    <tr>
        <td rowspan="2">값 유지</td>
        <td>예전 버전</td>
        <td>java.util.Date<br>java.util.Calendar</td>
        <td>
        Date 클래스는 날짜 계산을 할 수 없다.<br>
        Calendar 클래스는 불변 객체가 아니므로 연산시 객체 자체가 변경되었다.
        </td>
    </tr>
    <tr>
        <td>Java 8</td>
        <td>java.time.ZonedDateTime<br>java.time.LocalDate</td>
        <td>
        ZonedDateTime과 LocalDate 등은 불변 객체이다.<br>
        모든 클래스가 연산용의 메소드를 갖고 있으며,<br>
        연산시 새로운 불변 객체를 돌려 준다.<br>
        그리고 스레드에 안전하다.
        </td>
    </tr>
    <tr>
        <td rowspan="2">변경</td>
        <td>예전 버전</td>
        <td>java.text.SimpleDateFormat</td>
        <td>
        SimpleDateFormat는 스레드 안전하지도 않고 느리다.
        </td>
    </tr>
    <tr>
        <td>Java 8</td>
        <td>java.time.format.DateTimeFormatter</td>
        <td>
        DateTimeFormatter는 스레드 안전하며 빠르다.
        </td>
    </tr>
    <tr>
        <td rowspan="2">시간대</td>
        <td>예전 버전</td>
        <td>java.util.TimeZone</td>
        <td>
        "Asia/Seoul"이나 "+09:00" 같은 정보를 가진다.
        </td>
    </tr>
    <tr>
        <td>Java 8</td>
        <td>
            java.time.ZoneId
            java.time.ZoneOffset
        </td>
        <td>
        ZoneId는 "Asia/Seoul"라는 정보를 갖고 있고,<br>
        ZoneOffset는 "+09:00" 라는 정보를 가지고있다.
        </td>
    </tr>
    <tr>
        <td rowspan="3">속성 관련</td>
        <td>예전 버전</td>
        <td>java.util.Calendar</td>
        <td>
        Calendar.YEAR<br>
        Calendar.MONTH<br>
        Calendar.DATE (Calendar.DAY_OF_MONTH)<br>
        등 이들은 정수(int)이다.
        </td>
    </tr>
    <tr>
        <td rowspan="2">Java 8</td>
        <td>java.time.temporal.ChronoField</td>
        <td>
        ChronoField.YEAR<br>
        ChronoField.MONTH_OF_YEAR<br>
        ChronoField.DAY_OF_MONTH<br>
        등이 enum 타입이다.
        </td>
    </tr>
    <tr>
        <td>java.time.temporal.ChronoUnit</td>
        <td>
        ChronoUnit.YEARS (연수)<br>
        ChronoUnit.MONTHS (개월)<br>
        ChronoUnit.DAYS (일)<br>
        등이 enum 타입이다.
        </td>
    </tr>
    </table>

    - 시간을 나타내는 3가지 계열의 클래스들이 추가됨
        - Local : 타임존 없이 날짜와 시간만 표현
        - Offset : UTC 기준 고정 오프셋을 숫자로 설정 (+09:00 → ZoneOffset.ofHours(9) 등)
        - Zoned : 타임존 이름(ZoneId) 사용하여 시간 설정 ("Asia/Seoul", "America/New_York")
    - 요일을 더 편하게 표현할 수 있는 DayOfWeek enum 클래스 추가됨. DayOfWeek는 MONDAY 부터 SUNDAY까지의 상수를 가짐

        ```
        private void printDayOfWeek(){

            // DayOfWeek enum의 모든 값을 배열로 가져옴
            DayOfWeek[] dayOfWeeks = DayOfWeek.values();

            // 시스템의 기본 로케일을 가져옴 (한국 시스템이면 Locale.KOREA)
            // locale에 따라 언어가 달라짐
            Locale locale = locale.getDefault();

            for(DayOfWeek day : daayOfWeeks){
                System.out.println(day.getDisplayName(TextStyle.FULL, locale)+ " ");
                System.out.println(day.getDisplayName(TextStyle.SHORT, locale)+ " ");
                System.out.println(day.getDisplayName(TextStyle.NARROW, locale)+ " ");
            }
        }
        ```

    - getDisplayName(TextStyle.FULL, locale)은 요일 이름을 지정된 스타일과 로케일에 맞게 출력
        - TextStyle 옵션:
            - FULL → "Monday", "Tuesday" (전체 이름)
            - SHORT → "Mon", "Tue" (줄임말)
            - NARROW → "M", "T" (한 글자 표기)
        - 한국은 SHORT와 NARROW의 차이가 없음
- 배열을 병렬로 정렬하는 메소드
    - 배열을 정렬하려면 java.util.Array의 sort() 메소드를 사용하면 간편함
    - 하지만 더 빠른 처리를 원한다면 Java 8에서 추가된  parallelSort() 메소드를 사용할 수 있음. Fork-Join 프레임워크를 이용하여 배열 정렬을 여러 스레드로 처리함
    - 크기가 큰 배열에서는 parallelSort() 메소드가 sort()보다 더 빠름
- StringJoiner
    - 여러 문자열을 구분자를 넣어 이어 붙일 때 사용
    - 선택 사항으로 시작과 끝 지정 가능

        ```
        StringJoiner sj = new StringJoiner(", ", "[", "]"); // 구분자, 시작, 끝
        sj.add("Red");
        sj.add("Green");
        sj.add("Blue");

        System.out.println(sj.toString());
        ```

        ```
        [Red, Green, Blue]  //출력 결과
        ```

### 10.2 Java 8에서 변경된 것들
- Lamda 표현식
    - 메소드가 하나인 인터페이스를 간단하게 표현하는 방식. 메소드가 하나인 인터페이스를 Functional 인터페이스라고 함
    - 람다 클래스는 익명 클래스로 전환이 가능하며, 메소드가 하나일 경우 그 역도 성립함
    - Java에 정의된 하나의 메소드를 가진 많은 인터페이스들을 Lamda 표현식으로 전환 가능. 대표적으로 Runnable과 Comparator이 있음
    - (매개 변수 목록) -> 처리식으로 람다를 표현하며, 처리식이 한 줄 이상일 때는 처리식을 중괄호로 묶을 수 있음
    - 다른 사람이 Functional 인터페이스에 메소드를 더 추가하게 되면 이미 람다 표현식을 사용중일 경우 에러가 발생하므로, 인터페이스 위에 @FunctionalInterface를 사용하여 하나의 메소드만 정의되도록 강제할 수 있음
    - 아래는 Java 8에서 제공하는 주요 Functional 인터페이스
        - Predicate
            - boolean을 리턴하는 test() 메소드가 있으며 추가로 and(), negate(), or()이라는 default 메소드가 있음. default 메소드와 함께 사용하려면 아래와 같이 사용

                ```
                String godOfJava = "GodOfJava";

                Predicate<String> predicateLength5 = (a) -> a.length() > 5;
                Predicate<String> predicateContains = (a) -> a.contains("God");

                predicateLength5.and(predicateContains).test(godOfJava);
                ```

        - Supplier
            - generic으로 선언된 타입을 리턴하는 get() 메소드가 있음
        - Consumer
            - 리턴값이 없는 accept() 라는 매개변수를 하나 갖는 메소드가 있으며 출력처럼 리턴이 필요 없는 작업에 사용. 추가로 andThen()이라는 default 메소드가 있으며 순차적인 작업을 할 때 사용
        - Function
            - 하나의 매개 변수를 갖는 apply() 메소드가 있음. Function\<T, R\>로 apply()에 대한 매개변수 타입, 리턴 타입이 되는 2개 Generic 타입을 가짐. 변환을 할 때 사용 
        - UnaryOperator
            - 하나의 generic 타입으로 매개변수(1개)와 리턴값의 타입이 같은 apply() 메소드를 가짐
        - BinaryOperator
            - UnaryOperator와 유사하나 매개변수가 2개이며, generic은 마찬가지로 하나이므로 2개 매개변수와 리턴값의 타입이 같음
- stream
    - 스트림은 연속된 정보를 처리할 때 사용. 가장 기본적인 건 배열과 컬렉션인데, Collection에는 Stream 인터페이스 객체를 생성하는 stream() 메소드가 정의되어 있지만 배열에는 따로 없으므로 변환이 필요함
    - 배열을 List 컬렉션으로 변환하는 방법도 있지만 아래와 같이 배열을 다루기 위한 유틸리티 클래스 Arrays의 stream()의 매개변수로 넣어도 됨

        ```
        List<Integer> list = Arrays.stream(배열변수).종단연산  // Stream 객체 리턴
        ```

    - 스트림은 아래와 같은 구조를 가짐

        ```
        Collection객체.stream().중개연산.종단연산
        ```

    - 중개 연산은 데이터를 가공할 때 사용되며 연산 결과로 Stream 타입을 리턴. 따라서 0개 또는 여러 개의 중개연산이 존재할 수 있음
    - 종단 연산은 중개 연산에서 작업된 내용을 바탕으로 결과를 리턴. 1개만 존재하며, forEach()처럼 리턴 타입이 void인 연산도 있음
    - stream()은 컬렉션의 연속된 요소를 순차적으로 데이터를 처리함. 보다 빠른 처리가 필요하면 병렬로 처리하는 parallelStream()을 대신 사용할 수 있으나 CPU 사용량도 많고 몇개 스레드를 사용할지 보장되지 않아 권장되진 않음
    - 스트림에서 제공하는 중개연산과 종단연산의 종류는 다양하지만 잘 알려진 건 아래와 같음
        - 중개연산
            - filter(Predicate\<T> predicate)
            - map(Function\<T, R> mapper)
        - 종단연산
            - forEach(Consumer\<T> action)
            - collect(Collector\<? super T, A, R> collector)
            - Optional<T> reduce(BinaryOperator\<T> accumulator)
            - T reduce(T identity, BinaryOperator\<T> accumulator)
            - \<U> U reduce(U identity, BiFunction\<U,? super T,U> accumulator, BinaryOperator\<U> combiner)
    - Functional 인터페이스는 람다식으로 전환 가능하므로, map()과 forEach()는 아래와 같이 사용가능
        
        ```
        public class StudentDTO {
            private String name;
            private int age;
            private int scoreMath;
            private int scoreEnglish;

            public StudentDTO(String name, int age, int scoreMath, int scoreEnglish) {
                this.name = name;
                this.age = age;
                this.scoreMath = scoreMath;
                this.scoreEnglish = scoreEnglish;
            }
            ...
        }
        ```

        ```
        public class StudentForEachSample {
            public static void main(String[] args) {
                StudentForEachSample sample = new StudentForEachSample();
                List<StudentDTO> studentList = new ArrayList<>();

                studentList.add(new StudentDTO("A", 43, 99, 10));
                studentList.add(new StudentDTO("B", 30, 71, 85));
                studentList.add(new StudentDTO("C", 32, 81, 75));

                sample.printStudentNames(studentList);
            }

            public void printStudentNames(List<StudentDTO> studentList) {
                studentList.stream()
                        .map(student -> student.getName())  // Function 람다식
                        .forEach(name -> System.out.println); // Consumer 람다식
            }
            ...
        }
        ```

    - map()은 데이터를 특정 데이터로 변환함. 여기서 변환한다는 것은 인터페이스에 있는 단일 함수에서 매개변수로 받은 데이터와 다른 데이터를 리턴한다는 것
    - 위 예제의 map()에서는 StudentDTO 객체를 받아 String 타입의 name으로 리턴하고 있음. 따라서 이후부터는 List\<StudentDTO>의 스트림이 아닌 List\<String>의 스트림을 처리하게 됨
    - filter()와 collect()는 아래와 같이 사용가능

        ```
        List<StudentDTO> passedStudents = studentList.stream()
            .filter(s -> s.getScoreMath() >= 70)  // 중개연산
            .collect(Collectors.toList());        // 종단연산
        ```
        
        - filter()는 스트림 내에서 필요한 데이터를 걸러서 처리할 때 사용
        - collect()에 전달되는 Collector 인터페이스는 Functional 인터페이스가 아님. 주로 Collector 인터페이스를 리턴하는 Collectors 클래스의 메소드를 전달함. Collectors는 스트림 연산의 최종 결과를 모으는 방법을 제공하는 유틸리티 클래스
        - Collectors.toList()는 새 List를 만들고 요소를 담아 합치는 방법을 정의한 설계도 객체(Collector)를 리턴하는 메서드
    - reduce()는 스트림 안의 요소들을 하나의 값으로 합쳐서 축약할 때 사용

        ```
        // Optional<T> reduce(BinaryOperator<T> accumulator)의 경우

        Optional<Integer> sum = list.stream()
            .reduce((a, b) -> a + b);       // 누적 합. 초기값은 list의 첫번째 요소
        ```

        ```
        // T reduce(T identity, BinaryOperator<T> accumulator)의 경우

        int sum = list.stream()
            .reduce(0, (a, b) -> a + b);    // 누적 합. 초기값은 첫번째 인자인 0
        ```

        ```
        // <U> U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)의 경우 (잘 사용되지 않음)

        int totalLength = list.stream()
            .reduce(0,
                (len, str) -> len + str.length(),   // 누적 로직
                (a, b) -> a + b);                   // 이건 병렬 스트림일 때만 사용되므로 일반적으로 호출되지 않음
        ```


    - 메소드 참조(::)를 사용하여 람다식을 더 짧게 줄일 수 있음. 스트림에 사용하기도 더 간단해짐
    - 메소드 참조의 종류는 4가지
        - static 메소드 참조 
            - 클래스명::static메소드명
        - 특정 객체의 인스턴스 메소드 참조
            - 객체명::객체의_인스턴스_메소드명

                ```
                Arrays.asList(stringArray).stream().forEach(System.out::println);                
                ```

        - 특정 유형의 임의의 객체에 대한 인스턴스 메소드 참조
            - 클래스명::인스턴스_메소드명(static 아님)
                
                ```
                Arrays.sort(stringArray, String::compareToIgnoreCase);
                ```

                - Arrays 클래스는 아래와 같은 메소드를 갖고 있음

                    ```
                    static <T> void sort(T[] a, Comparator<? super T> c)
                    ```

                - sort()의 두번째 매개변수인 Comparator는 int compare(T o1, T o2)라는 하나의 메소드를 가진 Functional 인터페이스이므로 아래와 같이 표현될 수 있음
                    
                    ```
                    Comparator<String> compare = (s1, s2) -> s1.compareToIgnoreCase(s2);
                    ```
                    
                - compareToIgnoreCase는 String 클래스의 인스턴스 메소드이므로 String::compareToIgnoreCase으로 표현할 수 있음
        - 생성자 참조
            - 클래스명::new
            - () -> new 클래스명()의 간결한 표현

## 11. Java 9에서 변경된 것들
- 3~5년 주기로 업그레이드되던 Java는 9버전 부터 6개월마다 업그레이드되므로, 6개월 주기로 어떤 기능들이 추가되는지 확인하는게 좋음
    - openjdk 버전 별 기능 정리한 페이지 확인 (https://openjdk.org/projects/jdk/12/)
- 아래 이미지 처럼 Features에서 괄호 안에 Experimental, Preview, Incubator 등 3가지 단어가 올 수 있음
    ![jdk12_features](/assets/images/jdk12_features.png)
    - Experimental : 실험적인 기능으로, 옵션을 켜지 않으면 사용불가
    - Preview : 추후에 JDK에 포함될 기능
    - Incubator : 완전하지 않아 언제든 변경되거나 사라질 수 있는 기능
- String 클래스의 변화
    - String 내부에 있는 값들을 char 배열에서 byte 배열로 변경
    - 숫자, 영문, 키보드에 있는 특수문자들은 모두 1byte로 표현가능한 반면 한글이나 한자같은 다양한 문자들은 2byte를 사용해야 함. 문자열이 가장 많이 다뤄지므로 영문이 사용된 프로그램의 성능과 메모리 효율이 많이 향상됨
- Interface에 private 메소드 추가 가능
    - 해당 인터페이스를 구현하는 개발자에게 노출되지 않는 인터페이스 내부에서만 사용 가능한 메소드 생성
    - 인터페이스 내에서 구현된 메소드(default, private static일 경우 static 메소드도 가능)에서만 사용 가능
    - private로만 선언해야 하며 abstract이 붙을 수 없음. static은 가능
    - 당연히 static 메소드가 아니면 같은 클래스 안이라도 static 메소드에서 사용 불가
- HttpClient
    - 예전에 HTTP 호출을 하려면 URL, HTTPURLConnection 클래스를 활용하여 요청하고 BufferedReader를 사용하여 결과를 받는 식으로 처리했는데, 코드가 복잡해짐
    - 일반적인 오픈소스 라이브러리처럼 제공되는 HttpClient를 사용하여 대신 처리할 수 있음. 보낼 때 HttpRequest 클래스에 데이터를 넣고 받을 때는 HTtpResponse 클래스를 사용하여 응답 처리
    - 서버에 붙을 수 없거나 응답이 없을 때 요청을 끊을 수 있도록 HttpClient, HttpRequest 객체 생성 시 아래와 같이 타임아웃을 지정할 수 있음

        ```
        HttpClient client = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(5))  // 서버에 붙을 수 없거나 응답이 없을 경우 타임아웃
                .build();

        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://www.google.com"))
                .timeout(Duration.ofSeconds(10))        // 서버는 연결되었으나 응답이 없을 때 타임아웃
                .GET()
                .build();

        HttpResponse<String> response = client.send(request, ...);
        ```

    - 위와 같은 타임아웃은 반드시 지정해서 사용하는 것이 좋음
- Publish-Subscribe 프레임워크
    - 이메일을 보내는 경우 받는 사람의 입장에서 polling과 pulling 두가지 방식이 있음
    - polling은 주기적으로 요청을 해서 변경된 것이 있는지 확인하고 없으면 아무것도 안함. outlook 프로그램은 새로운 메일이 있는지 주기적으로 서버에 요청을 해서 확인
    - pulling은 필요시 데이터를 처리하도록 요청하는 것으로 Publish-Subscribe라는 개념이 있음. Java 9에서 이 프레임워크가 추가됨

        ![processor](/assets/images/publish-subscribescheme.png)

    - 펍섭 프레임워크는 아래와 같은 인터페이스들을 제공함
        - Publisher

            ```
            public static interface Publisher<T> {
                public void subscribe(Subscriber<? super T> subscriber);
            }
            ```

            - subscribe()에서 Subscriber에게 item 전달

        - Subscriber

            ```
            public static interface Subscriber<T> {
                public void onSubscribe(Subscription subscription);
                public void onNext(T item);
                public void onError(Throwable throwable);
                public void onComplete();
            }
            ```

            - onSubscribe()에서 Subscription의 request()를 호출해 받을 item 개수를 서버에 보내고, 서버에서 온 item은 onNext()에서 받음. onError()와 onComplete()는 각각 에러가 발생했을 때, 완료되었을 때 호출됨

        - Subscription (Publisher가 Subscriber에게 주는 item)

            ```
            public static interface Subscription {
                public void request(long n);
                public void cancel();
            }
            ```

            - Subscription은 Subscriber가 사용하며, request()는 Subscriber가 Publisher에게 얼마나 많은 아이템을 받을지 알려주기 위해 사용
            - requst() 취소하려면 cancel() 사용

        - Processor (중개자가 필요한 경우)
            - Processor가 낄 경우 아래와 같이 동작함

                ![processor](/assets/images/processor.png)

            ```
            public static interface Processor<T, R> extends Subscriber<T>, Publisher<R> {}
            ```

            - Subscriber이자 Publisher이므로 둘다 확장
            - 인터페이스 간의 상속이므로 extends 사용. 클래스가 인터페이스를 구현하면 implements
    - Publisher-Subscriber 예제. Publisher는 JDK에 포함된 SubmissionPublisher 구현 클래스 사용

        ```
        public class ReactiveStreamSubscriber implements Subscriber<Integer> {

            private Subscription subscription;
            private String name;
            private boolean completed;

            public ReactiveStreamSubscriber(String name) {
                this.name = name;
                this.completed = false;
            }

            @Override
            public void onSubscribe(Subscription subscription) {
                this.subscription = subscription;
                subscription.request(1); // 첫 아이템 요청
            }

            @Override
            public void onNext(Integer item) {
                Random random = new Random();
                int randomTime = random.nextInt(1000);
                sleep(randomTime);

                System.out.println("[" + name + "] Received item: " + item);

                subscription.request(1); // 다음 아이템 요청
            }

            @Override
            public void onError(Throwable error) {
                System.out.println("[" + name + "] Error occurred: " + error.getMessage());
            }

            @Override
            public void onComplete() {
                completed = true;
                System.out.println("[" + name + "] ReactiveStreamSubscriber is complete");
            }

            public boolean isCompleted() {
                return completed;
            }

            private void sleep(int time) {
                try {
                    Thread.sleep(time);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
        ```

        ```
        public class ReactiveStreamMain {

            public static void main(String[] args) throws InterruptedException {

                SubmissionPublisher<Integer> publisher = new SubmissionPublisher<>();

                ReactiveStreamSubscriber subscriber1 = new ReactiveStreamSubscriber("subscriber1");
                ReactiveStreamSubscriber subscriber2 = new ReactiveStreamSubscriber("subscriber2");

                publisher.subscribe(subscriber1);
                publisher.subscribe(subscriber2);

                System.out.println("Submitting items...");
                for (int i = 0; i < 5; i++) {
                    publisher.submit(i);
                    System.out.println("Published: " + i);
                }

                publisher.close();

                // 모든 Subscriber가 완료될 때까지 대기
                while (true) {
                    if (subscriber1.isCompleted() && subscriber2.isCompleted()) {
                        break;
                    }
                    Thread.sleep(100);
                }

                System.out.println("All subscribers completed.");
            }
        }
        ```

- 모듈화-직소 프로젝트
    - 자바 패키지 최상단에 module-info.java 파일 추가

        ![processor](/assets/images/모듈구조축소.png)
    
    - module-info.java에 exports로 외부에 노출할 패키지 지정 가능

        ```
        module GODOfJavaModule1 {
            exports f.java9.module1;
        }
        ```
    
    - 동일한 모듈에 있어도 module-info.java에 exports된 패키지에 정의된 클래스가 아니라면 다른 모듈의 클래스에서 import하거나 참조할 수 없음
        - 위의 폴더구조 이미지에 있는 HiddenClass 클래스는 f.java9.module0 패키지에 정의됨
        
            ```
            package f.java9.module0;

            public class HiddenClass {
                public boid showMeTheHidden(){
                    ...
                }
            }
            ```
        
        - HiddenClass 클래스는 같은 모듈에 있는 PrintData 클래스에서는 사용할 수 있으나 chapterF.06.Module2에 있는 UtilizeData 클래스에서는 import하거나 참조할 수 없음

## 12. Java 10에서 달라진 것들
- var 타입 사용 가능
    - javaScript에서 사용하는 var를 유사하게 자바에서 사용 가능
    - 누가 봐도 명시적인 타입을 지정할 대는 var를 사용하여 변수를 선언할 수 있음. 아래와 같이 배열에 서로 다른 타입의 값을 넣어도 컴파일 오류는 나지 않으나, 이런 제네릭은 없으므로 이런 방식의 사용은 자제해야 함

        ```
        var hello = "aaaaaa";
        var list = new ArrayList<>();
        list.add(hello);
        list.add(1);
        System.out.println(list)
        ```
    
    - var list = ArrayList\<String>();처럼 제네릭에 타입을 명시하면 숫자를 넣을 때 컴파일 에러가 발생함
    - 누가봐도 우측항의 타입이 명시적이면 var를 사용해도 되지만, 그렇지 않으면 컴파일 오류가 발생
- Immutable Collection
    - 수정 불가능한 List Collection을 만드는 List.of()가 추가됨
    - List.of()는 내부적으로 ImmutableCollections.ListN 객체를 반환함. 상속구조는 아래와 같음

        ```
        Object
            └─ AbstractCollection<E>
                └─ AbstractImmutableList<E> implements List<E>, RandomAccess, Serializable
                    └─ ListN<E>
        ```

    - 아래의 fruits에 새로운 요소를 추가하려하면 오류 발생
    
        ```
        var fruits = List.of("Apple", "Pineapple", "Grapes");
        ```

    - 이미 선언된 List를 수정 불가능한 목록으로 만드려면 Collectors 클래스의 toUnmodifiableList() 사용

        ```
        List<String> changedFruits = fruits.stream().collect(Collectors.toUnmodifiableList());
        ```

    - 참고로 Java 16부터는 stream.of()로도 만들 수 있음

        ```
        var fruits = Stream.of("Apple", "Pineapple", "Grapes").toList();
        ```

## 13. Java 11에서 달라진 것들
- 컴파일 없이 java 파일 실행
    - 원래는 javac 명령어로 .java 파일 컴파일 후 java 명령어로 실행 가능한데, 컴파일 없이 실행할 수 있게됨
        
        ```
        $ java NoCompileWithArgs.java God of java
        ```

    - 위처럼 매개변수도 문제없이 전달 가능
    - 코드 최상단에 #!java --source 자바버전(숫자)를 추가하면 ./자바파일 만으로 실행할 수 있음

        ```
        #!java --source 11
        public class NoCompile{
            public static void main(String args[]){
                System.out.println("script of java !!!");
            }
        }
        ```

        ```
        $ chmod 755 likescript  // 파일명은 클래스명과 일치하지 않아도 됨
        $ ./likescript
        script of java !!!
        ```

    - 이런 파일을 셔빙 파일이라 하며, #!으로 시작하여 실행파일(java)가 정의되어 있어야 함. --source로 버전도 반드시 명시해 줘야 함
    - 이렇게 하면 자바 11 이상이 설치된 환경에서는 쉘 스크립트 공부할 필요 없이 자바로 쉘 스크립트 같이 필요한 기능을 만들어 사용할 수 있음. 단, 성능은 쉘 스크립트보다 떨어질 수 있다는 점은 고려해야 함
- Lamda에서 var 사용
    - var 예약어는 제약이 많았는데 Lamda에서는 var을 사용하는게 불가능 했음
    - Java 11에선 아래와 같이 Lamda 매개변수에 var 사용가능 

        ```
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // numbers.stream()은 Stream<Integer>으로, 이미 컴파일러가 타입을 알고 있음
        int sum = numbers.stream().reduce(0, (var x, var y) -> x + y);
        ```

## 14. Java 12~17 버전
- 더 간결하게 표현 가능한 switch-case 문
    - Java 12 부터는 switch 앞에 값을 할당할 변수를 적어주고, case 뒤에 : 대신 -> 사용하여 값을 할당할 수 있음

        ```
        int days;
        days = switch(month) {
            case 1 -> 31;
            case 3 -> 31;
            ...
            case 4 -> 30;
            ...
            default -> 0;
        }
        ```

    - -> 문법에서는 오직 해당 case 한 번만 실행되기 때문에 break 불필요
    - case 뒤에 콤마를 붙여 여러 케이스에 하나의 값을 할당해야하는 경우 아래와 같이 표현
        
        ```
        int days;
        days = switch(month) {
            case 1, 3, 5, 7, 8, 12 -> 31;
            case 4, 6, 9, 11 -> 30;
            default -> 0;
        }        
        ```
    
    - Java 14부터 정식으로 switch-case 문에서 사용 가능한 yield 예약어가 추가됨. yield는 : 또는 -> 와 함께 사용 가능한데, 한 switch-case 문에서 두 방식을 같이 쓸 순 없음

        ```
        int days;
        days = switch(month) {
            case 1, 3, 5, 7, 8, 12 : 
                yield 31;
            case 4, 6, 9, 11 : 
                yield 30;
            default :
                yield 0;
        }           
        ```
    
    - yield와 ->를 함께 사용할 땐 중괄호로 묶어줘야 함. yield는 return 처럼 동작

        ```
        int days;
        days = switch(month) {
            case 1, 3, 5, 7, 8, 12 -> 31;
            case 4, 6, 9, 11 -> 30;
            default -> {
                System.println.out("Not assigned")
                yield 0;
            }
        }           
        ```  
- text 블록
    - Java 15부터는 정식으로 텍스트 블록을 사용할 수 있음. String을 두 줄 이상 작성할 때 +, \n을 사용할 필요가 없어짐
    - 단, 블록의 시작과 끝 """에는 공백이나 줄바꿈만 가능하며 다른 문자(문자열 내용 포함)를 바로 붙이면 안됨

        ```
        String text = """   // 다른 문자 없음
            Hello,
            
              This is a text block example.
            Multiple lines are preserved.
            """;            // 다른 문자 없음
        ```
    
    - text 블록은 여러 줄의 공통된 맨 앞 공백을 기준으로 제거하고, 그 이후 남은 공백과 내용은 그대로 문자열에 포함시킴. 따라서 위 예제는 아래와 같이 출력됨

        ```
        Hello,
          This is a text block example.
        Multiple lines are preserved.
        ```
- record 클래스
    - Java 16에서 정식으로 추가된 record 클래스는 아래와 같은 특징이 있음
        - 한번 지정한 값은 수정 불가능 (모든 필드가 final)
        - 추가 인스턴스 필드를 선언할 수 없으며 (static은 가능) 상속도 안됨
        - 전체 변수가 포함된 생성자를 자동으로 만들어줌
        - equals()나 hashCode, toString() 메소드를 자동으로 만들어줌
        - 각 변수명으로 생성된 메소드가 제공되며, 변수의 값을 확인하는데 사용됨 (getter)
    
    ```
    //괄호 안의 name, writer, category 인스턴스 필드만 존재. 추가 필드 선언 불가
    public record BookOfKoreanRecord(String name, String writer, String category) {

        // Static 필드 — OK
        public static final String BOOK_LANGUAGE = "Korean Book";

        // 생성자에 괄호가 없으면 전체변수 생성자
        // 전체변수 생성자는 자동으로 값이 매핑됨. 매핑된 후 Objects.requireNonNull()을 호출하여 null일 경우 예외 발생
        public BookOfKoreanRecord {
            Objects.requireNonNull(name);
            Objects.requireNonNull(writer);
        }

        // 전체변수 생성자가 아니면 괄호로 매개변수 지정
        public BookOfKoreanRecord(String name, String writer) {
            this(name, writer, "IT");
        }
    }
    ```

    ```
    private void testBookRecord() {
        BookOfKoreanRecord godOfJava1 = new BookOfKoreanRecord("GodOfJava", "Sangmin,Lee", "IT");

        // record의 자동 생성 toString()과 getter 메서드 호출
        System.out.println(godOfJava1);
        System.out.println(godOfJava1.name());
        System.out.println(godOfJava1.writer());
        System.out.println(godOfJava1.category());

        BookOfKoreanRecord godOfJava2 = new BookOfKoreanRecord("GodOfJava", "Sangmin,Lee", "IT");

        // record는 equals()와 hashCode()를 필드 값 기준으로 자동 생성
        System.out.println("Two same value objects equals = " + godOfJava1.equals(godOfJava2));
        System.out.println("godOfJava1 hashCode = " + godOfJava1.hashCode());
        System.out.println("godOfJava2 hashCode = " + godOfJava2.hashCode());
    }
    ```

    - 출력 결과는 아래와 같음

    ```
    BookOfKoreanRecord[name=godOfJava2, writer=Sangmin,Lee, category=IT]
    GodOfJava
    Sangmin,Lee
    IT
    Two same value object equals=true 
    godOfJava1 hashCode=-67549099 
    godOfJava2 hashCode=-67549099
    ```

    - record 클래스는 DB에서 조회한 데이터를 확인하는 등 변하지 않는 데이터를 처리할 때 유용함. 값 변경이 필요하다면 record가 아닌 DTO를 만들어 사용하는 게 좋음
- sealed 클래스
    - Java 17부터 사용 가능. 상속을 허용하기 위한 용도로 사용됨
    - class 앞에 sealed가 붙어야 하고, permits 뒤에 상속을 허용할 클래스명을 나열함. permits로 허용한 클래스 외에는 상속이 허용되지 않음
    - 상속이 허용된 클래스들에 대하여 아래와 같은 제약사항이 있음
        - 허용된 서브 클래스들은 반드시 같은 모듈에 존재해야 함
        - 허용된 서브 클래스들은 반드시 명시적으로 부모 클래스를 확장해야 함
        - 허용된 서브 클래스들은 다음 중 하나로 선언되어야 함 : final, sealed, non-sealed
    - sealed
    
        ```
        public sealed class Sealed FordCar permits Sealed Mustang, Sealed Explorer {
            public static String BRAND_NAME="FORD";
            public SealedFordCar() {
                System.out.println("SealedFordCar initiated. BRAND_NAME="+BRAND_NAME);
            }
        }
        ```

        ```
        public sealed class SealedMustang extends Sealed FordCar permits SealedMustangShelby{
            public SealedMustang() {
                System.out.println("SealedMustang initiated.BRAND_NAME="+BRAND_NAME);
            }
            public boolean isSportsCar(){
                return true;
            }
        }
        ```


    - final
        - 더이상 상속을 허용할 클래스가 없다면 final로 상속을 막음

            ```
            public final class Sealed MustangShelby extends SealedMustang {
                public SealedMustangShelby() {
                    System.out.println("SealedMustangShelby initiated.BRAND_NAME="+BRAND_NAME);
                }
            }
            ```

    - non-sealed
        - 해당 클래스의 자식 클래스에 대한 제약 삭제. 해당 클래스를 아무 클래스가 확장할 수 있게 됨

            ```
            public non-sealed class SealedExplorer extends FordCar {
                public SealedExplorer() {
                    System.out.println("SealedExplorer initiated. BRAND_NAME=" + BRAND_NAME);
                }
                public boolean isSUV() {
                    return true;
                }
            }
            ```
    
    - sealed 클래스는 컴파일러가 해당 타입의 가능한 모든 서브클래스를 알고 있으므로 타입 누락 실수를 방지할 수 있음
        - switch 패턴 매칭에서 누락한 클래스가 있을 경우 경고를 줄 수 있음