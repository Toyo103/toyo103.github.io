---
layout: post
title: 자바 기초 정리 (자바의 신 vol.1)
subtitle: 자바 기초 문법 정리
categories: CS
tags: [java]
---

## 1. 자바 변수와 자료형

### 1.1 변수의 종류

자바의 변수는 생명주기에 따라 4가지 종류로 나뉜다.

1. 지역 변수
    - 중괄호 내에서 선언된 변수
    - 생명주기도 해당 중괄호 내에서만 유효함
    - 자바에선 재선언이 허용되지 않으므로 해당 중괄호 내에서 동일한 이름을 갖는 지역 변수를 선언하면 컴파일 에러가 발생함

2. 매개 변수 
    - 메소드에 넘겨주는 변수
    - 메소드가 호출될 대 생명이 시작되어 메소드가 끝나면 소멸

3. 인스턴스 변수
    - 메소드 밖, 클래스 안에 선언된 변수
    - 객체가 생성될 때 생명이 시작되며, 그 객체를 참조하고 있는 다른 객체가 없으면 소멸됨

4. 클래스 변수
    - static 예약어가 붙은 인스턴스 변수
    - 클래스가 처음 로드될 때 생명이 시작되고, 자바 프로그램이 끝날 때 소멸됨
    - 클래스는 객체를 처음 생성하거나, 해당 클래스 변수에 접근하거나, 동적으로 로드하거나, 해당 클래스의 자식 클래스가 로드될 때 같이 로드됨

### 1.2 자료형의 종류

1. 기본 자료형
    - 바로 값을 넣어 초기화가 가능
    - 자료형의 첫 비트는 부호를 표시하는데 사용되며 음수의 범위가 양수의 범위보다 하나 더 큼. 부호비트가 1이고 나머지 비트가 0일 경우를 해당 타입의 최소값으로 사용하기 때문 (-2^n ~ -2^n-1)
    - 따라서 어떤 자료형에 최소값을 넣고 1을 빼면 최대값이, 최대값을 넣고 1을 더하면 최소값이 됨 (최소값이 10000000 이면 최대값은 01111111이기 때문)
    - 소수형 타입은 부동 소수점 연산을 사용하므로 값이 범위를 넘어서면 정확성이 보장되지 않음 -> 대신 java.match.BigDemical이라는 클래스를 사용
    - 자바의 모든 자료형은 값을 지정하지 않으면 기본값 사용. 기본 자료형은 각자의 기본값을 가지고 참조형은 null. 그러나 지역 변수일 경우는 기본값이 자동 적용되지 않음
    - 자바는 계산 시 두 피연산자가 정수형일 때 결과 값도 정수형으로 취급하므로 결과가 소수값이어도 소수형으로 결과가 나오진 않음. 소수점 아래까지의 결과를 원하면 두 피연산자를 소수형으로 할 필요가 있음
    - 종류
        - 정수형
            - byte  (-2^7 ~ 2^7-1)
            - short (-2^15 ~ 2^15-1)
            - int   (-2^31 ~ 2^31-1)
            - long  (-2^63 ~ 2^63-1)
                - long 자료형 초기화 시 L을 붙이지 않고 int 범위를 초과하는 값을 넣으면 에러 발생. 자바에서 기본적으로 숫자를 명시하면 int라고 생각하기 때문에 선언 시 L을 붙여주지 않으면 int로 인식됨
            - char
                - 정수형 중 유일하게 부호가 없음
                - 내부적으로 아스키/유니코드에 대응하는 숫자값을 저장하는 정수형 타입이지만 데이터 처리 방식에는 차이가 있음
                - 'a'와 같은 문자를 저장할 수 있으므로 char 같은 정수형인 다른 자료형들도 가능한 범위일 경우 해당 문자 저장 가능
                - 'a'같은 문자와 \u + 4자리의 16진수 값을 넣는 것이 대표적. 해당 값의 유니코드 번호를 지정해도 초기화 가능

        - 소수형
            - float
            - double
        - boolean

2. 참조 자료형
    - new 키워드를 사용해서 초기화 가능
    - String 만은 예외적으로 new을 사용하지 않고도 초기화 가능

## 2. 연산자와 형변환

### 2.1 연산자

- 연산자는 단항연산자   >   *, /, %   >   +, -   순으로 우선순위가 높다
- 단항연산자 중 ~(틸드)는 2진수로 되어 있는 비트 값을 전부 거꾸로 바꾸는 데 사용
- 등가 비교 연산자 (==, !=)는 같은 종류(정수형과 소수형도 같은 종류)끼리 비교가 가능하며 자바의 모든 기본 자료형과 참조 자료형에서 사용 가능. 참조 자료형은 주소값을 비교함
- 자바의 연산자들은 타입별로 사용 가능한 연산자가 정해져 있음. douable, float는 소수형이므로 비트 연산이 불가능함
- `&`, `|`, `^`(값이 서로 다르면 true, 같으면 false) 연산자는 숫자에 사용하면 비트 연산을, boolean 타입 사이에 사용하면 논리 연산을 수행
- 참조 자료형은 + 이항 연산자만 사용 가능. 사용 시 해당 클래스에 있는 toString() 메소드 결과끼리 더함


### 2.2 형변환

- 기본 자료형 중 boolean 타입은 숫자로 변환할 수 없기 때문에 형변환 불가능
- 더 범위가 넓은 타입으로 변환할 때는 문제가 없으나, 더 범위가 작은 타입으로 변환할 때는 소괄호 안에 타입을 명시해주어야 하며 예상치 못한 값이 나올수도 있음

## 3. 조건문과 반복문

### 3.1 조건문
- switch 문 
    - 한번 case 조건을 만족시켜 줬다면 그다음 break가 올때까지 모든 case 통과하여 실행문 실행
    - case문으로 이루어진 switch 문의 끝에는 default 문이 올 수 있으며 앞에 있는 조건에 맞지 않는 경우 실행됨. case문에서 한번이라도 걸렸으면 실행안됨
    - switch() 괄호 안의 비교 대상 변수는 정수형만 사용 가능 했으나 JDK7부터 String도 사용 가능해짐

### 3.2 반복문
- do-while 문 : 한 번은 꼭 실행시키고 싶을 때 사용. 마지막 while의 소괄호 뒤에 반드시 세미콜론을 입력해야 함
- label : 반복문에 이름을 부여하여(라벨명 : 반복문 형태로 정의) 특정 시점에 해당 반복문을 빠져나오거나(break 라벨명) 위로 돌아가도록 (continue 라벨명)할 수 있음

## 4. 배열

### 4.1 배열의 선언과 기본값
- 배열 선언 시 대괄호는 타입과 변수 사이에 또는 변수명 뒤에 빈 상태로 위치해야함
- 참조 자료형이므로 new 키워드를 사용해 생성하거나, 중괄호를 사용해서 한번에 선언 및 초기화
- 지역변수는 원래 기본값이 없으나, 배열에서는 지역 변수라고 해도 배열 크기만 정해주면 초기화 안해도 각 배열의 기본값이 할당됨
- 기본 자료형 배열의 기본값은 각 자료형의 기본값과 동일
    ```
    byteArray[0]=0
    shortArray[0]=0
    intArray[0]=0
    longArray[0]=0
    floatArray[0]=0.0
    doubleArray[0]=0.0
    charArray[0]=[ ]    //기본값은 ₩u0000으로 화면에 출력될 때에는 한 칸의 공백으로 보임
    booleanArray[0]=false
    ```
- 모든 참조자료형은 초기화 하지 않으면 null값을 기본적으로 가짐
- 참고 : 초기화한 객체를 출력하면, 객체가 기본으로 가지는 toString() 메소드가 해당 객체의 클래스이름@메모리주소기반으로 생성된 16진수 해시코드를 반환하는 걸 확인할 수 있음
    - 배열의 경우 [L클래스이름;@해당 배열의 고유번호. L은 해당 배열이 배열이라는 것을, L은 참조 자료형임을 의미
    - boolean: Z, byte : b, char : C, double : D, float : F, int : I, long : J, short : S

### 4.2 2차원 배열
- 아래와 같이 선언 및 초기화
    ```
    int [] twoDim[]; 
    int twoDim[][];

    twoDim = new int[2][3];
    ```
- 크기를 지정할 경우에는 반드시 한번에 설정하던지 1차원만 설정해야 함
    ```
    twoDim = new int[2][3];
    twoDim = new int[2][];
    ```
- 2차원은 1차원 크기 설정 뒤에도 설정가능. 2차원 방 크기는 서로 다를 수 있음
    ```
    twoDim = new int[2][];
    twoDim[0] = new int[3];
    twoDim[1] = new int[2];
    ```
- 중괄호를 사용해서 한번에 선언 및 초기화 가능.
    {% raw %}
    ```
    int [][]twoDim = {{1, 2, 3}, {4, 5, 6}};
    ```
    {% endraw %}
    
- 2차원 배열에서 .length로 배열 크기를 확인할 때 1차원, 2차원 배열에 각각 .length를 붙여서 알아내야 하며, twoDim[0][0]는 배열 객체가 아닌 값이 들어있는 공간을 나타내기 때문에 실행 시 오류 발생
    - 점(.)은 참조 자료형에서만 찍을 수 있으며 기본 자료형에서는 사용 불가
    ```
    for(int i=0; i<twoDim.length; i++){
        for(int j=0; j <twoDim[i].length; j++){
            ...
        }
    }
    ```
- 다만 위와 같이 .length를 사용하여 for 루프가 수행될 때마다 길이를 얻어오는 건 성능상 좋지 않으므로 아래와 같이 사용
    ```
    int iLength = twoDim.length;
    for(int i = 0; i < iLength; i++){
        int jLength = twoDim[i].length;
        for(int j = 0; j < jLength; j++){
            ...
        }
    }
    ```

### 4.3 배열을 위한 for 루프
- 자바에서 제공되는 Collection이라는 자료구조를 처리할 때 for 루프를 보다 쉽게 사용 가능. JDK5부터 지원됨
    {% raw %}
    ```
    for(타입이름 임시 변수명 : 반복대상객체){

    }

    //사용 예시
    int [][]twoDim= {{1, 2, 3}, {4, 5, 6}};
    for(int[] dimArray : twoDim){
        for(int data : dimArray){
            System.out.println(data);
        }
    }
    ```
    {% endraw %}
-  반복대상객체로는 Collection의 일부 클래스 사용 가능. 단, 이 루프 사용시 배열의 현재 인덱스는 따로 계산해야 함

### 4.4 main 메소드의 배열 인자
- main 메소드의 배열 인자 String ars[]에 아래와 같이 값을 전달할 수 있음 (["a", "b", "c", "d"] 배열 전달)
    ```
    public class ArrayMain {
        public static void main(String args[]){
            ...
        }
    }
    ```

    ```
    $ javac ArrayMain.java
    $ java ArrayMain a b c d
    ```

## 5. 참조 자료형

### 5.1 this 예약어
- '이 객체'를 의미. 생성자와 메소드 안에서 사용 가능. 
- 객체의 변수와 매개 변수의 이름이 동일할 때 서로 구분하기 위해서 사용

### 5.2 메소드 overloading
- 자바에서는 타입이 다르면 다른 메소드로, 타입이 같고 변수 이름이 같으면 같은 메소드로 인식됨
- 메소드의 이름을 같게 하고, 매개 변수만을 다르게 하는것을 overloading이라고 함. 만약 이름, 매개변수가 같은데 리턴 타입이 다르면 컴파일러가 메소드 호출 시 어느 쪽을 호출해야 할지 알 수 없게 되기 때문에 컴파일 오류가 발생
- 리턴 타입은 overloading 기준은 아니므로 메소드명만 동일하고 매개변수, 리턴 타입이 달라도 overloading에 해당함
- 같은 역할을 하는 메소드는 (매개변수가 달라지더라도) 같은 메소드 이름을 가져야 한다는 모토로 사용하는 것

### 5.3 static 메소드
- 객체를 생성하지 않아도 호출 가능한 메소드. 단, 해당 메소드 안에서는 클래스(static) 변수만 사용 가능
    - 단지 static 메소드에서 사용하기 위해 변수를 static으로 선언하는것은 지양해야 함. 인스턴스 변수에 static을 붙이면 해당 클래스의 모든 인스턴스 객체에서 하나의 값을 바라보게 됨

### 5.4 static 블록
- 해당 클래스의 인스턴스 객체를 여러개 생성해야하지만, 한번만 호출되어야 하는 코드가 있을 경우 사용
- 선언 위치 상관없이 무조건 생성자보다 먼저 실행되며 메소드가 아닌 클래스 내에 선언되어야 함
- static 메소드와 마찬가지로 static 블록 안에서는 static한 것들만 호출 가능
- 생성자가 불리지 않아도 해당 클래스에 대한 참조가 발생하자마자 호출되므로 static 인스턴스 변수의 기본값을 덮어 씌움
    ```
    public class StaticBlock {
        static int data = 1;
        public StaticBlock(){
            ...
        }

        static {
            data = 3;
        }

        static {
            data = 5;
        }

        public static int getData(){
            return data;
        }
    }

    pulic void ddd() {
        // StaticBlock 클래스에 대한 참조 발생
        // data=5 출력됨
        System.out.println("data=" + StaticBlock.getData()); 
        StaticBlock block1 = new StaticBlock();
    }
    ```

### 5.5 Pass by Value, Pass by Reference
- 모든 기본 자료형은 Pass by Value, 참조 자료형은 값이 아닌 참조가 전달되는 Pass by Reference
- String b = "z"와 String b = new String("z")는 동일하게 new를 사용하여 객체를 생성한 것과 같기 때문에, 호출하는 함수에 인자로 String 변수를 전달해도 참조가 아닌 객체가 새로 생성(복사)되어 넘어간 것이 됨
    ```
    ...
    String a = "a";
    passByValue(b);
    public void passByValue(String b){
        b = "b";    // 여전히 a 변수의 값은 "a"로 유지됨
    }
    ```

### 5.6 매개변수를 임의의 개수만큼 전달하기
-  함수로 넘길 매개 변수의 수를 정하기 애매한 경우 아래와 같이 사용할 수 있으나 넘길 숫자들을 직접 배열로 만든 후 넘겨줘야 한다는 단점이 있음
    ```
    ...
    varargs.calculateNumbersWithArray(new int[]{1, 2, 3, 4, 5});
    public void calculateNumbersWithArray(int []numbers){
        ...
    }
    ```
- 아래와 같이 "타입...변수명"으로 선언해도 마찬가지로 numbers는 배열로 인식되며, 함수 호출 시 필요한만큼 매개변수를 바로 넘길 수 있어 편리함
    ```
    ...
    varargs.calculateNumbers(1, 2, 3, 4, 5);
    public void calculateNumbers(int...numbers){
        ...
    }
    ```
    - 해당 방식은 하나의 메소드에서 한 번만 사용 가능하고, 여러 매개 변수가 있다면 가장 마지막에 선언해야 함
        ```
        public void arbitrary(String message, int...numbers){   //해당 매개변수 마지막으로
            ...
        }
        ```   
    - System.out.printf() 메소드는 아래와 같이 정의되어 가장 앞에 출력하는 포맷을 선언하고, 뒤에는 Object라는 타입의 args를 임의의 개수만큼 받을 수 있음
        ```
        printf(String format, Object...args)   //format 문자열에 정의한 포맷 수만큼 args로 전달하여 출력할 수 있음
        ```

## 6. 패키지

### 6.1 패키지 선언 시 규칙
- 소스의 가장 첫 줄에 있어야 함
- 패키지 선언은 소스 하나에 하나만 있어야 함
- package 선언과 파일 시스템의 디렉토리 구조가 일치해야 컴파일 또는 실행 시 해당 소스 또는 클래스 파일을 찾을 수 있음
- 컴파일 시 javac 명령에 package 구조에 맞는 소스 파일 경로를 줘야 함. 따라서 패키지 루트 디렉토리(package com.example로 정의한 경우 com이 패키지 루트 디렉토리)의 디렉토리나 그 상위 디렉토리에선 컴파일 가능하지만 하위 디렉토리에선 안됨
    ```
    # Main.java에 package com.example로 선언 시

    cd src
    javac com/example/Main.java
    # 현재 디렉토리(src)가 패키지 루트
    # 클래스 파일도 com/example 밑에 Main.class로 생성됨

    # 또는
    javac -d out src/com/example/Main.java
    # 패키지 루트 디렉토리의 상위 디렉토리에서 컴파일하지만 package 구조에 맞는 소스 파일 경로를 포함함
    # -d out: out이 클래스파일 기준 패키지 루트. 사용 시 클래스 파일 기준 패키지 루트와 소스 파일 기준 패키지 루트가 달라짐. 소스 파일 경로와 클래스 파일 경로를 다르게 하고 싶을 때 사용
    # out 폴더 밑에 package 선언과 동일하게 디렉토리 구조 생성됨(com/example 폴더 생성)
    ```
- 클래스 파일 실행 시에는 -cp 옵션으로 클래스 파일 기준 패키지 루트 패키지 디렉토리 지정 가능
    ```
    java -cp out com.example.Main
    ```
- 패키지를 사용하는 클래스(별도의 package 선언을 한 클래스)를 실행할 때는 항상 패키지명.클래스명 전체를 포함해서 실행해야 함
- 패키지 이름은 모두 소문자로 지정해야 하며, 자바의 예약어를 포함할 수 없음

### 6.2 패키지 import
- 자바에서는 같은 패키지에 있는 클래스들과 java.lang 패키지에 있는 클래스들만 찾을 수 있음. 그외에는 import 패키지명.클래스명을 정의해줘야 함
- import로 불러온 클래스를 따로 컴파일하지 않았어도 해당 클래스를 사용하는 소스 파일을 컴파일하면 (그리고 import한 패키지명과 실제 해당 클래스의 소스 파일이 있는 디렉토리 경로가 일치하면) 해당 클래스를 먼저 컴파일한 후 호출하는 클래스를 컴파일 함
- 특정 패키지의 하위 패키지들을 모두 import하고자 할 경우 import c.javapackage.sub.*;사용
    - 단, 해당 패키지의 바로 하위 패키지만 import 하므로 import c.*를 한다고 해서 c.javapackage의 하위 패키지들까지 import 되진 않음
    - 폴더 구조상 상위 패키지에 있는 클래스와 하위 패키지에 있는 클래스의 상관관계는 자바 언어 상에는 없으며, 단지 논리적으로 어떤 패키지 하위에 있는지 여부를 따지기 위함임
- 클래스안에 static 메소드나 변수가 있을 경우 import static을 사용하여 해당 메소드나 변수를 직접 import 할 수 있음
    - import static을 사용안 할 경우 해당 클래스를 import하여 클래스명.static_메소드/변수 형태로 사용해야 함
    - import 클래스명.*로 해당 static 메소드/변수 import할 때도 마찬가지로 import static 사용
    - static 메소드/변수가 직접 import되므로 해당 메소드/변수를 import 한 클래스에 이름이 중복되는 메소드/변수가 있을 수 있는데, 이 경우 자신의 클래스에 있는 변수/메소드가 더 우선됨

### 6.3 자바의 접근 제어자
- public : 누구나 접근 가능
- protected : 같은 패키지 내에 있거나 상속받은 경우에만 접근 가능
- package-private : 아무런 접근 제어자를 적어주지 않은 경우. 같은 패키지 내에 있을 때만 접근 가능
- private : 해당 클래스 내에서만 접근 가능
- 구조상으론 public > protected > package-private > private

| 지시자            | 해당 클래스 안에서 | 같은 패키지에서 | 상속받은 클래스에서 | import한 클래스 또는 그외에서 |
|-------------------|--------------------|------------------|------------------|----------------------|
| public            | O                  | O                | O                | O                    |
| protected         | O                  | O                | O                | X                    |
| package-private   | O                  | O                | X                | X                    |
| private           | O                  | X                | X                | X                    |

- 유의점 : public으로 선언된 클래스가 소스 내에 있다면 그 소스 파일의 이름은 public과 동일해야 함
    - 소스 파일명과 일치하는 클래스가 있어야 하는 건 아님

## 7. 상속

### 7.1 상속 예약어와 동작
- extends는 클래스를 상속 받기 위해 사용하는 자바 예약어. 자바에선 하나의 클래스만 상속 가능
- 자식 클래스에서는 부모 클래스에 있는 public, protected로 선언된 모든 인스턴스 및 클래스 변수와 메소드 사용 가능. package-private는 패키지가 같을 경우 사용 가능
- 상속이란 분류. A는 B의 한 종류이다 (=is kind of)
- 자식 클래스 생성자에서 super(매개변수)를 명시적으로 지정하지 않으면 컴파일 시 자동으로 부모클래스의 기본생성자를 호출하는 super()가 추가됨. 따라서 부모 클래스에 기본 생성자가 없으면 에러 발생할 수 있음
- super()는 반드시 자식 클래스의 생성자에서 가장 첫줄에 선언되어야 함

### 7.2 메소드 오버라이딩
- 부모 클래스 메소드와 동일한 시그니처(메소드 이름, 매개변수 타입 및 개수)를 갖는 자식 클래스의 메소드가 존재할 때 성립됨 (다르면 오버로딩)
- 부모 클래스의 메소드와 이름이 같으면서 리턴 타입이 다른 메소드는 자식클래스에서 정의할 수 없음
    - 변수 이름은 같을 수 있으나 권장하지 않음
- 접근제어자는 부모 클래스 메소드와 다르게 할 수 있으나, 확대되는 것만 가능하고 축소되는 것은 안됨 (public > protected > package-private > private)

### 7.3 참조 자료형의 형변환
- 기본 자료형에서 데이터 범위가 더 확장되는 경우(int -> long)와 마찬가지로 참조 자료형에서도 자식 클래스 타입을 부모 클래스 타입으로 형 변환시 명시적인 형 변환이 필요 없음 (데이터의 범위가 넓어지는 거지 사용 가능한 변수나 메소드가 많아진다는 걸 의미하진 않음)
- 부모 타입 객체를 자식 타입으로 형 변환 시에는 명시적인 타입 지정 필요. 이때, 변환하더라도 실제 들어있는 객체가 자식 타입이 아니면 사용 불가능
- 개발 편의상 부모 타입 배열 등에 여러가지 자식 타입의 값을 담아야 하는 경우가 있음
- instanceof 예약어를 사용하면 객체의 실제 타입을 확인할 수 있는데, 부모 타입으로 체크해도 true가 반환됨
- 다형성 : 부모 타입 변수에 자식 타입 객체가 들어있어도 실제 호출되는 것은 원래 객체(자식 타입 객체)에 있는 메소드임

## 8. 자바 API

### 8.1 API 
- JDK에는 매우 많은 클래스와 메소드를이 포함되어 있으며, JDK에 포함된 클래스들 외에도 엄청나게 많은 클래스들이 존재함. 이러한 클래스들을 설명하는 API 문서는 HTML로 구성됨
- API 문서는 클래스 및 메소드에 API에 명시되도록 하기 위한 주석을 달고 jdk/bin 디렉터리에 있는 javadoc 명령어만 실행하면 자동으로 생성됨

### 8.2 API 문서 상세 정보화면
- 패키지와 클래스 / 인터페이스 이름
- 클래스 상속 관계 다이어그램
    - 해당 클래스가 어떤 클래스들의 상속을 받았는지 간단한 계단식으로 표시
- 직속 자식 클래스
    - 현재 보고 있는 클래스를 확장한 클래스들의 목록
- 알려진 모든 하위 인터페이스 목록
    - 인터페이스에 대한 문서일 경우 해당 인터페이스 상속받은 인터페이스 목록
- 알려진 모든 구현한 클래스 목록
    - 해당 인터페이스를 구현한 클래스들의 목록
- 구현한 모든 인터페이스 목록
    - 클래스에서 구현한 모든 인터페이스 목록
- 클래스 / 인터페이스의 선언 상태
    - 클래스가 어떤 접근 제어자를 사용했는지, final 클래스인지 등을 확인
- 클래스 / 인터페이스의 설명
    - 클래스의 용도, 사용법, 사용 예시 등
    - Since : 해당 클래스가 JDK 몇 버전부터 추가되었는지 명시. 클래스만이 아닌 클래스에 선언된 상수 필드나 메소드에도 Since 표시되어 있는 경우가 있음
    - See also : 해당 클래스와 관련되어 있는 모든 클래스나 인터페이스, 메소드 등의 링크 제공
- 내부 클래스 종합
    - 클래스 안에 내부 클래스가 public하게 선언된 경우 그에 대한 내용 제공
- 상수 필드 종합
    - public static으로 선언한 상수 필드
- 생성자 종합
- 메소드 종합
    - 클래스에 선언되어 있는 모든 public 및 protected 메소드에 대한 종합 정보
    - 각 메소드의 리턴 타입, 매개 변수, static 여부, 접근제어자
    - javadoc 설명에 따르면 API 문서 생성 시 private도 보이도록 할 수 있음
- 부모 클래스로부터 상속받은 메소드 들
- 상수 필드 상세 설명
    - 선언된 상수 필드가 어떤 내용을 제공하는지에 대한 상세설명
    - Since, See Also가 제공되기도 함
- 생성자 상세 설명
    - 해당 생성자를 어떻게 사용하고, 매개 변수, 리턴 값 정보와 이 생성자에서 던지는 예외는 언제 발생하는지 등
    - Since, See Also가 제공되기도 함
- 메소드 상세 설명
    - Since, See Also가 제공되기도 함

### 8.3 API 문서 Header / Footer에 있는 링크
- OVERVIEW
    - 전체 패키지에 대한 설명 화면. Java SE 모듈과 JDK 모듈과 그 외 모듈로 분하여 정리됨
- MODULE
    - 패키지 묶음 설명화면. Java SE 모듈과 JDK 모듈과 그 외 모듈 등
- PACKAGE
    - 현재 보고 있는 클래스가 속한 패키지의 모든 인터페이스, 클래스, 예외 등 간단한 설명
- CLASS
    - USE 페이지에서 클래스 상세 설명으로 넘어가는 링크 클릭하여 이동
- USE
    - 현재 보고 있는 패키지, 클래스, 인터페이스 등을 사용(매개변수나 멤버 변수 및 기타 등등)하는 모든 목록 나열
    - 처음 보는 클래스가 어디 사용되는지 확인하기 좋음
- TREE
    - 클래스가 속한 패키지에 있는 모든 클래스들의 상속 관계를 Tree 형태로 제공
- DEPRECATED
    - JDK에 포함된 클래스/메소드 중 deprecated 클래스나 메소드 목록
- INDEX
    - A부터 Z까지의 알파벳 클릭하여 각 알파벳에 해당하는 클래스, 인터페이스, 메소드, static 변수 등의 색인을 오름차순으로 제공
- HELP
    - API 문서에 대한 간단 설명

## 9. java.lang.Object

### 9.1 Object 클래스의 메소드
- 자바에서는 기본적으로 아무런 상속을 받지 않을 경우 java.lang.Object 클래스를 확장함. 따라서 Object 클래스의 메소드는 모든 클래스에서 사용가능
- 주요 메소드
    - toString()
        - 객체가 System.out.println() 메소드에 매개 변수로 들어가거나 객체에 대하여 더하기 연산 할때 자동 호출됨
        - String을 제외한 참조 자료형에 더하기 연산을 수행하면 자동으로 toString() 메소드가 호출되어 그 리턴 값이 더해지게 됨
    - equals()
        - == 연산자는 참조 자료형의 경우 단순 주소값을 비교하므로 equals() 메소드를 오버라이딩 하여 사용. 오버라이딩 하지 않으면 equals() 메소드에서는 hashCode() 메소드 리턴 값인 주소값으로 비교함
        - 만약 어떤 두 개의 객체가 서로 동일하다면 hashCode() 값 역시 무조건 동일해야 하므로 equals() 메소드를 오버라이딩 시 hashCode()도 같이 해야함
    - hashcode()
        - 기본적으로 객체의 메모리 주소를 16진수로 반환
        - 자바 API 문서에는 equals(), hashcode() 오버라이딩 시 지켜야 할 규칙을 명시하고 있는데, 이러한 제약들 때문에 해당 메소드들을 직접 작성하는건 권장하지 않으며 개발 툴에서 자동 생성해주는 기능을 사용하는 것이 좋음
    - wait(), notify(), notifyAll()
        - 스레드 처리 시 사용
    - 그 밖에 객체의 복사본을 반환하는 clone(), 더 이상 쓸모없어진 객체를 정리하기 위해 GC가 호출하는 finalize(), 객체가 어떤 클래스의 인스턴스인지에 대한 메타데이터 객체를 반환하는 getClass() 등

## 10. 인터페이스와 추상클래스, enum

### 10.1 인터페이스
- 개발 절차의 설계 단계에서 인터페이스를 만들어두면 개발 단계에서 메소드의 이름, 매개변수에 대해 일일이 고민하지 않을 수 있음. 실제 코드는 만들지 않더라도 어떤 메소드들이 있어야 하는지 정의할 때 사용
- implements 라는 예약어 사용. 끝에 s가 붙는 것은 클래스 자체가 3인칭 단수이기 때문
- implements 뒤에는 여러 인터페이스가 올 수 있음
- abstract 클래스가 아닌 인터페이스를 구현하는 클래스에서는 반드시 인터페이스에 정의된 메소드들을 구현해야 함

### 10.2 추상클래스
- abstract 클래스는 abstract 클래스를 구현해 놓은 클래스를 통해 초기화 및 실행 가능
- abstract로 선언한 메소드는 반드시 abstract 클래스 안에 있어야 함
- 인터페이스와 달리 구현되어 있는 메소드가 있을 수 있으며 static이나 final 메소드도 가능
- abstract 클래스는 상속과 동일하게 extends 예약어로 구현. 인터페이스와 유사하게 구현하는 클래스에서는 상속받은 abstract 메소드를 반드시 구현해야 함
- 설계 단계에서 인터페이스 선언 시 어떤 메소드는 미리 만들어 놓아도 문제가 없는 경우 사용

    | 구분                           | 인터페이스       | abstract 클래스  | 클래스   |
    | ------------------------------ | ---------------- | ---------------- | -------- |
    | 선언 시 사용하는 예약어          | interface        | abstract class   | class    |
    | 구현 안 된 메소드 포함 가능 여부 | 가능(필수)       | 가능             | 불가     |
    | 구현된 메소드 포함 가능 여부     | 불가             | 가능             | 가능(필수) |
    | static 메소드 선언 가능 여부     | 불가             | 가능             | 가능     |
    | final 메소드 선언 가능 여부      | 불가             | 가능             | 가능     |
    | 상속 가능                       | 불가             | 가능             | 가능     |
    | 구현 가능                       | 가능             | 불가             | 불가     |

### 10.3 final
- 클래스에 선언할 경우 해당 클래스 상속 불가
- 메소드에 선언할 경우 해당 메소드 오버라이딩 불가
- 변수에 선언할 경우 더 이상 값을 바꿀 수 없음. 따라서 인스턴스 변수나 static 변수, 참조 자료형의 경우 여러곳에서 사용될 수 있으므로 선언과 함께 값을 지정해야 함
- 매개 변수나 지역 변수가 final일 경우는 반드시 선언할 때 초기화할 필요는 없음
- 참조 자료형 클래스가 final이라고 해서 그 안에 있는 인스턴스 변수나 static 변수가 final이 되진 않음. 따라서 해당 값들은 변경 가능

### 10.4 enum
- 상수의 집합으로, 타입이자 클래스의 일종
- enum 클래스에 있는 상수들은 별도로 타입이나 값을 지정할 필요가 없음
    ```
    public enum OverTimeValues {
        THREE_HOUR,
        FIVE_HOUR,
        WEEKEND_FOUR_HOUR,
        WEEKEND_EIGHT_HOUR;

        // 컴파일러가 기본 생성자 자동 생성
        private OverTimeValues() { }
    }

    public class OverTimeManager {
        public getOverTimeAmount(OverTimeValues value){
            int amount = 0;
            Sytstem.out.println(value);
            switch(value){
                case THREE_HOUR:
                    amount = 18000;
                    break;
                case FIVE_HOUR:
                    amount = 30000;
                    break;
                case WEEKEND_FOUR_HOUR:
                    amount = 40000;
                    break;
                case WEEKEND_EIGHT_HOUR:
                    amount = 60000;
                    break;
            }
            return amount;
        }
    }

    public class OverTimeManager {
        public static void main(String args[]){
            OverTimeManager manager = new OverTimeManager();
            int myAmount = manager.getOverTimeAmount(OverTimeValues.THREE_HOUR); // enum 클래스이름.상수이름 지정만으로 객체 생성 완료
            System.out.println(value2.getAmount);
        }
    }

    // 출력 결과
    
    // THREE_HOUR
    // 18000
    ```
- enum 클래스는 생성자는 package-private 나 private로만 만들 수 있으며 생성자를 통하여 객체를 생성할 수는 없음. package-private로 선언해도 사실상 private로 동작하며, 각 상수를 enum 클래스 안에서 선언할 때에만 이 생성자를 사용할 수 있음
- 보통 클래스와 마찬가지로 메소드 선언하여 사용 가능
- 필요할 경우 enum 상수 값을 처음부터 지정할 수 있음
    ```
    public enum OverTimeValues2 {
        THREE_HOUR(18000),
        FIVE_HOUR(30000),
        WEEKEND_FOUR_HOUR(40000),
        WEEKEND_EIGHT_HOUR(60000);

        private final int amount;

        OverTimeValues2(int mount){
            this.amount = amount;
        }
        public int getAmount(){
            return amount;
        }
    }

    public class OverTimeManager2 {
        public static void main(String args[]){
            OverTimeValues2 value2 = OverTimeValues2.FIVE_HOUR;
            System.out.println(value2);
            System.out.println(value2.getAmount);
        }
    }

    // 출력결과

    // FIVE_HOUR
    // 30000
    ```
- enum 클래스의 각 상수는 해당 클래스(= OverTimeValues2)의 인스턴스 변수가 아닌, 인스턴스 자체로 간주하면 됨. 따라서 해당 클래스에 인스턴스 변수가 늘어나면 각 상수가 가지는 값의 개수도 늘어남
- enum 클래스는 무조건 java.lang.Enum 클래스의 상속을 받음

    | 접근 제어자 | 메소드 | 설명  |
    | ----------- | -------- | -------- |
    | protected   | Enum(String name, int ordinal) | 컴파일러에서 자동 호출되도록 해둔 생성자 |

- name은 enum 상수의 이름이며 ordinal은 상수가 선언된 순서대로 0부터 증가
- Enum 클래스의 부모 클래스는 Object 클래스이나, Enum 클래스에서 Object 클래스 중 4개의 메소드(clone(), finalize(), hashCode(), equals())를 오버라이딩하지 못하도록 막아 toString()만 오버라이딩 가능. toString()은 기본적으로 상수 이름을 출력해줌
- Enum 클래스에서 선언되어 있는 메소드 중에서는 compareTo(E e)가 있는데, enum 타입과 순서 차이(ordinal)를 반환함. 같은 상수라면 0을 반환 
- 그 외에 API 문서에 없는 특수한 메소드로 values()라는 static 메소드가 있는데, enum 클래스에 선언되어 있는 모든 상수를 배열로 반환. enum 객체에 어떤 상수가 어떤 순서로 선언되었는지 확인하기 좋음

## 11. 예외

### 11.1 try-catch 문
- try 블록 내에서 선언한 변수는 catch에서 인식되지 않음. try 앞에 미리 선언해놔야 함
- finally 블록은 try-catch 블록 이후, 예외 발생 여부와 상관 없이 항상 실행됨
- catch 블록을 여러개 정의하여 서로 다른 타입의 예외를 캐치하려할 경우 앞 catch 블록에서 캐치된 경우 뒤로는 전달이 되지 않음. 따라서 catch문의 예외는 체크해야 할 순서대로 나열해야 함
- 모든 예외 클래스의 부모 클래스는 java.lang.Exception으로, Exception 클래스는 모든 예외를 캐치하므로 맨 밑에 사용해 예외들이 빠져나가지 못하도록 묶어두는 역할을 하는게 좋음. 캐치되지 않아 예외가 발생할 경우 해당 스레드는 끝남

### 11.2 예외의 종류 3가지
![예외 클래스 상관 관계도](/assets/images/자바예외.jpeg)
- error
    - 자바 프로그램 밖에서 발생한 예외 (서버 디스크 고장, 메인보드 고장 등으로 자바 프로그램이 동작 못하는 경우)
    - 프로세스에 영향을 준다는 점에서 스레드에 영향을 주는 Exception과 구분됨
- checked exception
    - Exception을 확장한 예외들
    - NullPointerException, NumberFormatException, ClassCastException.. 및 기타 등등
- runtime exception
    - RuntimeException을 확장한 예외들
    - 컴파일 시점이 아닌 실행 시점에 발생 가능. 따라서 try-catch로 묶지 않아도 컴파일시에 예외가 발생하지는 않으나 묶어두는 편이 좋음
    - IOException, SQLException.. 및 기타 등등

### 11.3 java.lang.Throwable
- Throwable의 생성자
    - Throwable()
    - Throwable(String Message)
    - Throwable(String Message, Throwable casue)
    - Throwable(Throwable casue)
- Throwable 클래스에 선언되어 있고 Exception 클래스에서 오버라이딩 한 주요 메소드
    - getMessage()
        - 예외 메시지를 String 형태로 제공받음. 어떤 예외가 발생했는지에 대한 예외 메시지를 활용하여 사용자에게 별도의 예외 메시지를 보여주기 위해 오버라이딩 가능
    - toString()
        - getMessage()와 비슷하나 약간 더 자세하게, 예외 클래스 이름도 같이 제공받음
    - printStackTrace()
        - 첫 줄에 예외 메시지를, 두 번째 줄부터는 예외가 발생하게 된 메소드들의 스택 트레이스 출력
        - printStackTrace > toString > getMessage 순으로 자세함

### 11.4 throw, throws
- 예외를 직접 던지려면 throw 예외객체; 실행. catch문에 해당 예외를 잡아줄 객체나 부모 객체가 정의되어있지 않을 경우 해당 예외가 발생한 메소드 밖으로 던져짐
- 이때 예외를 던지는 메소드 선언 옆에는 throws + 예외 클래스가 붙어야 함. 해당 메소드를 호출한 메소드로 예외 처리를 위임한다는 의미. 해당 메소드에선 try-catch문이 없어도 되며 해당 메소드를 호출한 메소드에서 호출문을 try-catch문으로 감싸주거나 예외를 다시 그 밖으로 위임할 수 있음
- Exception을 던질 가능성이 있는 코드가 try-catch나 throws가 강제되는 건 checked exception에 한정됨
- 가장 좋은 방법은 throws하는 메소드를 호출하는 메소드에서 try-catch로 처리하는 것. 예외가 시작된 메소드에서는 어떻게 처리해야할지 알 수 없는 경우가 있으니 책임이 있는 곳(메소드)에서 처리해야 함
- implements 처럼 throws 뒤에도 여러 예외 클래스가 올 수 있음

### 11.5 사용자 정의 Exception
- Throwable이나 그 자식 클래스의 상속을 받아야 함
- try-catch로 묶어줄 필요가 있을 경우에만 Exception클래스 확장, 실행 시 예외를 처리할 수 있는 경우에는 RuntimeException 클래스 확장

## 12. String

### 12.1 String 클래스 선언
```
public final calss String extends Object
     implements Serializable, Comparable<String>, CharSequence
```
- Serializable 인터페이스 : 구현해야 하는 메소드가 하나도 없음. 구현 시 해당 객체를 파일로 저장하거나 다른 서버에 전송 가능한 상태가 됨
- Comparable 인터페이스 : compareTo() 메소드를 상속받아 구현함. 매개변수로 받은 객체를 비교하여 같으면 0, 알파벳 순으로(정확히는 유니코드 값에 따라) 앞이면 -1, 뒤이면 1 반환. 알파벳 순서만큼 그 숫자값이 커짐
- CharSequence 인터페이스 : 해당 클래스가 문자열을 다루기 위한 클래스라는 것을 명시적으로 나타내는데 사용

### 12.2 String <-> 바이트 배열 변환
- String 클래스에는 다양한 생성자가 있지만 아래 2개가 가장 많이 사용됨
    - String(byte[] bytes) : 현재 JVM이 실행되는 환경의 기본 문자 인코딩 방식의 캐릭터 셋을 사용하여 제공된 byte 배열을 디코딩한 String 객체를 생성
    - String(byte[] bytes, String charsetName) : 지정된 캐릭터 셋을 사용하여 제공된 byte 배열을 디코딩한 String 객체를 생성
    - 생성자의 매개 변수로 받는 byte 배열은 String 클래스의 아래의 메소드로 생성됨
        - byte[] getBytes() : 기본 캐릭터 셋의 바이트 배열 생성
        - byte[] getBytes(Charset charset) : 지정한 캐릭터 셋으로 바이트 배열 생성
        - byte[] getBytes(String charsetName) : 지정한 캐릭터 셋 이름으로 바이트 배열 생성
    - java.nio.Charset 클래스 API에는 표준 캐릭터 셋이 정해져 있음.
        - UTF-8, UTF-16, EUC-KR 및 기타 등등
        - 한글을 처리하기 위해 자바에서 많이 사용하는 캐릭터 셋은 UTF-16
    - 문자가 깨지는 것을 방지하려면 문자열 <-> 바이트 배열 전환 시 동일한 캐릭터 셋을 사용해야 함
    - 한글을 byte 배열로 만들 때 어떤 캐릭터 셋을 쓰느냐에 따라서 배열의 크기가 달라짐. EUC-KR은 두글자에 4바이트, UTF-16은 6바이트
    - String 타입의 캐릭터 셋을 매개변수로 받는 아래의 두 생성자/메소드는 UnsupportedEncodingException 체크 예외를 발생시킬 수 있음. 따라서 반드시 try-catch로 감싸줘야 함
        - String(byte[] bytes, String charsetName)
        - byte[] getBytes(String charsetName)

### 12.3 String의 다양한 메소드

#### 12.3.1 문자열의 길이를 확인하는 메소드 
- length() : 배열의 크기를 확인하는 .length와 달리 괄호가 붙음. 배열은 객체이나 메소드는 없는 특수한 객체

#### 12.3.2 문자열이 같은지 비교하는 메소드
- boolean equals(Object anObject)
- boolean equalsIgnoreCase(String anotherStr)
- int compareTo(String anotherStr)
- int compareToIgnoreCase(String str)
- boolean contentEquals(CharSequence cs)
- boolean contentEquals(StringBuffer sb)
- 모두 매개변수로 넘어온 값과 String 객체가 같은지를 비교하는 메소드로 IgnoreCase가 붙은 메소드들은 대소문자 구분을 할지 안할지 여부만 다름
- String 클래스의 equals() 메소드는 오버라이딩 되어 주소값이 아닌 value를 비교함
- 자바에는 객체들을 재사용하기 위해 Constant Pool이라는 것이 만들어져 있는데, String의 경우 동일한 값을 갖는 객체가 있으면 이미 만든 객체를 재사용함. 따라서 아래의 text와 text2는 동일한 객체가 됨
    ```
    String text = "Check value";
    String text2 = "Check value";
    if(text == text2){
        ...
    }
    if(text.equals("Check value")){
        ...
    }
    //두 if문 모두 true가 됨
    ```
- 같은 문자열 값이어도 Constant Pool 활용하지 않고 별도의 객체를 생성하고 싶으면
    ```
    String text = "Check value";
    String text2 = new String("Check value");
    ```
- comepareTo() 메소드 설명은 앞의 12.1참고, contentEquals는 2권에서

#### 12.3.3 특정 조건에 맞는 문자열이 있는지를 확인하는 메소드
- boolean startsWith(String prefix)
- boolean startsWith(String prefix, int toffset)
- boolean endsWith(String suffix)
- boolean contains(CharSequence s)
- boolean matches(String regex)
    - contains()와 유사하나 매개변수가 정규표현식이어야 함
- boolean regionMatches(int toffset, String other, int ooffset, int len)
- boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)
    - ignoreCase : true일 경우 대소문자 구분없이 비교
    - toffset : 비교 대상 문자열의 확인 시작 위치 지정
    - other : 존재하는지를 확인할 문자열
    - ooffset : other 객체의 확인 시작 위치 지정
    - len : 비교할 char의 개수 지정 (비교 대상 문자열의 확인 시작 위치, other 객체의 확인 시작 위치로부터 몇개 문자가 일치하는지 확인할지)
    - 매개 변수의 값이 잘못된 경우 무조건 false 반환됨

#### 12.3.4 String 내에서 위치를 찾는 메소드
- int indexOf(int ch)
- int indexOf(int ch, int fromIndex)
- int indexOf(String str)
- int indexOf(String str, int fromIndex)
- int lastIndexOf(int ch)
- int lastIndexOf(int ch, int fromIndex)
- int lastIndexOf(String str)
- int lastIndexOf(String str, int fromIndex)
- inexOf()는 가장 앞에서부터, lastIndexOf()는 뒤에서부터 문자열이나 char을 찾음
- int ch는 char을 의미함. char은 정수형이기 때문에 매개변수로 char 넘기면 자동으로 int로 형변환 됨
- fromIndex는 문자열의 가장 왼쪽 기준 몇번째 자리부터 값을 확인할지에 대한 값으로 IndexOf()에서는 해당 위치로부터 오른쪽으로, lastIndexOf()에서는 왼쪽으로 탐색함
- 해당 char이나 문자열이 없으면 -1 반환

#### 12.3.5 String 값의 일부를 추출하기 위한 메소드
- java 8까지 String 클래스에선 String 문자열의 값을 char 배열로 저장해왔으나, 성능과 메모리 활용성을 고려하여 java 9부터는 byte 배열로 내부적으로 저장
- char 단위의 값을 추출하거나 char 배열 <-> String 변환 메소드
    - char charAt(int index) : 특정 위치의 char 값을 반환
    - static String copyValueOf(char[] data) : char 배열 -> 문자열
    - char[] toCharArray() : 문자열 -> char 배열
- 문자열의 일부 값을 잘라내는 메소드
    - String substring(int beginIndex) : beginIndex부터 끝까지 문자열 잘라 반환
    - String substring(int beginIndex, int endIndex) : beginIndex부터 endIndex까지 문자열 잘라 반환
    - CharSequence subSequence(int beginIndex, int endIndex) : beginIndex부터 endIndex까지 문자열을 잘라 반환
- 문자열을 여러 개의 String 배열로 나누는 split 메소드
    - String[] split(String regex) : 정규 표현식에 맞춰 문자열을 잘라 String 배열로 반환
    - String[] split(String regex, int limit) : 위와 유사하나 반환하는 String 배열 크기에 대한 limit가 있음
    - 정규표현식이나 특정 알파벳, 기호 하나로 문자열을 나눌경우 split()를, 특정 String으로 문자열을 나눌경우 StringTokenizer 클래스를 이용하는 편이 용이함

#### 12.3.6 String값을 바꾸는 메소드
- 문자열을 합치거나 공백을 제거하는 메소드
    - String concat(String str) : 자바에선 +로 문자열을 더할 수 있어 잘 사용 안됨
    - String trim() : 문자열의 맨앞과 맨뒤에 있는 공백들을 제거. 문자열에 공백을 제외한 char값이 하나 이상 있는지 확인하는데 사용할 수 있음
        ```
        String text = " a ";
        if(text!=null && text.trim().length() > 0){
            System.out.println("OK");
        }
        ```
- 내용을 교체하는 메소드
    - String replace(char oldChar, char newChar) : 문자열에서 oldChar 문자를 newChar 문자로 모두 치환
    - String replace(CharSequence target, CharSequence replacement) : 문자열에서 target 문자열을 replacement 문자열로 모두 치환
    - String replaceAll(String regex, String replacement) : 정규 표현식에 매칭되는 모든 부분을 replacement로 치환
    - String replaceFirst(String regex, String replacement) : 정규 표현식에 매칭되는 첫번째 내용을 replacement로 치환
- 특정 형식에 맞춰 값을 치환하는 메소드
    - static String format(String format, Object... args)
    - static String format(Locale 1, String format, Object... args) : 지정한 Locale 지역 규칙에 따라 포맷팅
    - %s는 String, %d는 정수형, %f는 소수점이 있는 숫자, %%는 % 의미
        ```
        String name = "민형";
        int age = 25;

        String result = String.format("이름: %s, 나이: %d", name, age);
        System.out.println(result);
        // 출력: 이름: 민형, 나이: 25
        ```
- 대소문자를 바꾸는 메소드
    - toLowerCase()
    - toLowerCase(Locale locale)
    - toUpperCase()
    - toUpperCase(Locale locale)
- 기본 자료형을 문자열로 변환하는 메소드
    - static String valueOf(boolean b) : boolean 값을 "true" 또는 "false" 문자열로 변환
    - static String valueOf(char c)
    - static String valueOf(char[] data)
    - static String valueOf(char[] data, int offset, int count)
    - static String valueOf(double d)
    - static String valueOf(float f)
    - static String valueOf(int i)
    - static String valueOf(long l)
    - static String valueOf(Object obj) : obj 객체의 toString() 결과를 반환. obj 값이 null인 경우에는 NullPointeraexcerption 없이 null을 반환함
    - 별도의 문자열과 합치는 경우에는 valueOf() 사용할 필요없이 자동으로 문자열로 변환됨
        ```
        byte b = 1;
        String byte1 = String.valueOf(b);
        String byte2 = b + ""
        ```
#### 12.3.7 사용해서는 안되는 메소드
- String 클래스에서 관리하는 문자열 풀에 있는 값을 재사용하므로 text, text2는 동일한 객체가 되고, text3은 새로운 객체를 생성

    ```
    String text = "Check value";
    String text2 = "Check value";
    String text3 = new String("Check value");
    ```
- String 클래스에는 자바가 아닌 C로 구현된 intern()이라는 메소드가 있음. 
- intern()을 사용하면 new String(String)으로 생성한 문자열 객체라도 풀에 해당 값이 있으면 풀에 있는 값을 참조하는 객체 반환. 만약 동일한 문자열이 존재하지 않으면 풀에 해당 값을 추가. 따라서 아래를 수행한 뒤의 문자열은 equals()가 아닌 == 으로 값이 동일한지 비교할 수 있음
    ```
    text3 = text3.intern();
    ```
- 문제는 새로운 문자열을 쉴새없이 만드는 프로그램에서 intern() 메소드를 사용하여 억지로 문자열 풀에 값을 할당하게 하면 저장영역의 한계로 별도의 메모리 청소 단계를 거치게 되어 전체 자바 시스템 성능에 악영향을 줌
    - 리터럴만 풀에 저장되기 때문에 아래의 경우 힙 영역에만 객체가 새로 생성되지만
        ```
        for (int i = 0; i < 1000000; i++) {
            String s = "Num" + i;   //i가 변수이므로 해당값은 힙에 저장됨
        }
        ```
    - 아래의 경우에는 강제로 풀에 쌓이게 되어 GC의 부담이 커짐
        ```
        for (int i = 0; i < 1000000; i++) {
            String s = ("Num" + i).intern();
        }
        ```

### 12.4 StringBuffer와 StringBuilder
- String은 immutable(불변의) 객체이므로 한 번 만들어지면 더이상 값을 바꿀수 없음. 문자열을 더하면 새로운 문자열 객체가 생성되고 기존의 객체는 GC의 대상이 됨
- 이러한 쓰레기를 계속 만드는 단점을 보안하기 위해 StringBuffer와 StringBuilder 클래스 제공. StringBuffer와 StringBuilder는 +가 아닌 append() 메소드로 문자열을 더하며 이 때 새로운 객체를 생성하지 않으므로 여러 String을 더하는 연산이 있을 경우 해당 클래스를 적절하게 선택하여 사용하는 것이 좋음
- 두 클래스의 메소드는 동일하나 StringBuffer는 Thread safe하고 StringBuilder는 그렇지 않음. 대신 StringBuilder가 속도는 더 빠름
- append()는 매개변수로 모든 기본 자료형과 참조 자료형을 포함하므로 어떤 값이라도 매개변수로 넣을 수 있음. append()의 반환 타입은 StringBuffer/StringBuilder이므로 연달아 사용 가능
- JDK 5 이상에서는 String 더하기 연산을 할 경우 컴파일 시 자동으로 해당 연산을 StringBuilder로 변환하나, for 루프와 같이 반복 연산을 할 경우에는 자동으로 변환을 해주지 않으므로 수동으로 해야함
- String, StringBuilder, StringBuffer 클래스는 모두 CharSequence 인터페이스를 구현하므로 이 셋 중 하나의 클래스를 사용하여 매개 변수로 받는 작업을 할 때 String이나 StringBuilder 타입으로 받기보다 CharSequence 타입으로 받는 편이 좋음
- 하나의 메소드 내에서 문자열을 생성하여 더할 경우 StringBuilder를 사용해도 문제없으나, 어떤 클래스에 문자열을 생성하여 더하기 위한 인스턴스 변수가 선언되었고 여러 스레드에서 이 변수를 동시에 접근하는 일이 있다면 반드시 StringBuffer를 사용해야 함

## 13. 내부 클래스

### 13.1 내부 클래스 종류
- static 여부에 따라 Static nested 클래스와 내부 클래스로 구분됨
- 내부 클래스는 다시 (로컬) 내부 클래스와 익명 클래스로 나뉨
- 내부 클래스의 용도
    - 한 곳에서만 사용되는 클래스를 논리적으로 묶어서 처리해야 할 때
    - 캡슐화가 필요할 때 (내부 구현 은닉)
    - 소스의 가독성과 유지보성 향상

### 13.2 Static nested 클래스
- 일반 내부 클래스와 달리 감싸고 있는 클래스의 static 변수만 참조할 수 있음
- 반대로 감싸고 있는 클래스에서 내부 클래스의 인스턴스 변수에 접근하려면 static 여부 상관없이 내부 클래스의 객체를 생성해서
그 객체를 통해서만 가능
    - outer를 만든다고 해서 자동으로 inner가 생성되지는 않으며, outer.new Inner()라고 명시적으로 생성해야 Inner 객체가 생성됨. 따라서 Inner 클래스는 문법적으로 내부에 포함되어 있을뿐, 객체 레벨에선 독립적임
- Static nested 클래스를 초기화하려면
    ```
    public class OuterOfStatic {
        static class StaticNested { //Static nested 클래스
            int value = 200;
            
            public int setValue(int value){
                this.value = value;
            }
        }
    }

    public class NestedSample {
        public static void main(String[] args){
            NestedSample sample = new NestedSample();
            sample.makeStaticNestedObject();
        }
        public void makeStaticNestedObject(){
            OuterOfStatic.StaticNested staticNested = new OuterOfStatic.StaticNested();
            staticNested.setValue(3);
        }
    }
    ```
- Outer 클래스와 논리적으로 묶여 있지만, 인스턴스에 종속될 필요는 없는 클래스가 필요할 때 사용. Outer 객체 없이도 생성 가능함
- School, University 클래스가 있을 때 Student 클래스를 독립적으로 생성하는 대신 각 클래스 안에 static으로 생성하면 어느쪽의 Student인지 용도가 보다 명확해짐

### 13.3 내부클래스와 익명클래스
- static 하지 않은 일반 내부클래스는 outer 객체 생성이 먼저 필요함
    ```
    public class InnerSample {
        public static void main(String[] args) {
            // Outer 객체 먼저 생성
            InnerSample outer = new InnerSample();

            // Inner 객체 생성 (Outer 인스턴스를 통해)
            Inner inner = outer.new Inner();
            inner.setValue(5);
            inner.printValue();
        }
    }
    ```
- 하나의 클래스에서 어떤 공통적인 작업을 수행하는 클래스가 필요한데 다른 클래스에서는 그 클래스가 전혀 필요 없을 때 사용
- GUI(사용자 화면용 애플리케이션) 관련 프로그램 개발 시 가장 많이 사용. Swing, Applet, SWT, GWT, 안드로이드 등
- GUI에서 내부클래스들은 리스너를 처리할 때(어떤 버튼이 눌렸을 때) 해야 하는 작업을 정의할 때 많이 쓰임. 버튼마다 작업이 보통 상이하므로 별도로 클래스를 만드는 대신 내부클래스를 만들며, 일회성일 경우 더 간단하게 익명클래스를 사용함
    ```
    public class MagicButton {
        private EventListener listener;

        public void setListener(EventListener listener) {
            this.listener = listener;
        }
        public void onClickProcess(){
            if(listener != null){
                listener.onClick();
            }
        }
    }

    MagicButton button = new MagicButton();
    button.setListener(new EventListener() {   //익명클래스
        public void onClick(View v) {
            System.out.println("Clicked!");
        }
    });
    ```
- 객체 생성처럼 보이나, outer 클래스 내부에서 새로운 클래스의 몸통을 정의했으므로 내부클래스에 속함
- 클래스를 만들고 호출하면 그 정보는 메모리에 올라가므로 많이 생성될수록 메모리 사용량이 늘어나고 애플리케이션 시작 속도가 느려짐. (로컬)내부클래스와 달리 익명클래스를 사용하면 Outer 클래스의 인스턴스 변수 등을 참조하지 않는 이상 Outer 객체와 불필요하게 오래 연결되지 않아 GC의 Outer 객체 회수가 더 용이해짐

## 14. 어노테이션

### 14.1 정의
- 클래스나 메소드 등의 선언시에 @를 사용하는 것. JDK 5부터 등장함
- 컴파일에게 정보를 알려주거나, 컴파일할 때와 설치 시의 작업을 지정하거나, 실행할 때 별도의 처리가 필요할 때 사용함

### 14.2 자바 기본 어노테이션 3개
- @Override
    - 해당 메소드가 Override 된 것이니 잘못 코딩 시 컴파일러가 알려주도록 하기위해 사용
- @Deprecated
    - 컴파일러에게 더 이상 사용하지 않는 클래스/메소드이며 다른이가 사용시 경고하도록 요청하기 위해 사용
    - 여러 사람들과 작업할 경우 @Deprecated로 사용하지 않을것이라는 알림을 제공하여 계도 기간을 거친 후 삭제하는 것이 바람직함
- @SupressWarings
    - 컴파일 시 경고 메시지가 나타날 때 내 의도대로 코딩한 것이니 경고를 해줄 필요가 없다고 컴파일러에게 알리는 용도
    - 속성값을 지정할 수 있음 -> @SupressWarings("deprecation")

### 14.3 메타 어노테이션
- 어노테이션을 직접 선언할 때 사용
- @Target
    - 어노테이션을 어떤 것에 적용할지 선언
    - @Target(ElementType.METHOD)와 같이 괄호 안에 적용대상 지정
        - 적용 대상
            - CONSTRUCTOR
            - FIELD
            - LOCAL_VALIABLE
            - METHOD
            - PACKAGE
            - PARARMETER
            - TYPE : 클래스, 인터페이스, enum 등
- @Retention
    - 얼마나 오래 어노테이션 정보가 유지되는지 선언
    - @RETENTION(RetentionPolicy.RUNTIME)
        - 적용대상
            - SOURCE
            - CLASS
            - RUNTIME
- @Documented
    - 해당 어노테이션에 대한 정보가 Javadocs(API) 문서에 포함된다는 것 선언
- @Inherited
    - 모든 자식 클래스에서 부모 클래스의 어노테이션을 사용 가능하다는 것 선언
- @interface
    - 어노테이션을 선언 시 함게 사용
```
import java.lang.annotation.*;

//적용 대상 지정 (클래스, 메서드 등)
@Target({ElementType.TYPE, ElementType.METHOD})

//유지 정책 지정 (런타임)
@Retention(RetentionPolicy.RUNTIME)

//어노테이션 정의
public @interface UserAnnotation {
    public int number();  // 속성 정의
    public String text() default "This is first annotation" // 기본값 있는 속성
}

@UserAnnotation(number = 1, text = "클래스에 적용")
public class UserService {

    @UserAnnotation(number = 2) // text는 기본값 사용. 기본값 지정되어 있지 않은 number는 반드시 값 지정 필요
    public void createUser() {
        ...
    }
}
```
- 어노테이션 속성은 메타데이터일 뿐 실제 필드가 아니며, 값을 읽어오려면 자바 리플렉션이라는 API에서 제공하는 클래스들을 사용해야 함
- lombok : 개발자가 필요한 작업을 어노테이션 선언만으로도 편하게 처리할 수 있게 도와줌