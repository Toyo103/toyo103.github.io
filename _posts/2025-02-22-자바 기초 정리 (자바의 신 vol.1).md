---
layout: post
title: 자바 기초 정리 (자바의 신 vol.1)
subtitle: 자바 기초 문법 정리
categories: CS
tags: [java]
---

## 1. 자바 변수와 자료형

### 1.1 변수의 종류

자바의 변수는 생명주기에 따라 4가지 종류로 나뉜다.

1. 지역 변수
    - 중괄호 내에서 선언된 변수
    - 생명주기도 해당 중괄호 내에서만 유효함
    - 자바에선 재선언이 허용되지 않으므로 해당 중괄호 내에서 동일한 이름을 갖는 지역 변수를 선언하면 컴파일 에러가 발생함

2. 매개 변수 
    - 메소드에 넘겨주는 변수
    - 메소드가 호출될 대 생명이 시작되어 메소드가 끝나면 소멸

3. 인스턴스 변수
    - 메소드 밖, 클래스 안에 선언된 변수
    - 객체가 생성될 때 생명이 시작되며, 그 객체를 참조하고 있는 다른 객체가 없으면 소멸됨

4. 클래스 변수
    - static 예약어가 붙은 인스턴스 변수
    - 클래스가 처음 로드될 때 생명이 시작되고, 자바 프로그램이 끝날 때 소멸됨
    - 클래스는 객체를 처음 생성하거나, 해당 클래스 변수에 접근하거나, 동적으로 로드하거나, 해당 클래스의 자식 클래스가 로드될 때 같이 로드됨

### 1.2 자료형의 종류

1. 기본 자료형
    - 바로 값을 넣어 초기화가 가능
    - 자료형의 첫 비트는 부호를 표시하는데 사용되며 음수의 범위가 양수의 범위보다 하나 더 큼. 부호비트가 1이고 나머지 비트가 0일 경우를 해당 타입의 최소값으로 사용하기 때문 (-2^n ~ -2^n-1)
    - 따라서 어떤 자료형에 최소값을 넣고 1을 빼면 최대값이, 최대값을 넣고 1을 더하면 최소값이 됨 (최소값이 10000000 이면 최대값은 01111111이기 때문)
    - 소수형 타입은 부동 소수점 연산을 사용하므로 값이 범위를 넘어서면 정확성이 보장되지 않음 -> 대신 java.match.BigDemical이라는 클래스를 사용
    - 자바의 모든 자료형은 값을 지정하지 않으면 기본값 사용. 기본 자료형은 각자의 기본값을 가지고 참조형은 null. 그러나 지역 변수일 경우는 기본값이 자동 적용되지 않음
    - 자바는 계산 시 두 피연산자가 정수형일 때 결과 값도 정수형으로 취급하므로 결과가 소수값이어도 소수형으로 결과가 나오진 않음. 소수점 아래까지의 결과를 원하면 두 피연산자를 소수형으로 할 필요가 있음
    - 종류
        - 정수형
            - byte  (-2^7 ~ 2^7-1)
            - short (-2^15 ~ 2^15-1)
            - int   (-2^31 ~ 2^31-1)
            - long  (-2^63 ~ 2^63-1)
                - long 자료형 초기화 시 L을 붙이지 않고 int 범위를 초과하는 값을 넣으면 에러 발생. 자바에서 기본적으로 숫자를 명시하면 int라고 생각하기 때문에 선언 시 L을 붙여주지 않으면 int로 인식됨
            - char
                - 정수형 중 유일하게 부호가 없음
                - 내부적으로 아스키/유니코드에 대응하는 숫자값을 저장하는 정수형 타입이지만 데이터 처리 방식에는 차이가 있음
                - 'a'와 같은 문자를 저장할 수 있으므로 char 같은 정수형인 다른 자료형들도 가능한 범위일 경우 해당 문자 저장 가능
                - 'a'같은 문자와 \u + 4자리의 16진수 값을 넣는 것이 대표적. 해당 값의 유니코드 번호를 지정해도 초기화 가능

        - 소수형
            - float
            - double
        - boolean

2. 참조 자료형
    - new 키워드를 사용해서 초기화 가능
    - String 만은 예외적으로 new을 사용하지 않고도 초기화 가능

## 2. 연산자와 형변환

### 2.1 연산자

- 연산자는 단항연산자   >   *, /, %   >   +, -   순으로 우선순위가 높다
- 단항연산자 중 ~(틸드)는 2진수로 되어 있는 비트 값을 전부 거꾸로 바꾸는 데 사용
- 등가 비교 연산자 (==, !=)는 같은 종류(정수형과 소수형도 같은 종류)끼리 비교가 가능하며 자바의 모든 기본 자료형과 참조 자료형에서 사용 가능. 참조 자료형은 주소값을 비교함
- 자바의 연산자들은 타입별로 사용 가능한 연산자가 정해져 있음. douable, float는 소수형이므로 비트 연산이 불가능함
- `&`, `|`, `^`(값이 서로 다르면 true, 같으면 false) 연산자는 숫자에 사용하면 비트 연산을, boolean 타입 사이에 사용하면 논리 연산을 수행
- 참조 자료형은 + 이항 연산자만 사용 가능. 사용 시 해당 클래스에 있는 toString() 메소드 결과끼리 더함


### 2.2 형변환

- 기본 자료형 중 boolean 타입은 숫자로 변환할 수 없기 때문에 형변환 불가능
- 더 범위가 넓은 타입으로 변환할 때는 문제가 없으나, 더 범위가 작은 타입으로 변환할 때는 소괄호 안에 타입을 명시해주어야 하며 예상치 못한 값이 나올수도 있음

## 3. 조건문과 반복문

### 3.1 조건문
- switch 문 
    - 한번 case 조건을 만족시켜 줬다면 그다음 break가 올때까지 모든 case 통과하여 실행문 실행
    - case문으로 이루어진 switch 문의 끝에는 default 문이 올 수 있으며 앞에 있는 조건에 맞지 않는 경우 실행됨. case문에서 한번이라도 걸렸으면 실행안됨

### 3.2 반복문
- do-while 문 : 한 번은 꼭 실행시키고 싶을 때 사용. 마지막 while의 소괄호 뒤에 반드시 세미콜론을 입력해야 함
- label : 반복문에 이름을 부여하여(라벨명 : 반복문 형태로 정의) 특정 시점에 해당 반복문을 빠져나오거나(break 라벨명) 위로 돌아가도록 (continue 라벨명)할 수 있음

## 4. 배열

### 4.1 배열의 선언과 기본값
- 배열 선언 시 대괄호는 타입과 변수 사이에 또는 변수명 뒤에 빈 상태로 위치해야함
- 참조 자료형이므로 new 키워드를 사용해 생성하거나, 중괄호를 사용해서 한번에 선언 및 초기화
- 지역변수는 원래 기본값이 없으나, 배열에서는 지역 변수라고 해도 배열 크기만 정해주면 초기화 안해도 각 배열의 기본값이 할당됨
- 기본 자료형 배열의 기본값은 각 자료형의 기본값과 동일
    ```
    byteArray[0]=0
    shortArray[0]=0
    intArray[0]=0
    longArray[0]=0
    floatArray[0]=0.0
    doubleArray[0]=0.0
    charArray[0]=[ ]    //기본값은 ₩u0000으로 화면에 출력될 때에는 한 칸의 공백으로 보임
    booleanArray[0]=false
    ```
- 모든 참조자료형은 초기화 하지 않으면 null값을 기본적으로 가짐
- 참고 : 초기화한 객체를 출력하면, 객체가 기본으로 가지는 toString() 메소드가 해당 객체의 클래스이름@메모리주소기반으로 생성된 16진수 해시코드를 반환하는 걸 확인할 수 있음
    - 배열의 경우 [L클래스이름;@해당 배열의 고유번호. L은 해당 배열이 배열이라는 것을, L은 참조 자료형임을 의미
    - boolean: Z, byte : b, char : C, double : D, float : F, int : I, long : J, short : S

### 4.2 2차원 배열
- 아래와 같이 선언 및 초기화
    ```
    int [] twoDim[]; 
    int twoDim[][];

    twoDim = new int[2][3];
    ```
- 크기를 지정할 경우에는 반드시 한번에 설정하던지 1차원만 설정해야 함
    ```
    twoDim = new int[2][3];
    twoDim = new int[2][];
    ```
- 2차원은 1차원 크기 설정 뒤에도 설정가능. 2차원 방 크기는 서로 다를 수 있음
    ```
    twoDim = new int[2][];
    twoDim[0] = new int[3];
    twoDim[1] = new int[2];
    ```
- 중괄호를 사용해서 한번에 선언 및 초기화 가능.
    {% raw %}
    ```
    int [][]twoDim = {{1, 2, 3}, {4, 5, 6}};
    ```
    {% endraw %}
    
- 2차원 배열에서 .length로 배열 크기를 확인할 때 1차원, 2차원 배열에 각각 .length를 붙여서 알아내야 하며, twoDim[0][0]는 배열 객체가 아닌 값이 들어있는 공간을 나타내기 때문에 실행 시 오류 발생
    - 점(.)은 참조 자료형에서만 찍을 수 있으며 기본 자료형에서는 사용 불가
    ```
    for(int i=0; i<twoDim.length; i++){
        for(int j=0; j <twoDim[i].length; j++){
            ...
        }
    }
    ```
- 다만 위와 같이 .length를 사용하여 for 루프가 수행될 때마다 길이를 얻어오는 건 성능상 좋지 않으므로 아래와 같이 사용
    ```
    int iLength = twoDim.length;
    for(int i = 0; i < iLength; i++){
        int jLength = twoDim[i].length;
        for(int j = 0; j < jLength; j++){
            ...
        }
    }
    ```

### 4.3 배열을 위한 for 루프
- 자바에서 제공되는 Collection이라는 자료구조를 처리할 때 for 루프를 보다 쉽게 사용 가능. JDK5부터 지원됨
    {% raw %}
    ```
    for(타입이름 임시 변수명 : 반복대상객체){

    }

    //사용 예시
    int [][]twoDim= {{1, 2, 3}, {4, 5, 6}};
    for(int[] dimArray : twoDim){
        for(int data : dimArray){
            System.out.println(data);
        }
    }
    ```
    {% endraw %}
-  반복대상객체로는 Collection의 일부 클래스 사용 가능. 단, 이 루프 사용시 배열의 현재 인덱스는 따로 계산해야 함

### 4.4 main 메소드의 배열 인자
- main 메소드의 배열 인자 String ars[]에 아래와 같이 값을 전달할 수 있음 (["a", "b", "c", "d"] 배열 전달)
    ```
    public class ArrayMain {
        public static void main(String args[]){
            ...
        }
    }
    ```

    ```
    $ javac ArrayMain.java
    $ java ArrayMain a b c d
    ```

## 5. 참조 자료형

### 5.1 this 예약어
- '이 객체'를 의미. 생성자와 메소드 안에서 사용 가능. 
- 객체의 변수와 매개 변수의 이름이 동일할 때 서로 구분하기 위해서 사용

### 5.2 메소드 overloading
- 자바에서는 타입이 다르면 다른 메소드로, 타입이 같고 변수 이름이 같으면 같은 메소드로 인식됨
- 메소드의 이름을 같게 하고, 매개 변수만을 다르게 하는것을 overloading이라고 함. 만약 이름, 매개변수가 같은데 리턴 타입이 다르면 컴파일러가 메소드 호출 시 어느 쪽을 호출해야 할지 알 수 없게 되기 때문에 컴파일 오류가 발생
- 리턴 타입은 overloading 기준은 아니므로 메소드명만 동일하고 매개변수, 리턴 타입이 달라도 overloading에 해당함
- 같은 역할을 하는 메소드는 (매개변수가 달라지더라도) 같은 메소드 이름을 가져야 한다는 모토로 사용하는 것

### 5.3 static 메소드
- 객체를 생성하지 않아도 호출 가능한 메소드. 단, 해당 메소드 안에서는 클래스(static) 변수만 사용 가능
    - 단지 static 메소드에서 사용하기 위해 변수를 static으로 선언하는것은 지양해야 함. 인스턴스 변수에 static을 붙이면 해당 클래스의 모든 인스턴스 객체에서 하나의 값을 바라보게 됨

### 5.4 static 블록
- 해당 클래스의 인스턴스 객체를 여러개 생성해야하지만, 한번만 호출되어야 하는 코드가 있을 경우 사용
- 선언 위치 상관없이 무조건 생성자보다 먼저 실행되며 메소드가 아닌 클래스 내에 선언되어야 함
- static 메소드와 마찬가지로 static 블록 안에서는 static한 것들만 호출 가능
- 생성자가 불리지 않아도 해당 클래스에 대한 참조가 발생하자마자 호출되므로 static 인스턴스 변수의 기본값을 덮어 씌움
    ```
    public class StaticBlock {
        static int data = 1;
        public StaticBlock(){
            ...
        }

        static {
            data = 3;
        }

        static {
            data = 5;
        }

        public static int getData(){
            return data;
        }
    }

    pulic void ddd() {
        // StaticBlock 클래스에 대한 참조 발생
        // data=5 출력됨
        System.out.println("data=" + StaticBlock.getData()); 
        StaticBlock block1 = new StaticBlock();
    }
    ```

### 5.5 Pass by Value, Pass by Reference
- 모든 기본 자료형은 Pass by Value, 참조 자료형은 값이 아닌 참조가 전달되는 Pass by Reference
- String b = "z"와 String b = new String("z")는 동일하게 new를 사용하여 객체를 생성한 것과 같기 때문에, 호출하는 함수에 인자로 String 변수를 전달해도 참조가 아닌 객체가 새로 생성(복사)되어 넘어간 것이 됨
    ```
    ...
    String a = "a";
    passByValue(b);
    public void passByValue(String b){
        b = "b";    // 여전히 a 변수의 값은 "a"로 유지됨
    }
    ```

### 5.6 매개변수를 임의의 개수만큼 전달하기
-  함수로 넘길 매개 변수의 수를 정하기 애매한 경우 아래와 같이 사용할 수 있으나 넘길 숫자들을 직접 배열로 만든 후 넘겨줘야 한다는 단점이 있음
    ```
    ...
    varargs.calculateNumbersWithArray(new int[]{1, 2, 3, 4, 5});
    public void calculateNumbersWithArray(int []numbers){
        ...
    }
    ```
- 아래와 같이 "타입...변수명"으로 선언해도 마찬가지로 numbers는 배열로 인식되며, 함수 호출 시 필요한만큼 매개변수를 바로 넘길 수 있어 편리함
    ```
    ...
    varargs.calculateNumbers(1, 2, 3, 4, 5);
    public void calculateNumbers(int...numbers){
        ...
    }
    ```
    - 해당 방식은 하나의 메소드에서 한 번만 사용 가능하고, 여러 매개 변수가 있다면 가장 마지막에 선언해야 함
        ```
        public void arbitrary(String message, int...numbers){   //해당 매개변수 마지막으로
            ...
        }
        ```   
    - System.out.printf() 메소드는 아래와 같이 정의되어 가장 앞에 출력하는 포맷을 선언하고, 뒤에는 Object라는 타입의 args를 임의의 개수만큼 받을 수 있음
        ```
        printf(String format, Object...args)   //format 문자열에 정의한 포맷 수만큼 args로 전달하여 출력할 수 있음
        ```

## 6. 패키지

### 6.1 패키지 선언 시 규칙
- 소스의 가장 첫 줄에 있어야 함
- 패키지 선언은 소스 하나에 하나만 있어야 함
- package 선언과 파일 시스템의 디렉토리 구조가 일치해야 컴파일 또는 실행 시 해당 소스 또는 클래스 파일을 찾을 수 있음
- 컴파일 시 javac 명령에 package 구조에 맞는 소스 파일 경로를 줘야 함. 따라서 패키지 루트 디렉토리(package com.example로 정의한 경우 com이 패키지 루트 디렉토리)의 디렉토리나 그 상위 디렉토리에선 컴파일 가능하지만 하위 디렉토리에선 안됨
    ```
    # Main.java에 package com.example로 선언 시

    cd src
    javac com/example/Main.java
    # 현재 디렉토리(src)가 패키지 루트
    # 클래스 파일도 com/example 밑에 Main.class로 생성됨

    # 또는
    javac -d out src/com/example/Main.java
    # 패키지 루트 디렉토리의 상위 디렉토리에서 컴파일하지만 package 구조에 맞는 소스 파일 경로를 포함함
    # -d out: out이 클래스파일 기준 패키지 루트. 사용 시 클래스 파일 기준 패키지 루트와 소스 파일 기준 패키지 루트가 달라짐. 소스 파일 경로와 클래스 파일 경로를 다르게 하고 싶을 때 사용
    # out 폴더 밑에 package 선언과 동일하게 디렉토리 구조 생성됨(com/example 폴더 생성)
    ```
- 클래스 파일 실행 시에는 -cp 옵션으로 클래스 파일 기준 패키지 루트 패키지 디렉토리 지정 가능
    ```
    java -cp out com.example.Main
    ```
- 패키지를 사용하는 클래스(별도의 package 선언을 한 클래스)를 실행할 때는 항상 패키지명.클래스명 전체를 포함해서 실행해야 함
- 패키지 이름은 모두 소문자로 지정해야 하며, 자바의 예약어를 포함할 수 없음

### 6.2 패키지 import
- 자바에서는 같은 패키지에 있는 클래스들과 java.lang 패키지에 있는 클래스들만 찾을 수 있음. 그외에는 import 패키지명.클래스명을 정의해줘야 함
- import로 불러온 클래스를 따로 컴파일하지 않았어도 해당 클래스를 사용하는 소스 파일을 컴파일하면 (그리고 import한 패키지명과 실제 해당 클래스의 소스 파일이 있는 디렉토리 경로가 일치하면) 해당 클래스를 먼저 컴파일한 후 호출하는 클래스를 컴파일 함
- 특정 패키지의 하위 패키지들을 모두 import하고자 할 경우 import c.javapackage.sub.*;사용
    - 단, 해당 패키지의 바로 하위 패키지만 import 하므로 import c.*를 한다고 해서 c.javapackage의 하위 패키지들까지 import 되진 않음
    - 폴더 구조상 상위 패키지에 있는 클래스와 하위 패키지에 있는 클래스의 상관관계는 자바 언어 상에는 없으며, 단지 논리적으로 어떤 패키지 하위에 있는지 여부를 따지기 위함임
- 클래스안에 static 메소드나 변수가 있을 경우 import static을 사용하여 해당 메소드나 변수를 직접 import 할 수 있음
    - import static을 사용안 할 경우 해당 클래스를 import하여 클래스명.static_메소드/변수 형태로 사용해야 함
    - import 클래스명.*로 해당 static 메소드/변수 import할 때도 마찬가지로 import static 사용
    - static 메소드/변수가 직접 import되므로 해당 메소드/변수를 import 한 클래스에 이름이 중복되는 메소드/변수가 있을 수 있는데, 이 경우 자신의 클래스에 있는 변수/메소드가 더 우선됨

### 6.3 자바의 접근 제어자
- public : 누구나 접근 가능
- protected : 같은 패키지 내에 있거나 상속받은 경우에만 접근 가능
- package-private : 아무런 접근 제어자를 적어주지 않은 경우. 같은 패키지 내에 있을 때만 접근 가능
- private : 해당 클래스 내에서만 접근 가능
- 구조상으론 public > protected > package-private > private

| 지시자            | 해당 클래스 안에서 | 같은 패키지에서 | 상속받은 클래스에서 | import한 클래스 또는 그외에서 |
|-------------------|--------------------|------------------|------------------|----------------------|
| public            | O                  | O                | O                | O                    |
| protected         | O                  | O                | O                | X                    |
| package-private   | O                  | O                | X                | X                    |
| private           | O                  | X                | X                | X                    |
- 유의점 : public으로 선언된 클래스가 소스 내에 있다면 그 소스 파일의 이름은 public과 동일해야 함
    - 소스 파일명과 일치하는 클래스가 있어야 하는 건 아님

## 6. 상속