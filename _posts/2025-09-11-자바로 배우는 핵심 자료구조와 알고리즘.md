---
layout: post
title: 자바로 배우는 핵심 자료구조와 알고리즘
subtitle: 자료구조/알고리즘 정리
categories: CS
tags: [java, 자료구조, 알고리즘]
---

## 1. 인터페이스 프로그래밍
- List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List로 동작하는 메서드는 ArrayList와 LinkedList 또는 List를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨
- 라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨

## 2. 시간 복잡도
- 전체 코드 구현 이전에 컴퓨터의 성능에 구애받지 않고 알고리즘의 소요 시간을 정량화하기 위해 시간 복잡도를 계산함
- 알고리즘을 이루는 더하기, 곱하기, 숫자 비교 등의 기본 연산을 식별하여 더함
- 입력 데이터에 대한 평균 성능을 분석하거나, 가능하지 않을 경우 최악의 시나리오를 분석
- 문제의 크기에 따라 더 효율적인 알고리즘이 달라질 수 있는데, 작은 문제보다 큰 문제에서 알고리즘의 차이가 더 심해지므로 큰 문제에 초점을 맞춤
- 시간/공간 복잡도를 표기하기 위해 가장 일반적으로 사용되는 빅오 표기법은 알고리즘 최악의 실행 시간을 표기. 입력값의 크기인 n을 기준으로 그 입력값의 크기에 따라 얼마나 알고리즘이 복잡해지는지를 알려줌
    - 실행 속도 O(1) < O(log N) < O(N) < O(N log N) < O(N^2) < O(2^N) 

## 3. ArrayList
- java.util.ArrayList 클래스는 List 인터페이스의 구현 클래스 중 하나. List 인터페이스 문서에 정의된 add, gets, rem, set, indexOf, equals 메소드 규칙을 참고하여 ArrayList 클래스와 유사한 MyArrayList 클래스를 작성하면 아래와 같음
    ```
    public class MyArrayList<T> implements List<T> {
	int size;
	private T[] array;

	@Override
	public boolean add(T element) {
		if (size >= array.length) {
            // 배열의 전체 크기보다 더 많은 값이 삽입되면 크기가 그 2배인 배열을 다시 생성, 기존값 복사
            // 자바에선 타입 파라미터(T)로 배열을 초기화할 수 없으므로 Object 배열 생성 후 형변환
            E[] bigger = (T[]) new Object[array.length * 2];
            System.arraycopy(array, 0, bigger, 0, array.length);
            array = bigger;
        }
        array[size] = element;
        size++;
        return true;
	}

	@Override
	public void add(int index, T element) {
		if (index < 0 || index > size) {
			throw new IndexOutOfBoundsException();
		}
		add(element);

		// shift the elements
		for (int i=size-1; i>index; i--) {
			array[i] = array[i-1];
		}
		// put the new one in the right place
		array[index] = element;
	}

	@Override
	public T get(int index) {
		if (index < 0 || index >= size) {
			throw new IndexOutOfBoundsException();
		}
		return array[index];
	}

    @Override
	public T set(int index, T element) {
		E old = get(index);
        array[index] = element;
        return old;
	}

	@Override
	public int indexOf(Object target) {
        for (int i = 0; i < size; i++) {
            if (equals(target, array[i])) return i;
        }
		return -1;
	}

	private boolean equals(Object target, Object element) {
		if (target == null) {
			return element == null;
		} else {
            //Object 객체의 equals 메소드를 호출하여 실제 객체에서 재정의한 equals 메소드가 호출됨 
			return target.equals(element);
		}
	}

	@Override
	public boolean remove(Object obj) {
		int index = indexOf(obj);
		if (index == -1) {
			return false;
		}
		remove(index);
		return true;
	}

	@Override
	public T remove(int index) {
		E element = get(index);
        for (int i=index; i < size-1; i++) {
            array[i] = array[i+1];
        }
        size--;
        return element;
	}

    ...

    ```
- get, set, indexOf, equals, remove 메소드의 시간 복잡도는 각각 상수, 상수, 선형, 상수, 선형임
- add(T element) 메소드의 시간 복잡도를 계산하기 위해 크기가 2인 배열에 n개 요소를 추가할 때의 평균 연산 횟수를 고려하면
    - 1~2번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장
    - 3번째 호출 : 기존의 2배 크기(=4)를 가진 배열을 생성하여 기존 요소 2개를 복사하고 요소 저장
    - 4번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장
    - 5번째 호출 : 기존의 2배 크기(=8)를 가진 배열을 생성하여 기존 요소 4개를 복사하고 요소 저장
    - 6~8번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장
    - 위의 패턴 반복
- 결과적으로 n번 추가하면 요소 총 n개를 저장하고 총 n-2개를 복사함. 따라서 총 연산 횟수는 2n-2이고, 평균 횟수는 n으로 나누어 2n-2/n이 됨
- n이 커질수록 두 번째 항인 2/n는 작아지므로 add(T element) 메소드는 상수 시간으로 간주됨
- 일련의 호출에서 평균 시간을 계산하는 알고리즘 분류 방법을 **분할 상환 분석**이라고 함. 핵심 개념은 배열의 크기를 조정할 때마다 배열의 길이가 2배로 늘어나 각 요소를 복사하는 횟수를 제한한다는 것. 매번 고정된 양을 더해서 크기를 늘리는 대신 곱하여 연산 횟수를 더 제한함
- 이어서 removeAll 메소드를 구현하면 아래와 같음
    ```
	@Override
	public boolean removeAll(Collection<?> collection) {
		boolean flag = true;
		for (Object obj: collection) {
			flag &= remove(obj);
		}
		return flag;
	}
    ```
- 반복문을 돌리면 선형인 remove 메소드를 호출하고 있지만 collection 크기가 n에 비례하지 않는다면 이차가 아님

## 4. LinkedList
- 연결 리스트에서 각 노드는 리스트의 다음 노드에 대한 참조를 포함. 연결 구조의 다른 예로는 트리와 그래프가 있음
- List 인터페이스를 상속받아 MyLinkedList를 직접 구현
    ```
    public class MyLinkedList<E> implements List<E> {

        private class Node {
            public E data;
            public Node next;

            public Node(E data) {
                this.data = data;
                this.next = null;
            }
        }

        private int size;            // 요소 더하거나 제거할 때마다 갱신
        private Node head;           // 리스트의 첫 번째 노드 참조. 빈 리스트이면 null

        public MyLinkedList() {
            head = null;
            size = 0;
        }

        @Override
        public boolean add(E element) {
            if (head == null) {
                head = new Node(element);
            } else {
                Node node = head;
                for ( ; node.next != null; node = node.next) {}
                node.next = new Node(element);
            }
            size++;
            return true;
        }

        @Override
        public void clear() {
            head = null;
            size = 0;
        }
    ```
- LinkedList는 ArrayList와 달리 리스트 자체가 파괴되지 않아도 요소를 제거하면 리스트 크기가 줄어들고 사용하지 않는 노드는 즉시 가비지 컬렉션이 될 수 있다는 장점이 있음
- add 메소드는 리스트의 끝까지 이동해야 하므로 선형
- clear 메소드로 LinkedList의 첫 번째 노드 참조를 제거할 경우에는 순차적으로 연결리스트의 각 노드들에 대한 참조가 사라지게 되어 가비지 컬렉션이 선형이 됨
    ```
        private boolean equals(Object target, Object element) {
            if (target == null) {
                return element == null;
            } else {
                return target.equals(element);  //Object를 오버라이드 한 target의 실제 equals 메소드 호출
            }
        }

        @Override
        public int indexOf(Object target) {
            Node node = head;
            for (int i=0; i < size; i++){
                if (equals(target, node.data)) {
                    return i;
                }
                node = node.next;
            }
            return -1;
        }

        private Node getNode(int index) {
            if (index < 0 || index >= size) {
                throw new IndexOutOfBoundsException();
            }
            Node node = head;
            for (int i=0; i<index; i++) {
                node = node.next;
            }
            return node;
        }

        @Override
        public E get(int index) {
            Node node = getNode(index);
            return node.data;
        }

        @Override
        public void add(int index, E element) {
            if (index == 0) {
                head = new Node(element, head);
            } else {
                Node node = getNode(index - 1);
                node.next = new Node(element, node.next);
            }
            size++;
        }

        @Override
        public E remove(int index) {
            E element = get(index);
            if (index == 0) {
                head = head.next;
            } else {
                Node node = getNode(index-1);
                node.next = node.next.next;
            }
            size--;
            return element;
        }
    ```
- indexOf는 선형, remove와 add(int index, E element)도 index가 0인 특별한 경우를 제외하고 getNode가 선형이므로 선형
- MyArrayList 클래스는 끝에 추가하고 끝에서 제거할 때와 get/set 메서드 연산에 이점이 있으며, MyLinkedList 클래스는 시작에 추가하고 시작에서 제거하는 연산에 이점이 있음. 다른 연산에서는 증가 차수가 같음
- ArrayList 끝에 새로운 요소를 추가하는 실행 시간 측정 테스트
    ```
    public static void profileArrayListAddEnd() {
		Timeable timeable = new Timeable() {
			List<String> list;

			// 초기 설정: ArrayList 사용
			public void setup(int n) {
				list = new ArrayList<String>();
			}

			public void timeMe(int n) {
				for (int i = 0; i < n; i++) {
					list.add("a string");
				}
			}
		};
		int startN = 4000;  // 몇 번 추가할지에 대한 n값
		int endMillis = 1000;   // timingLoop 테스트 실행시간
		runProfiler("ArrayList add first", timeable, startN, endMillis);
	}

    private static void runProfiler(String title, Timeable timeable, int startN, int endMillis) {
		Profiler profiler = new Profiler(title, timeable);
		XYSeries series = profiler.timingLoop(startN, endMillis);
		profiler.plotResults(series);
	}
    ```
- Profiler 클래스를 사용하기 위해 setup과 timeMe 메서드를 제공하는 Timeable 객체를 생성, 리스트 맨 앞에 n개의 요소를 추가하는 시간 측정 테스트 수행
- 테스트 결과 : endMillis 동안 루프를 돌며 2배식 증가된 startN, 해당 startN에서 10회 씩 timeMe를 수행한 총 소요 시간 출력
    ```
    4000, 3
    8000, 0
    16000, 1
    32000, 2
    64000, 3
    128000, 6
    256000, 18
    512000, 30
    1024000, 8
    2048000, 185
    4096000, 242
    8192000, 544
    16384000, 1325
    ```
- 테스트 수행 결과 그래프가 a + bn (직선)이 되는 것 확인 가능. a는 Y 절편, b는 기울기
- add 메소드가 선형일때는 전체시간이 이차가 되며, 실행시간은 a + bn + cn^2의 포물선 그래프가 됨
- 측정에 잡음이 많으면 그래프 차이를 확인하기 어려우므로 이차 이상은 log-log 스케일을 적용해 직선 그래프 간의 기울기의 차이 확인 가능. 기울기가 1에 가까우면 선형, 2에 가까우면 이차로 봐야함
- timeMe 메소드를 ArrayList 맨 앞에 새로운 요소를 추가하도록 수정하면 전체시간은 이차가 되며, log-log 스케일을 적용했을때 기울기가 2에 가까워짐

## 5. 이중 연결 리스트
- 