---
layout: post
title: 자바로 배우는 핵심 자료구조와 알고리즘
subtitle: 자료구조/알고리즘 정리
categories: CS
tags: [java, 자료구조, 알고리즘]
---

## 1. 인터페이스 프로그래밍
- List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List로 동작하는 메서드는 ArrayList와 LinkedList 또는 List를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨
- 라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨

## 2. 시간 복잡도
- 전체 코드 구현 이전에 컴퓨터의 성능에 구애받지 않고 알고리즘의 소요 시간을 정량화하기 위해 시간 복잡도를 계산함
- 알고리즘을 이루는 더하기, 곱하기, 숫자 비교 등의 기본 연산을 식별하여 더함
- 입력 데이터에 대한 평균 성능을 분석하거나, 가능하지 않을 경우 최악의 시나리오를 분석
- 문제의 크기에 따라 더 효율적인 알고리즘이 달라질 수 있는데, 작은 문제보다 큰 문제에서 알고리즘의 차이가 더 심해지므로 큰 문제에 초점을 맞춤
- 시간/공간 복잡도를 표기하기 위해 가장 일반적으로 사용되는 빅오 표기법은 알고리즘 최악의 실행 시간을 표기. 입력값의 크기인 n을 기준으로 그 입력값의 크기에 따라 얼마나 알고리즘이 복잡해지는지를 알려줌
    - 실행 속도 O(1) < O(log N) < O(N) < O(N log N) < O(N^2) < O(2^N) 

## 3. ArrayList
- java.util.ArrayList 클래스는 List 인터페이스의 구현 클래스 중 하나. List 인터페이스 문서에 정의된 add, gets, rem, set, indexOf, equals 메소드 규칙을 참고하여 ArrayList 클래스와 유사한 MyArrayList 클래스를 작성하면 아래와 같음
    ```
    public class MyArrayList<T> implements List<T> {
	int size;
	private T[] array;

	@Override
	public boolean add(T element) {
		if (size >= array.length) {
            // 배열의 전체 크기보다 더 많은 값이 삽입되면 크기가 그 2배인 배열을 다시 생성, 기존값 복사
            // 자바에선 타입 파라미터(T)로 배열을 초기화할 수 없으므로 Object 배열 생성 후 형변환
            E[] bigger = (T[]) new Object[array.length * 2];
            System.arraycopy(array, 0, bigger, 0, array.length);
            array = bigger;
        }
        array[size] = element;
        size++;
        return true;
	}

	@Override
	public void add(int index, T element) {
		if (index < 0 || index > size) {
			throw new IndexOutOfBoundsException();
		}
		add(element);

		// shift the elements
		for (int i=size-1; i>index; i--) {
			array[i] = array[i-1];
		}
		// put the new one in the right place
		array[index] = element;
	}

	@Override
	public T get(int index) {
		if (index < 0 || index >= size) {
			throw new IndexOutOfBoundsException();
		}
		return array[index];
	}

    @Override
	public T set(int index, T element) {
		E old = get(index);
        array[index] = element;
        return old;
	}

	@Override
	public int indexOf(Object target) {
        for (int i = 0; i < size; i++) {
            if (equals(target, array[i])) return i;
        }
		return -1;
	}

	private boolean equals(Object target, Object element) {
		if (target == null) {
			return element == null;
		} else {
            //Object 객체의 equals 메소드를 호출하여 실제 객체에서 재정의한 equals 메소드가 호출됨 
			return target.equals(element);
		}
	}

	@Override
	public boolean remove(Object obj) {
		int index = indexOf(obj);
		if (index == -1) {
			return false;
		}
		remove(index);
		return true;
	}

	@Override
	public T remove(int index) {
		E element = get(index);
        for (int i=index; i < size-1; i++) {
            array[i] = array[i+1];
        }
        size--;
        return element;
	}

    ...

    ```
- get, set, indexOf, equals, remove 메소드의 시간 복잡도는 각각 상수, 상수, 선형, 상수, 선형임
- add(T element) 메소드의 시간 복잡도를 계산하기 위해 크기가 2인 배열에 n개 요소를 추가할 때의 평균 연산 횟수를 고려하면
    - 1~2번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장
    - 3번째 호출 : 기존의 2배 크기(=4)를 가진 배열을 생성하여 기존 요소 2개를 복사하고 요소 저장
    - 4번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장
    - 5번째 호출 : 기존의 2배 크기(=8)를 가진 배열을 생성하여 기존 요소 4개를 복사하고 요소 저장
    - 6~8번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장
    - 위의 패턴 반복
- 결과적으로 n번 추가하면 요소 총 n개를 저장하고 총 n-2개를 복사함. 따라서 총 연산 횟수는 2n-2이고, 평균 횟수는 n으로 나누어 2n-2/n이 됨
- n이 커질수록 두 번째 항인 2/n는 작아지므로 add(T element) 메소드는 상수 시간으로 간주됨
- 일련의 호출에서 평균 시간을 계산하는 알고리즘 분류 방법을 **분할 상환 분석**이라고 함. 핵심 개념은 배열의 크기를 조정할 때마다 배열의 길이가 2배로 늘어나 각 요소를 복사하는 횟수를 제한한다는 것. 매번 고정된 양을 더해서 크기를 늘리는 대신 곱하여 연산 횟수를 더 제한함
- 이어서 removeAll 메소드를 구현하면 아래와 같음
    ```
	@Override
	public boolean removeAll(Collection<?> collection) {
		boolean flag = true;
		for (Object obj: collection) {
			flag &= remove(obj);
		}
		return flag;
	}
    ```
- 반복문을 돌리면 선형인 remove 메소드를 호출하고 있지만 collection 크기가 n에 비례하지 않는다면 이차가 아님

## 4. LinkedList
- 연결 리스트에서 각 노드는 리스트의 다음 노드에 대한 참조를 포함. 연결 구조의 다른 예로는 트리와 그래프가 있음
- List 인터페이스를 상속받아 MyLinkedList를 직접 구현
    ```
    public class MyLinkedList<E> implements List<E> {

        private class Node {
            public E data;
            public Node next;

            public Node(E data) {
                this.data = data;
                this.next = null;
            }
        }

        private int size;            // 요소 더하거나 제거할 때마다 갱신
        private Node head;           // 리스트의 첫 번째 노드 참조. 빈 리스트이면 null

        public MyLinkedList() {
            head = null;
            size = 0;
        }

        @Override
        public boolean add(E element) {
            if (head == null) {
                head = new Node(element);
            } else {
                Node node = head;
                for ( ; node.next != null; node = node.next) {}
                node.next = new Node(element);
            }
            size++;
            return true;
        }

        @Override
        public void clear() {
            head = null;
            size = 0;
        }
    ```
- LinkedList는 ArrayList와 달리 리스트 자체가 파괴되지 않아도 요소를 제거하면 리스트 크기가 줄어들고 사용하지 않는 노드는 즉시 가비지 컬렉션이 될 수 있다는 장점이 있음
- add 메소드는 리스트의 끝까지 이동해야 하므로 선형 증가차수를 가짐
- clear 메소드로 LinkedList의 첫 번째 노드 참조를 제거할 경우에는 순차적으로 연결리스트의 각 노드들에 대한 참조가 사라지게 되어 가비지 컬렉션이 선형이 됨
    ```
        private boolean equals(Object target, Object element) {
            if (target == null) {
                return element == null;
            } else {
                return target.equals(element);  //Object를 오버라이드 한 target의 실제 equals 메소드 호출
            }
        }

        @Override
        public int indexOf(Object target) {
            Node node = head;
            for (int i=0; i < size; i++){
                if (equals(target, node.data)) {
                    return i;
                }
                node = node.next;
            }
            return -1;
        }

        private Node getNode(int index) {
            if (index < 0 || index >= size) {
                throw new IndexOutOfBoundsException();
            }
            Node node = head;
            for (int i=0; i<index; i++) {
                node = node.next;
            }
            return node;
        }

        @Override
        public E get(int index) {
            Node node = getNode(index);
            return node.data;
        }

        @Override
        public void add(int index, E element) {
            if (index == 0) {
                head = new Node(element, head);
            } else {
                Node node = getNode(index - 1);
                node.next = new Node(element, node.next);
            }
            size++;
        }

        @Override
        public E remove(int index) {
            E element = get(index);
            if (index == 0) {
                head = head.next;
            } else {
                Node node = getNode(index-1);
                node.next = node.next.next;
            }
            size--;
            return element;
        }
    ```
- indexOf는 선형, remove와 add(int index, E element)도 index가 0인 특별한 경우를 제외하고 getNode가 선형이므로 선형
- MyArrayList 클래스는 끝에 추가하고 끝에서 제거할 때와 get/set 메서드 연산에 이점이 있으며, MyLinkedList 클래스는 시작에 추가하고 시작에서 제거하는 연산에 이점이 있음. 다른 연산에서는 증가 차수가 같음
- ArrayList 끝에 새로운 요소를 추가하는 실행 시간 측정 테스트
    ```
    public static void profileArrayListAddEnd() {
		Timeable timeable = new Timeable() {
			List<String> list;

			// 초기 설정: ArrayList 사용
			public void setup(int n) {
				list = new ArrayList<String>();
			}

			public void timeMe(int n) {
				for (int i = 0; i < n; i++) {
					list.add("a string");
				}
			}
		};
		int startN = 4000;  // 몇 번 추가할지에 대한 n값
		int endMillis = 1000;   // timingLoop 테스트 실행시간
		runProfiler("ArrayList add first", timeable, startN, endMillis);
	}

    private static void runProfiler(String title, Timeable timeable, int startN, int endMillis) {
		Profiler profiler = new Profiler(title, timeable);
		XYSeries series = profiler.timingLoop(startN, endMillis);
		profiler.plotResults(series);
	}
    ```
- Profiler 클래스를 사용하기 위해 setup과 timeMe 메서드를 제공하는 Timeable 객체를 생성(Timeable 클래스는 교재의 별도 코드 참고), 리스트 맨 앞에 n개의 요소를 추가하는 시간 측정 테스트 수행
- 테스트 결과 : endMillis 동안 루프를 돌며 2배식 증가된 startN, 해당 startN에서 10회 씩 timeMe를 수행한 총 소요 시간 출력
    ```
    4000, 3
    8000, 0
    16000, 1
    32000, 2
    64000, 3
    128000, 6
    256000, 18
    512000, 30
    1024000, 8
    2048000, 185
    4096000, 242
    8192000, 544
    16384000, 1325
    ```
- 테스트 수행 결과 그래프가 a + bn (직선)이 되는 것 확인 가능. a는 Y 절편, b는 기울기
- add 메소드가 선형일때는 전체시간이 이차가 되며, 실행시간은 a + bn + cn^2의 포물선 그래프가 됨
- 측정에 잡음이 많으면 그래프 차이를 확인하기 어려우므로 이차 이상은 log-log 스케일을 적용해 직선 그래프 간의 기울기의 차이 확인 가능. 기울기가 1에 가까우면 선형, 2에 가까우면 이차로 봐야함
- plotResults 메소드는 log-log 스케일을 적용하여 계산한 기울기를 출력하기 위해 estimateSlope 메소드 실행
- timeMe 메소드를 ArrayList 맨 앞에 n개의 새로운 요소를 추가하도록 수정하면 전체시간은 이차가 되며, log-log 스케일을 적용했을때 기울기가 2에 가까워짐
- MyLinkedList 클래스를 이용하여 시작과 끝에 n개의 새로운 요소를 추가하도록 수정하면 둘다 1에 가까운 기울기가 출력됨

## 5. 이중 연결 리스트
- 앞서 구현한 단일 연결 리스트인 MyLinkedList와 달리 java.util.LinkedList 클래스는 이중 연결 리스트로 아래와 같은 특징이 있음
    - 각 노드는 다음 노드와 이전 노드의 참조를 포함
    - LinkedList 객체는 첫번째와 마지막 요소에 대한 참조를 포함
- ArrayList, 단일 연결 리스트, 이중 연결 리스트 성능 비교
![예외 클래스 상관 관계도](/assets/images/리스트_성능_비교.png)
- ArrayList 클래스는 get/set 메서드에서 유일하게 연결 리스트보다 나은 성능을 보임
- 반대로 실행시간이 시작이나 끝 근처에 요소를 추가하거나 제거하는 연산에 의존한다면 LinkedList 클래스가 좋음
- 단, 이러한 연산이 프로그램의 실행시간에 뚜렷한 영향을 미치지 않는다면 List 구현에 대한 선택은 큰 의미가 없음
- 또한 리스트가 충분히 크지 않으면 위의 성능표에 있는 성능차이는 해당되지 않으며 공간면에서는 ArrayList가 참조가 차지하는 공간이 적어 연결리스트보다 효율이 높음

## 6. 트리 순회

### 6.1 웹 크롤러 구현을 위한 DFS 트리 순회
- 웹 크롤러가 HTML 페이지를 다운로드하고 파싱해 본문과 링크를 추출하도록 하기 위해 jsoup 라이브러리를 사용하여 노드 기반 연결 자료구조인 DOM 트리로 표현
- DOM 트리는 DFS(깊이 우선 탐색)이 적합함 
    ```
    public class WikiNodeExample {
        public static void main(String[] args) throws IOException {
            String url = "https://en.wikipedia.org/wiki/Java_(programming_language)";
            
            //String 타입의 URL을 인자로 받아 웹 서버에 접속
            Connection conn = Jsoup.connect(url);
            //get 메소드는 HTML 을 다운로드하여 파싱하고 DOM 트리를 나타내는 Document 객체를 반환
            Document doc = conn.get();
            
            Element content = doc.getElementById("mw-content-text");
            Elements paras = content.select("p");
            Element firstPara = paras.get(0);
		
            //재귀적 방법을 사용한 DOM 트리 깊이 우선 탐색
            recursiveDFS(firstPara);
            System.out.println();

            //반복적 방법을 사용한 DOM 트리 깊이 우선 탐색
            iterativeDFS(firstPara);
            System.out.println();
        }
    }
    ```

### 6.2 DFS로 트리를 순회하는 2가지 방법

#### 6.2.1 재귀적 방법을 사용한 트리 순회
- 자식 노드를 탐색하기에 앞서 각 TextNode의 내용을 출력하는 전위 순회 방식
    ```
    private static void recursiveDFS(Node node) {
		if (node instanceof TextNode) {
			System.out.print(node);
		}
		for (Node child: node.childNodes()) {
			recursiveDFS(child);
		}
	}
    ```

#### 6.2.2 반복적 방법을 사용한 트리 순회 : 스택 사용
- 스택은 push, pop, peek, isEmpty 등 List의 일부 기능만 제공하지만 단순하여 코드 가독성을 높이고 오류 발생 가능성을 줄임. 또한 작은 API는 효율적으로 구현하기가 더 쉬움
- 자바로 스택 구현 시 기존 ArrayList나 LinkedList 클래스를 사용하면 잘못된 위치에 추가하거나 잘못된 순서로 제거하는 실수가 발생할 수 있고, 자바의 Stack 클래스는 오래된 버전이라 최근 JCF와 일치하지 않으므로 ArrayDeque같은 Deque 인터페이스를 구현한 클래스를 사용하는 편이 좋음
- Deque는 양쪽에 끝이 있는 큐로, 자바에서 Deque 인터페이스는 push 와 pop, peek, isEmpty 메서드를 제공하므로 Deque를 스택으로 사용할 수 있음
    ```
    private static void iterativeDFS(Node root) {
		Deque<Node> stack = new ArrayDeque<Node>();
		stack.push(root);

		while (!stack.isEmpty()) {

			Node node = stack.pop();
			if (node instanceof TextNode) {
				System.out.print(node);
			}

			// 후입선출이므로 역순으로 삽입
			List<Node> nodes = new ArrayList<Node>(node.childNodes());
			Collections.reverse(nodes);
			
			for (Node child: nodes) {
				stack.push(child);
			}
		}
	}
    ```
- LinkedList는 List와 Deque 인터페이스를 둘 다 구현함. 어느 인터페이스를 사용하느냐에 따라 활용 방법이 달라짐
- 반복적 DFS가 재귀적 DFS보다 Iterator 인터페이스(hasNext(), next())로 래핑하기가 용이해 외부에서 순회 제어하기가 더 쉬움
- 웹 크롤러를 이용한 철학으로 가는 길 예제 (코드는 교재 확인)
    - ArrayDeque 스택을 가지고 DOM 트리를 탐색하는 Iterable 구현 클래스 WikiNodeIterable
    - jsoup 라이브러리를 활용하여 위키피디아 페이지를 다운로드하는 WikiFetcher 클래스
    - WikiNodeIterable을 사용해 페이지의 첫 번째 유효링크를 파싱하는 WikiParser 클래스 
    - WikiParser와 WikiFetcher을 사용하여 주어진 위키피디아 페이지에서 시작해 첫 번째 링크를 따라가며 목표 페이지에 도달하거나 
 제한 횟수·사이클·막다른 길에 걸릴 때까지 탐색하는 WikiPhilosophy 클래스

## 7. Map

### 7.1 인덱서 구현을 위한 Map, Set
- 인덱서는 검색어를 바탕으로 관련 페이지를 찾을 수 있게 하는 자료구조. 검색어가 각 페이지에 몇 번씩 등장하는지를 기록해 가장 관련성이 높은 페이지 식별
- List<Page> 같은 페이지의 컬렉션 형태보다는 키에 해당하는 값을 빠르게 찾을 수 있는 Map이 더 적절함
- 검색어에 등장 횟수를 매핑하는 Termcounter 클래스와 함께 검색어와 검색어가 등장하는 페이지의 컬렉션을 매핑하는 Index 라는 클래스를 정의
- 검색어별로 등장하는 페이지를 모아두면, 여러 검색어를 동시에 찾을 때는 교집합 연산으로 공통 페이지를 구해야 함.
Set은 중복 없는 집합 구조라 페이지 별로 유일하며 교집합 같은 연산을 효율적으로 구현할 수 있는 메소드를 제공하므로 페이지 별 데이터를 저장하는데 적합함
- Index 클래스는 단어 문자열을 key, TermCounter 객체들의 Set을 value로 가지는 Map을 보유하여 특정 검색어에 대한 페이지별 등장횟수(TermCounter)를 제공
    ```
    public class Index {
        private Map<String, Set<TermCounter>> index = new HashMap<String, Set<TermCounter>>();
        ...
    }
    ```
    ```
    public class TermCounter {

        private Map<String, Integer> map; //해당 페이지에서 해당 단어가 등장하는 횟수 매핑
        private String label; //페이지의 url

        public TermCounter(String label) {
            this.label = label;
            this.map = new HashMap<String, Integer>();
        }
        ...
    }
    ```
- TermCounter는 jsoup 라이브러리의 Element 객체 컬렉션인 Elements 객체를 쪼개 단어별 등장 횟수를 카운트하는 
processElement, processTree, processText 메소드 제공. processTree는 Element 객체의 DOM 트리를 
탐색하기위해 앞서 정의한 WikiNodeIterable 클래스를 사용함
- 자바는 Map 인터페이스의 구현으로 HashMap, TreeMap 클래스, Set 인터페이스의 구현으로 HashSet과 TreeSet 클래스 제공


### 7.2 Map 인터페이스 구현
- java.util.Map 인터페이스 문서의 메소드 정의를 참고하여 해당 인터페이스를 구현한 MyLinearMap 클래스 작성
    ```
    public class MyLinearMap<K, V> implements Map<K, V> {

        private List<Entry> entries = new ArrayList<Entry>();

        public class Entry implements Map.Entry<K, V> {
            private K key;
            private V value;

            public Entry(K key, V value) {
                this.key = key;
                this.value = value;
            }
        }

        private Entry findEntry(Object target) {
            for (Entry entry: entries) {
                if (equals(target, entry.getKey())) {
                    return entry;
                }
            }
            return null;
        }

        private boolean equals(Object target, Object obj) {
            if (target == null) {
                return obj == null;
            }
            return target.equals(obj);
        }

        @Override
        public V get(Object key) {
            Entry entry = findEntry(key);
            if (entry == null) return null;
            return entry.getValue();
        }

        @Override
        public V put(K key, V value) {
            Entry entry = findEntry (key)
            if (entry == null){
                entries.add(new Entry(key, value));
            } else {
                V oldValue = entry.getValue();
                entry.setValue(value);
                return oldValue;
        }

        @Override
        public V remove(Object key) {
            Entry entry = findEntry(key);
            if (entry == null) {
                return null;
            } else {
                V value = entry.getValue();
                entries.remove(entry);
                return value;
            }
        }

        @Override
        public void clear() {
            entries.clear();
        }
        ...
    }
    ```
- Entry 클래스는 단지 키와 값의 컨테이너로 이 정의는 MyLinearMap 클래스에 중첩되어 있으므로 같은 타입 파라미터인 K와 V를 사용
- equals는 상수시간, findEntry가 선형이므로 put과 get도 선형, remove는 ArrayList 시작이나 중간에서 삭제할경우 요소를 이동해야하지만 2번의 선형 연산이므로 마찬가지로 선형
- 해시코드를 사용하면 Map의 증가차수를 더 개선할 수 있음

### 7.3 HashMap
- Entry 대신 MyLinearMap(Entry List)의 List 컬랙션 사용
- 키를 확인하여 어느 내장 Map에 투입할지 결정하기 위해 해시 함수 chooseMap 사용. 이 함수는 0bject 객체를 인자로
받아 해시 코드라는 정수를 반환하는데, 중요한 점은 같은 0bject 객체에 대해서는 항상 같은 해시 코드를 반환해야 함 
- 자바에서 모든 0bject 객체는 hashCode 라는 메소드를 제공하여 해시 함수를 계산하며, 메서드의 구현은 객체의 종류에 따라 달라짐
- 하나의 Map이 여러 MyLinearMap으로 쪼개지는 만큼 탐색해야 하는 각 맵의 엔트리 개수는 더 줄어드므로 FindEntry 메서드와 그것을 호출하는 메서드의 속도가 더 빨라짐
    ```
    public class MyBetterMap<K, V> implements Map<K, V> {

        protected List<MyLinearMap<K, V>> maps;

        public MyBetterMap() {
            makeMaps(2);
        }

        protected void makeMaps(int k) {
            maps = new ArrayList<MyLinearMap<K, V>>(k);
            for (int i=0; i<k; i++) {
                maps.add(new MyLinearMap<K, V>());
            }
        }

        protected MyLinearMap<K, V> chooseMap(Object key) {
            //ath.abs 메서드를 호출하여 절대값을 만들고 %를 사용하여 결과가 0 에서 map.size()-1 사이에 있음을 보장
            int index = key==null ? 0 : Math.abs(key.hashCode()) % maps.size();
            return maps.get(index);
        }

        @Override
        public V get(Object key) {
            MyLinearMap<K, V> map = chooseMap(key);
            return map.get(key);
        }

        @Override
        public V put(K key, V value) {
            MyLinearMap<K, V> map = chooseMap(key);
            return map.put(key, value);
        }

        @Override
        public int size() {
            // add up the sizes of the sub-maps
            int total = 0;
            for (MyLinearMap<K, V> map: maps) {
                total += map.size();
            }
            return total;
        }

        @Override
        public void clear() {
            // clear the sub-maps
            for (int i=0; i<maps.size(); i++) {
                maps.get(i).clear();
            }
        }
        ...
    }
    ```
- 탐색해야 할 Map 당 Entry가 n/k개로 줄어들지만 chooseMap을 호출하는 get, put 메소드의 성능은 여전히 n에 비례함
- 하지만 n과 함께 k를 늘려간다면 n/k의 크기를 제한할 수 있음. 3. ArrayList의 분할상환방식에서 확인한 것처럼 매번 n이 k를 초과할 때 k를 두 배로 늘린다면 put을 상수시간으로 줄일 수 있음. 또한 하위 맵당 엔트리의 개수가 일정하면 단일 하위 맵은 상수 시간으로 검색할 수 있음
- MyBetterMap에서 각 맵의 크기는 ArrayList에 의존하여 자동으로 증가하므로 FACTOR 값만큼 맵 당 최대 엔트리 개수를 제한하고 요소가 새로 추가되면 내장 Map을 새로 생성
- 앞서 정의한 MyBetterMap을 상속받아 HashMap 정의
    ```
    public class MyHashMap<K, V> extends MyBetterMap<K, V> implements Map<K, V> {

        protected static final double FACTOR = 1.0; //하위 맵당 최대 엔트리 개수

        @Override
        public V put(K key, V value) {
            V oldValue = super.put(key, value);

            //size() : 엔트리의 전체 개수인 n
            //maps.size() : 내장된 map의 개수인 k
            if (size() > maps.size() * FACTOR) {
                rehash();
            }
            return oldValue;
        }
    }
    ```
- put 메소드만 새로 재정의하여 MyBetterMap의 put 메소드를 호출하고 재해시가 필요한지 확인
- n 〉 k * FACTOR면 하위 맵당 엔트리의 개수가 임계치를 초과함을 의미하므로 rehash 메서드를 호출. rehash 메서드가 호출될 때마다 내장된 맵의 개수 k는 두 배가 됨
- 맵 당 엔트리 개수가 제한됨으로서 get, containsKey, remove 메소드는 자동으로 상수시간이 됨
- 그러나 size 메소드가 여전히 선형이므로 대신 size 인스턴스 변수를 추가하여 put, remove 메소드에서 관리 
    ```
    ...
    private int size = 0;

    @Override
    public V remove(Object key) {
        MyLinearMap<K, V> map = chooseMap(key);
        size -= map.size();
        V oldValue = map.remove(key);
        size += map.size();
        return oldValue;
    }

    @Override
    public V put(K key, V value) {
        MyLinearMap<K, V› map = chooseMap(key);
        size -= map.size();
        V oldValue = map.put(key, value);
        size += map.size();
        if (size() 〉 maps.size() * FACTOR) {
            size = 0;
            rehash();
        }
        return oldValue;
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public void clear() {
        super.clear();
        size = 0;
    }
    ...
    ```
- size 메소드가 상수시간이 되어 put 메소드도 자동으로 상수시간이 됨
- MyBetterMap에서 clear 메소드는 오히려 선형이 되었지만 자주 사용되지 않는 함수라 감안할 만함
- 많은 객체가 동일한 해시 코드를 갖는다면 결국 같은 하위 맵으로 몰리게 되고, k개의 하위 맵으로 인한 성능 향상은 k보다 줄어들게 됨. 따라서  해시 함수는 해시코드를 균등하게 분배해야 함
- 해싱을 사용하는 자료구조에서 가변 객체를 키로 사용하는 것은 위험함. 키가 맵에 있는 동안 키 값이 변경되면 해당 값을 찾지 못하게 됨
- equals()가 true인 객체들은 반드시 hashCode() 결과값이 동일해야 해시 기반 컬렉션에서 올바르게 동작함

### 7.4 TreeMap
- HashMap은 널리 사용되지만 상수시간이라도 상수가 상당히 커지거나, 하위 맵에 고르게 키를 분배하는 좋은 해시 함수를 설계하는게 어렵거나, 저장되는 데이터에 순서가 없다는 문제점이 있음
- TreeMap은 해싱을 사용하지 않으며 이진 탐색 트리에 키를 저장하므로 키를 선형 시간으로 순서대로 조회할 수 있음. 또한 핵심 메소드의 실행시간이 log n에 비례하여 쓸만함
- 이진 탐색 트리는 아래와 같은 속성이 있음
    - 노드 왼쪽에 자식이 있다면 왼쪽 하위 트리의 모든 키는 노드에 있는 키보다 작음
    - 노드 오른쪽에 자식이 있다면 오른쪽 하위 트리의 모든 키는 노드에 있는 키보다 큼
    - 따라서 검색할 때 트리 전체를 탐색할 필요 없이 트리의 각 수준에서 한개의 자식노드만 찾으면 됨. 이는 트리의 높이인 log n에 비례함
        - 이진 트리의 높이 별 총 노드 개수는 n = 2^h - 1이므로, log를 씌우면 log n ≈ h
    - 위의 조건을 만족할 뿐 기본적으로는 균형있는 이진트리를 보장하진 않음 
- 이진 탐색 트리로 Map 인터페이스를 구현하면 아래와 같음
    ```
    public class MyTreeMap<K, V> implements Map<K, V> {

        private int size = 0;
        private Node root = null;

        protected class Node {
            public K key;
            public V value;
            public Node left = null;
            public Node right = null;

            public Node(K key, V value) {
                this.key = key;
                this.value = value;
            }
        }

        @Override
        public void clear() {
            size = 0;
            root = null;
        }

        @Override
        public boolean containsKey(Object target) {
            return findNode(target) != null;
        }

        private Node findNode(Object target) {
            if (target == null) {
                throw new IllegalArgumentException();
            }

            // key와 비교하기 위해 Object -> Key 타입으로 형변환
            // Map 인터페이스 규약에 따르면 containsKey의 파라미터 타입은 Object
            @SuppressWarnings("unchecked")
            Comparable<? super K> k = (Comparable<? super K>) target;

            Node node = root;
            while (node != null)
            {
                int cmp = k.compareTo(node.key);
                if (cmp < 0)
                    node = node.left;
                else if (cmp > 0)
                    node = node.right;
                else
                    return node;
            }
            return null;
        }

        private boolean equals(Object target, Object obj) {
            if (target == null) {
                return obj == null;
            }
            return target.equals(obj);
        }

        @Override
        public boolean containsValue(Object target) {
            return containsValueHelper(root, target);
        }

        private boolean containsValueHelper(Node node, Object target) {
            if (node == null) {
                return false;
            }
            if (equals(target, node.value)) {
                return true;
            }
            if (containsValueHelper(node.left, target)) {
                return true;
            }
            if (containsValueHelper(node.right, target)) {
                return true;
            }
            return false;
        }

        @Override
        public Set<Map.Entry<K, V>> entrySet() {
            throw new UnsupportedOperationException();
        }

        @Override
        public V get(Object key) {
            Node node = findNode(key);
            if (node == null) {
                return null;
            }
            return node.value;
        }

        @Override
        public Set<K> keySet() {
            Set<K> set = new LinkedHashSet<K>();
            addInOrder(root, set);
            return set;
        }

        private void addInOrder (Node node, Set<K> set) {
            if(node == null) return;
            addInOrder(node.left, set);
            set.add(node.key);
            addInOrder(node.right, set);
        }

        @Override
        public V put(K key, V value) {
            if (key == null) {
                throw new NullPointerException();
            }
            if (root == null) {
                root = new Node(key, value);
                size++;
                return null;
            }
            return putHelper(root, key, value);
        }

        private V putHelper(Node node, K key, V value) {
            Comparable<? super K> k = (Comparable<? super K>) key;
            int cmp = k.compareTo(node.key);

            //리프 노드를 찾아서 키를 비교하여 크기에 따라 오른쪽/왼쪽 자식 노드로 추가
            if (cmp < 0) {
                if (node.left == null) {
                    node.left = new Node(key, value);
                    size++;
                    return null;
                }
                else {
                    return putHelper(node.left, key, value);
                }
            }
            if (cmp > 0) {
                if (node.right == null) {
                    node.right = new Node(key, value);
                    size++;
                    return null;
                }
                else {
                    return putHelper(node.right, key, value);
                }
            }
            V oldValue = node.value;
            node.value = value;
            return oldValue;
        }

        @Override
        public void putAll(Map<? extends K, ? extends V> map) {
            for (Map.Entry<? extends K, ? extends V> entry: map.entrySet()) {
                put(entry.getKey(), entry.getValue());
            }
        }

        @Override
        public V remove(Object key) {
            if (root == null) throw new UnsupportedOperationException();

            Node deletedNode = new Node(null, null);
            root = removeHelper(root, (Comparable<? super K>) key, deletedNode);
            if (deletedNode.value != null) size--;
            
            return deletedNode.value;
        }

        public Node removeHelper(Node node, Comparable<? super K> key, Node deletedNode) {
            int cmp = key.compareTo(node.key);

            if (cmp < 0) {
                node.left = removeHelper(node.left, key, deletedNode);
            } else if (cmp > 0) {
                node.right = removeHelper(node.right, key, deletedNode);
            } else {
                // 삭제할 노드 찾음
                if(deletedNode != null) deletedNode.value = node.value;

                // (1) 리프 노드
                if (node.left == null && node.right == null) return null;

                // (2) 자식 하나
                if (node.left == null) return node.right;
                if (node.right == null) return node.left;

                // (3) 자식 둘
                Node successor = findMin(node.right);  // 오른쪽 서브트리에서 가장 작은 값
                node.key = successor.key;
                node.value = successor.value;
                node.right = removeHelper(node.right, (Comparable<? super K>) successor.key, null);
            }
            return node;
        }
        ...
    }
    ```
- clear는 root가 null이 될 시 자식 노드들을 수거하므로 선형시간임을 고려해야함
- findNode, put, remove는 key를 사용하기 때문에 트리의 높이에 비례하나 containsValue, keySet은 트리 전체를 검색하므로 n에 비례함
- 트리의 모든 노드를 방문하는 방식으로 전위/중위/후위 순회가 있는데 containsValueHelper는 순서 상관없이 value를 확인하므로 전위 순회, addInorder는 오름차순으로 key 값을 정렬해야 하므로 중위 순회를 함
- 위 코드에서 put 메소드를 확인해보면 순차적으로 증가하는 값들을 put 할 경우 오른쪽 자식에만 쏠린 불균형 트리가 됨
- 불균형 트리를 해결하기 위해서는 Map에 키를 순서대로 넣지 않거나, put을 수정하여 트리가 불균형해질 때 노드를 재배열하는 로직을 추가해야 함(=자가 균형 트리)
- 일반적인 자가 균형 트리로는 AVL 트리, 레드 블랙 트리가 있음
- java.util.TreeMap은 내부적으로 레드 블랙 트리로 구현되어 있어 순차적인 데이터가 삽입되어도 균형을 유지함
- remove 메소드는 삭제할 노드가 리프 노드인지, 자식 하나인지, 둘인지에 따라 다르게 동작함. 삭제할 노드의 자식이 둘일 경우 왼쪽 서브트리에서 가장 큰 값 또는 오른쪽 서브트리에서 가장 작은 값을 찾아 대체해야 함. 이는 트리의 균형을 다시 맞추는 것과 유사한 연산을 거침

