<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>자바로 배우는 핵심 자료구조와 알고리즘 | Toyo.log</title>
<meta name="generator" content="Jekyll v4.4.1">
<meta property="og:title" content="자바로 배우는 핵심 자료구조와 알고리즘">
<meta name="author" content="Toyo">
<meta property="og:locale" content="en_US">
<meta name="description" content="1. 인터페이스 프로그래밍 java.util.List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List 인터페이스에 정의된 메소드는 ArrayList와 LinkedList 또는 List 인터페이스를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨 라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨">
<meta property="og:description" content="1. 인터페이스 프로그래밍 java.util.List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List 인터페이스에 정의된 메소드는 ArrayList와 LinkedList 또는 List 인터페이스를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨 라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨">
<link rel="canonical" href="/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html">
<meta property="og:url" content="/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html">
<meta property="og:site_name" content="Toyo.log">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2025-09-11T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="자바로 배우는 핵심 자료구조와 알고리즘">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Toyo"},"dateModified":"2025-09-11T00:00:00+00:00","datePublished":"2025-09-11T00:00:00+00:00","description":"1. 인터페이스 프로그래밍 java.util.List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List 인터페이스에 정의된 메소드는 ArrayList와 LinkedList 또는 List 인터페이스를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨 라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨","headline":"자바로 배우는 핵심 자료구조와 알고리즘","mainEntityOfPage":{"@type":"WebPage","@id":"/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"},"url":"/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="icon" href="">
  <link rel="canonical" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Toyo.log">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js" async></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  /*
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }
  */

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe-lightbox.umd.min.js" async></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe.umd.min.js" async></script>
<link href="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/photoswipe.min.css" rel="stylesheet">
<style>
  .pswp .pswp__container .pswp__img {
    background-color: white;
  }
</style>

<script>
  function initPhotoSwipe() {
    let customOptions = {};

    try {
      const data = ``.replaceAll("=>", ":");
      customOptions = JSON.parse(data);
    } catch (e) {
      console.info("Invalid custom photo previewer options! " + e.message);
    }

    // Define object and gallery options
    const options = Object.assign(
      {
        gallery: "section.main",
        children: "a.photo-swipe",
        photo_scale: 2,
        // dynamic import is not supported in UMD version
        pswpModule: PhotoSwipe,
      },
      customOptions
    );

    const galleryEl = document.querySelector(options.gallery);
    if (!galleryEl) {
      return;
    }

    const imgEls = [];
    const els = galleryEl.querySelectorAll("img:not(.emoji)");
    els.forEach((el) => {
      if (el.src.trim() == "") {
        return;
      }
      if (!imgEls.includes(el)) {
        imgEls.push(el);
      }
    });

    if (imgEls.length === 0) {
      return;
    }

    imgEls.forEach((imgEl) => {
      imgEl.outerHTML = `
      <a class="photo-swipe"
        href="${imgEl.src}"
        data-pswp-width="${
          Math.max(imgEl.naturalWidth, imgEl.width) * options.photo_scale
        }"
        data-pswp-height="${
          Math.max(imgEl.naturalHeight, imgEl.height) * options.photo_scale
        }"
        data-pswp-caption="${imgEl.getAttribute("caption") || imgEl.alt}"
        target="_blank">
        ${imgEl.outerHTML}
      </a>`;
    });

    // Initialize PhotoSwipe 5
    var lightbox = new PhotoSwipeLightbox(options);

    lightbox.init();
  }

  window.addEventListener("load", initPhotoSwipe);
</script>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Toyo.log" src="" onerror="this.style.display='none'">
  Toyo.log
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/categories.html">CATEGORIES</a><a class="page-link" href="/">HOME</a><a class="page-link" href="/tags.html">TAGS</a>









<div class="page-link" style="display: inline;">



<div id="google_translate_element" style="display: none;">
</div>

<div class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</div>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'en',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit" async></script>
</div>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('light' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">자바로 배우는 핵심 자료구조와 알고리즘</h1>
  <h2 class="post-subtitle">자료구조/알고리즘 정리</h2>

  <div class="post-meta">
    <time class="dt-published" datetime="2025-09-11T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Sep 11, 2025
    </time>
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 30 mins</span>
  </div>
<div class="post-tags">
<a class="post-tag" href="/tags.html#java">#java</a><a class="post-tag" href="/tags.html#%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0">#자료구조</a><a class="post-tag" href="/tags.html#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">#알고리즘</a>
</div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="1-인터페이스-프로그래밍">1. 인터페이스 프로그래밍</h2>
<ul>
  <li>java.util.List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List 인터페이스에 정의된 메소드는 ArrayList와 LinkedList 또는 List 인터페이스를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨</li>
  <li>라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨</li>
</ul>

<h2 id="2-빅오-표기법">2. 빅오 표기법</h2>
<ul>
  <li>알고리즘의 성능(시간 혹은 공간 복잡도)을 입력 크기 n에 따라 표현하는 수학적 표기법</li>
  <li>전체 코드 구현 이전에 컴퓨터의 성능에 구애받지 않고 알고리즘의 소요 시간을 정량화하기 위해 입력 크기에 따른 증가율을 비교함</li>
  <li>입력 크기가 커질수록 알고리즘 간 성능 차이가 커지므로, 분석은 대규모 입력에 초점을 맞춰야 함. 빅오 표기법은 이러한 상황에서 알고리즘의 최악의 실행 시간을 표현하여 성능을 평가하는 데 사용</li>
  <li>실행 속도 O(1) &lt; O(log N) &lt; O(N) &lt; O(N log N) &lt; O(N^2) &lt; O(2^N)</li>
</ul>

<h2 id="3-arraylist">3. ArrayList</h2>
<ul>
  <li>java.util.ArrayList 클래스는 java.util.List 인터페이스의 구현 클래스 중 하나. List 인터페이스 문서에 정의된 add, gets, rem, set, indexOf, equals 메소드 규칙을 참고하여 ArrayList 클래스와 유사한 MyArrayList 클래스를 작성해보면 아래와 같음
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class MyArrayList&lt;T&gt; implements List&lt;T&gt; {
      int size;
      private T[] array;

      @Override
      public boolean add(T element) {
          if (size &gt;= array.length) {
              // 배열의 전체 크기보다 더 많은 값이 삽입되면 크기가 그 2배인 배열을 다시 생성, 기존값 복사
              // 자바에선 타입 파라미터(T)로 배열을 초기화할 수 없으므로 Object 배열 생성 후 형변환
              E[] bigger = (T[]) new Object[array.length * 2];
              System.arraycopy(array, 0, bigger, 0, array.length);
              array = bigger;
          }
          array[size] = element;
          size++;
          return true;
      }

      @Override
      public void add(int index, T element) {
          if (index &lt; 0 || index &gt; size) {
              throw new IndexOutOfBoundsException();
          }
          add(element);

          // shift the elements
          for (int i=size-1; i&gt;index; i--) {
              array[i] = array[i-1];
          }
          // put the new one in the right place
          array[index] = element;
      }

      @Override
      public T get(int index) {
          if (index &lt; 0 || index &gt;= size) {
              throw new IndexOutOfBoundsException();
          }
          return array[index];
      }

      @Override
      public T set(int index, T element) {
          E old = get(index);
          array[index] = element;
          return old;
      }

      @Override
      public int indexOf(Object target) {
          for (int i = 0; i &lt; size; i++) {
              if (equals(target, array[i])) return i;
          }
          return -1;
      }

      private boolean equals(Object target, Object element) {
          if (target == null) {
              return element == null;
          } else {
              //Object 객체의 equals 메소드를 호출하여 실제 객체에서 재정의한 equals 메소드가 호출됨 
              return target.equals(element);
          }
      }

      @Override
      public boolean remove(Object obj) {
          int index = indexOf(obj);
          if (index == -1) {
              return false;
          }
          remove(index);
          return true;
      }

      @Override
      public T remove(int index) {
          E element = get(index);
          for (int i=index; i &lt; size-1; i++) {
              array[i] = array[i+1];
          }
          size--;
          return element;
      }

      ...

</code></pre></div>    </div>
  </li>
  <li>get, set, indexOf, equals, remove 메소드의 시간 복잡도는 각각 상수, 상수, 선형, 상수, 선형임</li>
  <li>add(T element) 메소드의 시간 복잡도를 계산하기 위해 크기가 2인 배열에 n개 요소를 추가할 때의 평균 연산 횟수를 고려하면
    <ul>
      <li>1~2번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장</li>
      <li>3번째 호출 : 기존의 2배 크기(=4)를 가진 배열을 생성하여 기존 요소 2개를 복사하고 요소 저장</li>
      <li>4번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장</li>
      <li>5번째 호출 : 기존의 2배 크기(=8)를 가진 배열을 생성하여 기존 요소 4개를 복사하고 요소 저장</li>
      <li>6~8번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장</li>
      <li>위의 패턴 반복</li>
    </ul>
  </li>
  <li>결과적으로 n번 추가하면 요소 총 n개를 저장하고 총 n-2개를 복사함. 따라서 총 연산 횟수는 2n-2이고, 평균 횟수는 n으로 나누어 2-2/n이 됨</li>
  <li>n이 커질수록 두 번째 항인 2/n는 작아지므로 add(T element) 메소드는 상수 시간으로 간주됨</li>
  <li>일련의 호출에서 평균 시간을 계산하는 알고리즘 분류 방법을 <strong>분할 상환 분석</strong>이라고 함. 핵심 개념은 배열의 크기를 조정할 때마다 배열의 길이가 2배로 늘어나 각 요소를 복사하는 횟수를 제한한다는 것. 매번 고정된 양을 더해서 크기를 늘리는 대신 곱하여 연산 횟수를 더 제한함</li>
  <li>이어서 removeAll 메소드를 구현하면 아래와 같음
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  @Override
  public boolean removeAll(Collection&lt;?&gt; collection) {
      boolean flag = true;
      for (Object obj: collection) {
          flag &amp;= remove(obj);
      }
      return flag;
  }
</code></pre></div>    </div>
  </li>
  <li>반복문을 돌리며 선형인 remove 메소드를 호출하고 있지만 collection 크기가 n에 비례하지 않는다면 이차가 아님</li>
</ul>

<h2 id="4-linkedlist">4. LinkedList</h2>
<ul>
  <li>연결 리스트에서 각 노드는 리스트의 다음 노드에 대한 참조를 포함. 연결 구조의 다른 예로는 트리와 그래프가 있음</li>
  <li>java.util.List 인터페이스를 상속받아 MyLinkedList를 직접 구현
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class MyLinkedList&lt;E&gt; implements List&lt;E&gt; {

      private class Node {
          public E data;
          public Node next;

          public Node(E data) {
              this.data = data;
              this.next = null;
          }
      }

      private int size;            // 요소 더하거나 제거할 때마다 갱신
      private Node head;           // 리스트의 첫 번째 노드 참조. 빈 리스트이면 null

      public MyLinkedList() {
          head = null;
          size = 0;
      }

      @Override
      public boolean add(E element) {
          if (head == null) {
              head = new Node(element);
          } else {
              Node node = head;
              for ( ; node.next != null; node = node.next) {}
              node.next = new Node(element);
          }
          size++;
          return true;
      }

      @Override
      public void clear() {
          head = null;
          size = 0;
      }
</code></pre></div>    </div>
  </li>
  <li>LinkedList는 ArrayList와 달리 리스트 자체가 파괴되지 않아도 요소를 제거하면 리스트 크기가 줄어들고 사용하지 않는 노드는 즉시 가비지 컬렉션이 될 수 있다는 장점이 있음</li>
  <li>add 메소드는 리스트의 끝까지 이동해야 하므로 선형 증가차수를 가짐</li>
  <li>clear 메소드로 LinkedList의 첫 번째 노드 참조를 제거할 경우에는 순차적으로 연결리스트의 각 노드들에 대한 참조가 사라지게 되어 가비지 컬렉션이 선형이 됨
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>      private boolean equals(Object target, Object element) {
          if (target == null) {
              return element == null;
          } else {
              return target.equals(element);  //Object를 오버라이드 한 target의 실제 equals 메소드 호출
          }
      }

      @Override
      public int indexOf(Object target) {
          Node node = head;
          for (int i=0; i &lt; size; i++){
              if (equals(target, node.data)) {
                  return i;
              }
              node = node.next;
          }
          return -1;
      }

      private Node getNode(int index) {
          if (index &lt; 0 || index &gt;= size) {
              throw new IndexOutOfBoundsException();
          }
          Node node = head;
          for (int i=0; i&lt;index; i++) {
              node = node.next;
          }
          return node;
      }

      @Override
      public E get(int index) {
          Node node = getNode(index);
          return node.data;
      }

      @Override
      public void add(int index, E element) {
          if (index == 0) {
              head = new Node(element, head);
          } else {
              Node node = getNode(index - 1);
              node.next = new Node(element, node.next);
          }
          size++;
      }

      @Override
      public E remove(int index) {
          E element = get(index);
          if (index == 0) {
              head = head.next;
          } else {
              Node node = getNode(index-1);
              node.next = node.next.next;
          }
          size--;
          return element;
      }
</code></pre></div>    </div>
  </li>
  <li>indexOf는 선형, remove와 add(int index, E element)도 index가 0인 특별한 경우를 제외하고 getNode가 선형이므로 선형</li>
  <li>MyArrayList 클래스는 끝에 추가하고 끝에서 제거할 때와 get/set 메서드 연산에 이점이 있으며, MyLinkedList 클래스는 시작에 추가하고 시작에서 제거하는 연산에 이점이 있음. 다른 연산에서는 증가 차수가 같음</li>
  <li>ArrayList 끝에 새로운 요소를 추가하는 실행 시간 측정 테스트
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public static void profileArrayListAddEnd() {
      Timeable timeable = new Timeable() {
          List&lt;String&gt; list;

          // 초기 설정: ArrayList 사용
          public void setup(int n) {
              list = new ArrayList&lt;String&gt;();
          }

          // 테스트 내용: 리스트 맨 앞에 n개의 요소를 추가
          public void timeMe(int n) {
              for (int i = 0; i &lt; n; i++) {
                  list.add("a string");
              }
          }
      };
      int startN = 4000;  // 몇 번 추가할지에 대한 n값
      int endMillis = 1000;   // timingLoop 테스트 실행시간
      runProfiler("ArrayList add first", timeable, startN, endMillis);
  }

  private static void runProfiler(String title, Timeable timeable, int startN, int endMillis) {
      Profiler profiler = new Profiler(title, timeable);
      XYSeries series = profiler.timingLoop(startN, endMillis);
      profiler.plotResults(series);
  }
</code></pre></div>    </div>
    <ul>
      <li>리스트 맨 앞에 n개의 요소를 추가하는 시간 측정 테스트 수행. 테스트에 사용되는 Profiler, Timeable 클래스는 교재의 별도 코드 참고</li>
      <li>테스트 결과 : endMillis 동안 루프를 돌며 2배식 증가되는 startN과, 해당 startN에서 10회 씩 timeMe를 수행한 총 소요 시간 출력
        <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  4000, 3
  8000, 0
  16000, 1
  32000, 2
  64000, 3
  128000, 6
  256000, 18
  512000, 30
  1024000, 8
  2048000, 185
  4096000, 242
  8192000, 544
  16384000, 1325
</code></pre></div>        </div>
      </li>
      <li>테스트 수행 결과 그래프가 a + bn (직선)이 되는 것 확인 가능. a는 Y 절편, b는 기울기</li>
      <li>plotResults 메소드는 테스트 수행 결과를 그래프로 출력</li>
      <li>측정에 잡음이 많으면 그래프 차이를 확인하기 어려우므로 이차 이상은 log-log 스케일을 적용해 직선 그래프 간의 기울기의 차이를 확인할 수 있음. 기울기가 1에 가까우면 선형, 2에 가까우면 이차로 봐야함</li>
      <li>timeMe 메소드를 ArrayList 맨 앞에 n개의 새로운 요소를 추가하도록 수정하면 전체시간은 이차가 되며, log-log 스케일을 적용했을때 기울기가 2에 가까워짐</li>
      <li>MyLinkedList 클래스를 이용하여 시작과 끝에 n개의 새로운 요소를 추가하도록 수정하면 둘다 1에 가까운 기울기가 출력됨</li>
    </ul>
  </li>
</ul>

<h2 id="5-이중-연결-리스트">5. 이중 연결 리스트</h2>
<ul>
  <li>앞서 구현한 단일 연결 리스트인 MyLinkedList와 달리 java.util.LinkedList 클래스는 이중 연결 리스트로 아래와 같은 특징이 있음
    <ul>
      <li>각 노드는 다음 노드와 이전 노드의 참조를 포함</li>
      <li>LinkedList 객체는 첫번째와 마지막 요소에 대한 참조를 포함</li>
    </ul>
  </li>
  <li>
    <p>ArrayList, 단일 연결 리스트, 이중 연결 리스트 성능 비교</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">구분</th>
          <th style="text-align: center">ArrayList</th>
          <th style="text-align: center">MyLinkedList</th>
          <th style="text-align: center">LinkedList</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">add(끝)</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">add(시작)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">add(일반적으로)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
        <tr>
          <td style="text-align: left">get/set</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
        <tr>
          <td style="text-align: left">indexOf/lastIndexOf</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
        <tr>
          <td style="text-align: left">isEmpty/size</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">remove(끝)</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">remove(시작)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">remove(일반적으로)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>ArrayList 클래스는 get/set 메서드에서 유일하게 연결 리스트보다 나은 성능을 보임</li>
  <li>반대로 실행시간이 시작이나 끝 근처에 요소를 추가하거나 제거하는 연산에 의존한다면 LinkedList 클래스가 좋음</li>
  <li>단, 이러한 연산이 프로그램의 실행시간에 뚜렷한 영향을 미치지 않는다면 List 구현에 대한 선택은 큰 의미가 없음</li>
  <li>또한 리스트가 충분히 크지 않으면 위의 성능표에 있는 성능차이는 해당되지 않으며 공간면에서는 ArrayList가 참조가 차지하는 공간이 적어 연결리스트보다 효율이 높음</li>
</ul>

<h2 id="6-트리-순회">6. 트리 순회</h2>

<h3 id="61-웹-크롤러-구현을-위한-dfs-트리-순회">6.1 웹 크롤러 구현을 위한 DFS 트리 순회</h3>
<ul>
  <li>웹 크롤러가 HTML 페이지를 다운로드하고 파싱해 본문과 링크를 추출하도록 하기 위해 jsoup 라이브러리를 사용</li>
  <li>jsoup은 HTML 문서를 노드 기반 연결 자료구조인 DOM 트리 형태로 표현하며, 이 트리 구조는 깊이 우선 탐색(DFS)을 수행하기에 적합함
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class WikiNodeExample {
      public static void main(String[] args) throws IOException {
          String url = "https://en.wikipedia.org/wiki/Java_(programming_language)";
            
          //String 타입의 URL을 인자로 받아 웹 서버에 접속
          Connection conn = Jsoup.connect(url);
          //get 메소드는 HTML 을 다운로드하여 파싱하고 DOM 트리를 나타내는 Document 객체를 반환
          Document doc = conn.get();
            
          Element content = doc.getElementById("mw-content-text");
          Elements paras = content.select("p");
          Element firstPara = paras.get(0);
		
          //재귀적 방법을 사용한 DOM 트리 깊이 우선 탐색
          recursiveDFS(firstPara);
          System.out.println();

          //반복적 방법을 사용한 DOM 트리 깊이 우선 탐색
          iterativeDFS(firstPara);
          System.out.println();
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="62-dfs로-트리를-순회하는-2가지-방법">6.2 DFS로 트리를 순회하는 2가지 방법</h3>

<h4 id="621-재귀적-방법을-사용한-트리-순회">6.2.1 재귀적 방법을 사용한 트리 순회</h4>
<ul>
  <li>자식 노드를 탐색하기에 앞서 각 TextNode의 내용을 출력하는 전위 순회 방식
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  private static void recursiveDFS(Node node) {
      if (node instanceof TextNode) {
          System.out.print(node);
      }
      for (Node child: node.childNodes()) {
          recursiveDFS(child);
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="622-반복적-방법을-사용한-트리-순회--스택-사용">6.2.2 반복적 방법을 사용한 트리 순회 : 스택 사용</h4>
<ul>
  <li>스택 자료구조는 push, pop, peek, isEmpty 등 List의 일부 기능만 제공하지만 단순하여 코드 가독성을 높이고 오류 발생 가능성을 줄임. 또한 API가 적으면 효율적으로 구현하기가 더 쉬워짐</li>
  <li>자바로 스택 구현 시 기존 ArrayList나 LinkedList 클래스를 사용하면 잘못된 위치에 추가하거나 잘못된 순서로 제거하는 실수가 발생할 수 있고, 자바의 Stack 클래스는 오래된 버전이라 최근 JCF와 일치하지 않으므로 ArrayDeque같은 Deque 인터페이스를 구현한 클래스를 사용하는 편이 좋음</li>
  <li>Deque는 양쪽에 끝이 있는 큐로, 자바에서 Deque 인터페이스는 push 와 pop, peek, isEmpty 메서드를 제공하므로 스택으로 구현할 수 있음
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  private static void iterativeDFS(Node root) {
      Deque&lt;Node&gt; stack = new ArrayDeque&lt;Node&gt;();
      stack.push(root);

      while (!stack.isEmpty()) {
          Node node = stack.pop();
          if (node instanceof TextNode) {
              System.out.print(node);
          }

          // 후입선출이므로 역순으로 삽입
          List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(node.childNodes());
          Collections.reverse(nodes);
			
          for (Node child: nodes) {
              stack.push(child);
          }
      }
  }
</code></pre></div>    </div>
  </li>
  <li>반복적 DFS가 재귀적 DFS보다 Iterator 인터페이스(hasNext(), next())로 래핑하기가 용이해 외부에서 순회 제어하기가 더 쉬움</li>
  <li>웹 크롤러를 이용한 철학으로 가는 길 예제 (교재 확인 시 참고용)
    <ul>
      <li>ArrayDeque 스택을 가지고 DOM 트리를 탐색하는 Iterable 구현 클래스 WikiNodeIterable</li>
      <li>jsoup 라이브러리를 활용하여 위키피디아 페이지를 다운로드하는 WikiFetcher 클래스</li>
      <li>WikiNodeIterable을 사용해 페이지의 첫 번째 유효링크를 파싱하는 WikiParser 클래스</li>
      <li>WikiParser와 WikiFetcher을 사용하여 주어진 위키피디아 페이지에서 시작해 첫 번째 링크를 따라가며 목표 페이지에 도달하거나 제한 횟수·사이클·막다른 길에 걸릴 때까지 탐색하는 WikiPhilosophy 클래스</li>
    </ul>
  </li>
</ul>

<h2 id="7-map">7. Map</h2>

<h3 id="71-map-set과-인덱서">7.1 Map, Set과 인덱서</h3>
<ul>
  <li>인덱서는 검색어를 바탕으로 관련 페이지를 찾을 수 있게 하는 자료구조. 검색어가 각 페이지에 몇 번씩 등장하는지를 기록해 가장 관련성이 높은 페이지 식별</li>
  <li>List<page> 같은 페이지의 컬렉션 형태보다는 키에 해당하는 값을 빠르게 찾을 수 있는 Map이 더 적절함</page>
</li>
  <li>검색어와 검색어가 등장하는 페이지의 컬렉션을 매핑하는 Index 라는 클래스, 해당 페이지의 단어 별 등장 횟수를 매핑하는 Termcounter 클래스 구현</li>
  <li>검색어별로 등장하는 페이지를 모아두면, 여러 검색어를 동시에 찾을 때는 교집합 연산으로 공통 페이지를 구해야 함</li>
  <li>Set은 기본적으로 중복 없는 집합 구조로, TermCounter의 equals()와 hashCode() 메소드를 label로 비교하도록 재정의할 경우 페이지 별로 유일하며 교집합 같은 연산을 효율적으로 구현할 수 있는 메소드를 제공해 페이지 별 데이터를 저장하는데 적합함</li>
  <li>Index 클래스는 단어 문자열을 key, TermCounter 객체들의 Set을 value로 가지는 Map을 보유하여 특정 검색어에 대한 페이지별 등장횟수(TermCounter)를 제공
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class Index {
      private Map&lt;String, Set&lt;TermCounter&gt;&gt; index = new HashMap&lt;String, Set&lt;TermCounter&gt;&gt;();
      ...
  }
</code></pre></div>    </div>
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class TermCounter {

      private Map&lt;String, Integer&gt; map; //해당 페이지에서 해당 단어가 등장하는 횟수 매핑
      private String label; //페이지의 url

      public TermCounter(String label) {
          this.label = label;
          this.map = new HashMap&lt;String, Integer&gt;();
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>TermCounter는 jsoup 라이브러리의 Element 객체 컬렉션인 Elements 객체를 쪼개 단어별 등장 횟수를 카운트하는 processElement, processTree, processText 메소드 제공. processTree는 Element 객체의 DOM 트리를 탐색하기 위해 앞서 정의된 WikiNodeIterable 클래스를 사용함 (교재 코드 참고)</li>
  <li>자바 Map 인터페이스 구현 클래스로는 HashMap, TreeMap 클래스, Set 인터페이스 구현 클래스로는 HashSet과 TreeSet 클래스가 있음</li>
</ul>

<h3 id="72-map-인터페이스-구현">7.2 Map 인터페이스 구현</h3>
<ul>
  <li>java.util.Map 인터페이스 문서의 메소드 정의를 참고하여 해당 인터페이스를 구현한 MyLinearMap 클래스 작성
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class MyLinearMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

      private List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;();

      public class Entry implements Map.Entry&lt;K, V&gt; {
          private K key;
          private V value;

          public Entry(K key, V value) {
              this.key = key;
              this.value = value;
          }
      }

      private Entry findEntry(Object target) {
          for (Entry entry: entries) {
              if (equals(target, entry.getKey())) {
                  return entry;
              }
          }
          return null;
      }

      private boolean equals(Object target, Object obj) {
          if (target == null) {
              return obj == null;
          }
          return target.equals(obj);
      }

      @Override
      public V get(Object key) {
          Entry entry = findEntry(key);
          if (entry == null) return null;
          return entry.getValue();
      }

      @Override
      public V put(K key, V value) {
          Entry entry = findEntry (key)
          if (entry == null){
              entries.add(new Entry(key, value));
          } else {
              V oldValue = entry.getValue();
              entry.setValue(value);
              return oldValue;
          }
      }

      @Override
      public V remove(Object key) {
          Entry entry = findEntry(key);
          if (entry == null) {
              return null;
          } else {
              V value = entry.getValue();
              entries.remove(entry);
              return value;
          }
      }

      @Override
      public void clear() {
          entries.clear();
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>Entry 클래스는 단지 키와 값의 컨테이너로 이 정의는 MyLinearMap 클래스에 중첩되어 있으므로 같은 타입 파라미터인 K와 V를 사용</li>
  <li>equals는 상수시간, findEntry가 선형이므로 put과 get도 선형, remove는 ArrayList 시작이나 중간에서 삭제할경우 요소를 이동해야하지만 2번의 선형 연산이므로 마찬가지로 선형</li>
  <li>해시코드를 사용하면 Map의 증가차수를 더 개선할 수 있음</li>
</ul>

<h3 id="73-hashmap">7.3 HashMap</h3>
<ul>
  <li>Entry 대신 MyLinearMap(Entry List)의 List 컬랙션 사용</li>
  <li>키를 확인하여 어느 내장 Map에 투입할지 결정하기 위해 해시 함수 chooseMap 사용. 이 함수는 0bject 객체를 인자로
받아 해시 코드라는 정수를 반환하는데, 중요한 점은 같은 0bject 객체에 대해서는 항상 같은 해시 코드를 반환해야 함</li>
  <li>자바에서 모든 0bject 객체는 hashCode 라는 메소드를 제공하여 해시 함수를 계산하며, 메서드의 구현은 객체의 종류에 따라 달라짐</li>
  <li>하나의 Map이 여러 MyLinearMap으로 쪼개지는 만큼 탐색해야 하는 각 맵의 엔트리 개수는 더 줄어드므로 FindEntry 메서드와 그것을 호출하는 메서드의 속도가 더 빨라짐
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class MyBetterMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

      protected List&lt;MyLinearMap&lt;K, V&gt;&gt; maps;

      public MyBetterMap() {
          makeMaps(2);
      }

      protected void makeMaps(int k) {
          maps = new ArrayList&lt;MyLinearMap&lt;K, V&gt;&gt;(k);
          for (int i=0; i&lt;k; i++) {
              maps.add(new MyLinearMap&lt;K, V&gt;());
          }
      }

      protected MyLinearMap&lt;K, V&gt; chooseMap(Object key) {
          //ath.abs 메서드를 호출하여 절대값을 만들고 %를 사용하여 결과가 0 에서 map.size()-1 사이에 있음을 보장
          int index = key==null ? 0 : Math.abs(key.hashCode()) % maps.size();
          return maps.get(index);
      }

      @Override
      public V get(Object key) {
          MyLinearMap&lt;K, V&gt; map = chooseMap(key);
          return map.get(key);
      }

      @Override
      public V put(K key, V value) {
          MyLinearMap&lt;K, V&gt; map = chooseMap(key);
          return map.put(key, value);
      }

      @Override
      public int size() {
          // add up the sizes of the sub-maps
          int total = 0;
          for (MyLinearMap&lt;K, V&gt; map: maps) {
              total += map.size();
          }
          return total;
      }

      @Override
      public void clear() {
          // clear the sub-maps
          for (int i=0; i&lt;maps.size(); i++) {
              maps.get(i).clear();
          }
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>탐색해야 할 Map 당 Entry가 n/k개로 줄어들지만 chooseMap을 호출하는 get, put 메소드의 성능은 여전히 n에 비례함</li>
  <li>하지만 n과 함께 k를 늘려간다면 n/k의 크기를 제한할 수 있음. 3. ArrayList의 분할상환방식에서 확인한 것처럼 매번 n이 k를 초과할 때 k를 두 배로 늘린다면 put을 상수시간으로 줄일 수 있음. 또한 하위 맵당 엔트리의 개수가 일정하면 단일 하위 맵은 상수 시간으로 검색할 수 있음</li>
  <li>MyBetterMap에서 각 맵의 크기는 ArrayList에 의존하여 자동으로 증가하므로 FACTOR 값만큼 맵 당 최대 엔트리 개수를 제한하고 요소가 새로 추가되면 내장 Map을 새로 생성</li>
  <li>앞서 정의한 MyBetterMap을 상속받아 HashMap 정의
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class MyHashMap&lt;K, V&gt; extends MyBetterMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

      protected static final double FACTOR = 1.0; //하위 맵당 최대 엔트리 개수

      @Override
      public V put(K key, V value) {
          V oldValue = super.put(key, value);

          //size() : 엔트리의 전체 개수인 n
          //maps.size() : 내장된 map의 개수인 k
          if (size() &gt; maps.size() * FACTOR) {
              rehash();
          }
          return oldValue;
      }
  }
</code></pre></div>    </div>
  </li>
  <li>put 메소드만 새로 재정의하여 MyBetterMap의 put 메소드를 호출하고 재해시가 필요한지 확인</li>
  <li>n 〉 k * FACTOR면 하위 맵당 엔트리의 개수가 임계치를 초과함을 의미하므로 rehash 메서드를 호출. rehash 메서드가 호출될 때마다 내장된 맵의 개수 k는 두 배가 됨</li>
  <li>맵 당 엔트리 개수가 제한됨으로서 get, containsKey, remove 메소드는 자동으로 상수시간이 됨</li>
  <li>그러나 size 메소드가 여전히 선형이므로 대신 size 인스턴스 변수를 추가하여 put, remove 메소드에서 관리
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  ...
  private int size = 0;

  @Override
  public V remove(Object key) {
      MyLinearMap&lt;K, V&gt; map = chooseMap(key);
      size -= map.size();
      V oldValue = map.remove(key);
      size += map.size();
      return oldValue;
  }

  @Override
  public V put(K key, V value) {
      MyLinearMap&lt;K, V› map = chooseMap(key);
      size -= map.size();
      V oldValue = map.put(key, value);
      size += map.size();
      if (size() 〉 maps.size() * FACTOR) {
          size = 0;
          rehash();
      }
      return oldValue;
  }

  @Override
  public int size() {
      return size;
  }

  @Override
  public void clear() {
      super.clear();
      size = 0;
  }
  ...
</code></pre></div>    </div>
  </li>
  <li>size 메소드가 상수시간이 되어 put 메소드도 자동으로 상수시간이 됨</li>
  <li>MyBetterMap에서 clear 메소드는 오히려 선형이 되었지만 자주 사용되지 않는 함수라 감안할 만함</li>
  <li>많은 객체가 동일한 해시 코드를 갖는다면 결국 같은 하위 맵으로 몰리게 되고, k개의 하위 맵으로 인한 성능 향상은 k보다 줄어들게 됨. 따라서 해시 함수는 해시코드를 균등하게 분배해야 함</li>
  <li>해싱을 사용하는 자료구조에서 가변 객체를 키로 사용하는 것은 위험함. 키가 맵에 있는 동안 키 값이 변경되면 해당 값을 찾지 못하게 됨</li>
  <li>equals()가 true인 객체들은 반드시 hashCode() 결과값이 동일해야 해시 기반 컬렉션에서 올바르게 동작함</li>
</ul>

<h3 id="74-treemap">7.4 TreeMap</h3>
<ul>
  <li>HashMap은 널리 사용되지만 상수시간이라도 상수가 상당히 커지거나, 하위 맵에 고르게 키를 분배하는 좋은 해시 함수를 설계하는게 어렵거나, 저장되는 데이터에 순서가 없다는 문제점이 있음</li>
  <li>TreeMap은 해싱을 사용하지 않으며 이진 탐색 트리에 키를 저장하므로 키를 선형 시간으로 순서대로 조회할 수 있음. 또한 핵심 메소드의 실행시간이 log n에 비례하여 쓸만함</li>
  <li>이진 탐색 트리는 아래와 같은 속성이 있음
    <ul>
      <li>노드 왼쪽에 자식이 있다면 왼쪽 하위 트리의 모든 키는 노드에 있는 키보다 작음</li>
      <li>노드 오른쪽에 자식이 있다면 오른쪽 하위 트리의 모든 키는 노드에 있는 키보다 큼</li>
      <li>따라서 검색할 때 트리 전체를 탐색할 필요 없이 트리의 각 수준에서 한개의 자식노드만 찾으면 됨. 이는 트리의 높이인 log n에 비례함
        <ul>
          <li>이진 트리의 높이 별 총 노드 개수는 n = 2^h - 1이므로, log를 씌우면 log n ≈ h</li>
        </ul>
      </li>
      <li>위의 조건들을 만족할 뿐 기본적으로는 균형있는 이진트리를 보장하진 않음</li>
    </ul>
  </li>
  <li>이진 탐색 트리로 Map 인터페이스를 구현하면 아래와 같음
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class MyTreeMap&lt;K, V&gt; implements Map&lt;K, V&gt; {
      private int size = 0;
      private Node root = null;

      protected class Node {
          public K key;
          public V value;
          public Node left = null;
          public Node right = null;

          public Node(K key, V value) {
              this.key = key;
              this.value = value;
          }
      }

      @Override
      public void clear() {
          size = 0;
          root = null;
      }

      @Override
      public boolean containsKey(Object target) {
          return findNode(target) != null;
      }

      private Node findNode(Object target) {
          if (target == null) {
              throw new IllegalArgumentException();
          }

          // key와 비교하기 위해 Object -&gt; Key 타입으로 형변환
          // Map 인터페이스 규약에 따르면 containsKey의 파라미터 타입은 Object
          @SuppressWarnings("unchecked")
          Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) target;

          Node node = root;
          while (node != null)
          {
              int cmp = k.compareTo(node.key);
              if (cmp &lt; 0)
                  node = node.left;
              else if (cmp &gt; 0)
                  node = node.right;
              else
                  return node;
          }
          return null;
      }

      private boolean equals(Object target, Object obj) {
          if (target == null) {
              return obj == null;
          }
          return target.equals(obj);
      }

      @Override
      public boolean containsValue(Object target) {
          return containsValueHelper(root, target);
      }

      private boolean containsValueHelper(Node node, Object target) {
          if (node == null) {
              return false;
          }
          if (equals(target, node.value)) {
              return true;
          }
          if (containsValueHelper(node.left, target)) {
              return true;
          }
          if (containsValueHelper(node.right, target)) {
              return true;
          }
          return false;
      }

      @Override
      public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {
          throw new UnsupportedOperationException();
      }

      @Override
      public V get(Object key) {
          Node node = findNode(key);
          if (node == null) {
              return null;
          }
          return node.value;
      }

      @Override
      public Set&lt;K&gt; keySet() {
          Set&lt;K&gt; set = new LinkedHashSet&lt;K&gt;();
          addInOrder(root, set);
          return set;
      }

      private void addInOrder(Node node, Set&lt;K&gt; set) {
          if(node == null) return;
          addInOrder(node.left, set);
          set.add(node.key);
          addInOrder(node.right, set);
      }

      @Override
      public V put(K key, V value) {
          if (key == null) {
              throw new NullPointerException();
          }
          if (root == null) {
              root = new Node(key, value);
              size++;
              return null;
          }
          return putHelper(root, key, value);
      }

      private V putHelper(Node node, K key, V value) {
          Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
          int cmp = k.compareTo(node.key);

          //리프 노드를 찾아서 키를 비교하여 크기에 따라 오른쪽/왼쪽 자식 노드로 추가
          if (cmp &lt; 0) {
              if (node.left == null) {
                  node.left = new Node(key, value);
                  size++;
                  return null;
              }
              else {
                  return putHelper(node.left, key, value);
              }
          }
          if (cmp &gt; 0) {
              if (node.right == null) {
                  node.right = new Node(key, value);
                  size++;
                  return null;
              }
              else {
                  return putHelper(node.right, key, value);
              }
          }
          V oldValue = node.value;
          node.value = value;
          return oldValue;
      }

      @Override
      public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
          for (Map.Entry&lt;? extends K, ? extends V&gt; entry: map.entrySet()) {
              put(entry.getKey(), entry.getValue());
          }
      }

      @Override
      public V remove(Object key) {
          if (root == null) throw new UnsupportedOperationException();

          Node deletedNode = new Node(null, null);
          root = removeHelper(root, (Comparable&lt;? super K&gt;) key, deletedNode);
          if (deletedNode.value != null) size--;
            
          return deletedNode.value;
      }

      public Node removeHelper(Node node, Comparable&lt;? super K&gt; key, Node deletedNode) {
          int cmp = key.compareTo(node.key);

          if (cmp &lt; 0) {
              node.left = removeHelper(node.left, key, deletedNode);
          } else if (cmp &gt; 0) {
              node.right = removeHelper(node.right, key, deletedNode);
          } else {
              // 삭제할 노드 찾음
              if(deletedNode != null) deletedNode.value = node.value;

              // (1) 리프 노드
              if (node.left == null &amp;&amp; node.right == null) return null;

              // (2) 자식 하나
              if (node.left == null) return node.right;
              if (node.right == null) return node.left;

              // (3) 자식 둘
              Node successor = findMin(node.right);  // 오른쪽 서브트리에서 가장 작은 값
              node.key = successor.key;
              node.value = successor.value;
              node.right = removeHelper(node.right, (Comparable&lt;? super K&gt;) successor.key, null);
          }
          return node;
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>clear는 root가 null이 될 시 자식 노드들을 수거하므로 선형시간임을 고려해야함</li>
  <li>findNode, put, remove는 key를 사용하기 때문에 트리의 높이에 비례하나 containsValue, keySet은 트리 전체를 검색하므로 n에 비례함</li>
  <li>트리의 모든 노드를 방문하는 방식으로 전위/중위/후위 순회가 있는데 containsValueHelper는 순서 상관없이 value를 확인하므로 전위 순회, addInorder는 오름차순으로 key 값을 정렬해야 하므로 중위 순회를 함</li>
  <li>위 코드에서 put 메소드를 확인해보면 순차적으로 증가하는 값들을 put 할 경우 오른쪽 자식에만 쏠린 불균형 트리가 됨</li>
  <li>불균형 트리를 해결하기 위해서는 Map에 키를 순서대로 넣지 않거나, put을 수정하여 트리가 불균형해질 때 노드를 재배열하는 로직을 추가해야 함(=자가 균형 트리)</li>
  <li>일반적인 자가 균형 트리로는 AVL 트리, 레드 블랙 트리가 있음</li>
  <li>java.util.TreeMap은 내부적으로 레드 블랙 트리로 구현되어 있어 순차적인 데이터가 삽입되어도 균형을 유지함</li>
  <li>remove 메소드는 삭제할 노드가 리프 노드인지, 자식 하나인지, 둘인지에 따라 다르게 동작함. 삭제할 노드의 자식이 둘일 경우 왼쪽 서브트리에서 가장 큰 값 또는 오른쪽 서브트리에서 가장 작은 값을 찾아 대체해야 함. 이는 트리의 균형을 다시 맞추는 작업과 유사한 연산을 거침</li>
</ul>

<h2 id="8-redis">8. Redis</h2>
<ul>
  <li>앞의 7.1에서 두 가지 자료구조를 이용하여 인덱스를 저장했는데, 이러한 자료구조는 실행 중인 자바 프로그램의 메모리에 저장되어 프로그램이 멈추면 모두 사라짐</li>
  <li>데이터를 영속적으로 만들기 위하여 프로그램 종료 전 JSON 포맷으로 파일에 저장하거나 데이터베이스를 활용하는 방법이 있음</li>
  <li>파일에 저장 시 대량의 자료구조를 읽고 쓰면 느려질 수 있고 단일 실행 프로그램 메모리에 다 들어가지 않을 수 있음. 또한 프로그램 비정상 종료 시 변경사항이 소실될 수 있음</li>
  <li>레디스는 자바 자료구조와 유사한 영속적인 자료구조를 제공함. 기본적으로 String 타입의 키와 다양한 데이터 타입 중 하나를 값으로 넣을 수 있는 맵 구조로, 주목할 자료구조는 아래와 같음
    <ul>
      <li>문자열 String</li>
      <li>자바 Set과 유사한 문자열 집합</li>
      <li>자바 List와 유사한 문자열 리스트</li>
      <li>자바 Map 과 유사한 해시
        <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public static void main(String[] args) throws IOException {

  Jedis jedis = make();

  // String
  jedis.set("mykey", "myvalue");
  String value = jedis.get("mykey");
  System.out.println("Got value: " + value);

  // Set
  jedis.sadd("myset", "element1", "element2", "element3");
  System.out.println("element2 is member: " + jedis.sismember("myset", "element2"));  // Jedis.sismember 메서드는 요소가 ser 에 있는지 검사

  // List
  jedis.rpush("mylist", "element1", "element2", "element3");                  // 리스트의 오른쪽 끝에 요소 추가
  System.out.println("element at index 1: " + jedis.lindex("mylist", 1));     // jedis.lindex는 정수 인덱스를 받아 list의 지정된 요소를 반환

  // Hash
  jedis.hset("myhash", "word1", Integer.toString(2));     // 키와 값은 모두 string이므로 Integer를 저장하려면 hset 메서드를 호출하기 전에 String 타입으로 변환해야 함
  jedis.hincrBy("myhash", "word2", 1);                    // word2 필드의 현재 값(존재하지 않으면 0)을 가져와서 1만큼 증가
  System.out.println("frequency of word1: " + jedis.hget("myhash", "word1"));
  System.out.println("frequency of word2: " + jedis.hget("myhash", "word2"));

  jedis.close();
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>자바 코드에서 Redis와 통신할 수 있게 해주는 클라이언트 라이브러리 Jedis를 만들고 서버에 연결하여 레디스 명령 실행</li>
  <li>Jedis.sismember, jedis.lindex, jedis.hincrBy 모두 상수시간 연산</li>
  <li>jedis.hset에서 첫번째 키는 특정 hash를 식별하고, 두번째 키(=필드)는 hash 안의 값을 식별함</li>
  <li>hash 안의 값의 정수인 경우가 많아 hincrby 같은 특별한 메서드가 제공됨. 이 메서드는 값을 정수로 취급함</li>
</ul>

<h3 id="81-redis로-인덱서-구현">8.1 Redis로 인덱서 구현</h3>
<ul>
  <li>7.1에서 정의한 Index, TermCounter 클래스를 레디스로 이동
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class JedisIndex {

      private Jedis jedis;

      public JedisIndex(Jedis jedis) {
          this.jedis = jedis;
      }

      private String urlSetKey(String term) {
          return "URLSet:" + term;
      }

      private String termCounterKey(String url) {
          return "TermCounter:" + url;
      }

      public void add(String term, TermCounter tc) {
          jedis.sadd(urlSetKey(term), tc.getLabel());
      }

      public boolean isIndexed(String url) {
          String redisKey = termCounterKey(url);
          return jedis.exists(redisKey);
      }

      public Map&lt;String, Integer&gt; getCounts(String term) {
          Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
          Set&lt;String&gt; urls = getURLs(term);
          for (String url : urls) {
              Integer count = getCount(url, term);
              map.put(url, count);
          }
          return map;
      }

      public Set&lt;String&gt; getURLs(String term) {
          Set&lt;String&gt; set = jedis.smembers(urlSetKey(term));
          return set;
      }

      public Integer getCount(String url, String term) {
          String redisKey = termCounterKey(url);
          String count = jedis.hget(redisKey, term);
          return new Integer(count);
      }

      public void indexPage(String url, Elements paragraphs) {
          System.out.println("Indexing " + url);
          // Termcounter 객체를 만들어 단락에 있는 검색어 개수를 셉니다
          TermCounter tc = new TermCounter(url);
          tc.processElements(paragraphs);
          // TermCounter의 내용을 레디스에 푸시합니다
          pushTermCounterToRedis(tc);
      }

      // url 별 term 등장횟수를 담은 TermCounter를 레디스의 Set 형태로 전환
      public List&lt;Object&gt; pushTermCounterToRedis(TermCounter tc) {
          // jedis.multi()는 Jedis 객체의 모든 메서드를 제공하는 Transaction 객체를 반환
          Transaction t = jedis.multi();
          String url = tc.getLabel();
          String hashname = termCounterKey(url); // TermCounter : url
          // 페이지가 이미 인덱싱되어 있다면 기존 해시를 제거합니다
          t.del(hashname);
          // 각 검색어에 대해 TermCounter 에 엔트리와 인덱스의 새 멤버를 추가합니다.
          for (String term: tc.keySet()) {
              Integer count = tc.get(term);
              t.hset(hashname, term, count.toString()); //redis의 hash 자료구조에 추가
              t.sadd(urlSetKey(term), url); //redis의 set 자료구조에 추가 "URLSet: term"
          }
          List&lt;Object&gt; res = t.exec();    // 매번 서버와 통신하면 시간이 더 소요되므로 Transaction 동작을 모아뒀다 한꺼번에 적용
          return res;
      }
        
      private static void loadIndex(JedisIndex index) throws IOException {
          WikiFetcher wf = new WikiFetcher();

          String url = "https://en.wikipedia.org/wiki/Java_(programming_language)";
          Elements paragraphs = wf.readWikipedia(url);
          index.indexPage(url, paragraphs);

          url = "https://en.wikipedia.org/wiki/Programming_language";
          paragraphs = wf.readWikipedia(url);
          index.indexPage(url, paragraphs);
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>레디스 데이터베이스에서 각 객체는 string 형의 유일한 키로만 식별되므로 두 종류 이상의 객체(Index, TermCounter)가 있다면 이 둘을 구분할 수 있는 접두사를 추가해야 함
    <ul>
      <li>Set에 키를 “URLSet : 단어”, 값을 url 주소로 저장 =&gt; 특정 단어에 대한 url들의 Set</li>
      <li>Hash에 첫번째 키를 “TermCounter : url 주소”, 두번째 키를 단어, 값을 단어 등장 횟수로 저장 =&gt; 특정 url 주소 별 각 단어 등장 횟수 Map</li>
      <li>기존 Index 객체에서는 단어 별 TermCounter들의 집합을 인스턴스로 가졌으나 TermCounter는 각 페이지 별 단어들과 단어 등장횟수를 저장하므로 Index 객체에 의존할 필요가 없음</li>
    </ul>
  </li>
  <li>n개의 페이지 인덱싱 후 m개의 고유한 검색어를 검색 할 때 소요되는 시간 (getCounts)
    <ul>
      <li>HashMap을 생성 -&gt; getURL 메소드 호출하여 해당 단어를 포함한 URL 집합을 가져옴 -&gt; 집합에 있는 각 URL에 대해 getCount 메소드 호출하여 HashMap에 엔트리 추가</li>
      <li>getURL 메소드의 jedis.smembers는 Redis의 Set 자료구조에서 모든 요소를 가져오는 메서드로 단어에 해당하는 url들을 모두 순회함</li>
      <li>이후 반복문 안에서 해당 단어가 등장하는 url 개수만큼 getCount를 호출하는데 상수시간 연산이라 전체 복잡도는 최악의 상황에 n이 됨. 하지만 실제로 검색어를 포함한 페이지의 개수는 n보다 작은 경우가 많음</li>
    </ul>
  </li>
  <li>한 페이지를 인덱싱하는데 소요되는 시간 (indexPage)
    <ul>
      <li>페이지의 DOM 트리를 순회하고 모든 TextNode 객체를 찾고 문자열을 검색어로 쪼갬 =&gt; 소요 시간은 페이지의 단어 개수에 비례함</li>
    </ul>
  </li>
</ul>



    </div>

</article>
<div class="post-nav">
<a class="previous" href="/cs/2025/07/22/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-(%EC%9E%90%EB%B0%94%EC%9D%98-%EC%8B%A0-vol.1).html" title="자바 기초 정리 (자바의 신 vol.1)">자바 기초 정리 (자바의 신 vol.1)...</a><span></span>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li class="">
          <a class="post-link" href="/cs/2025/07/22/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-(%EC%9E%90%EB%B0%94%EC%9D%98-%EC%8B%A0-vol.1).html" title="자바 기초 정리 (자바의 신 vol.1)">
            자바 기초 정리 (자바의 신 vol.1)<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/investments/2025/06/07/%EB%89%B4%EC%9A%95%EC%A3%BC%EB%AF%BC%EC%9D%98-%EC%A7%84%EC%A7%9C-%EB%AF%B8%EA%B5%AD%EC%8B%9D-%EC%A3%BC%EC%8B%9D%ED%88%AC%EC%9E%90.html" title="뉴욕주민의 진짜 미국식 주식투자 : 내용 정리">
            뉴욕주민의 진짜 미국식 주식투자 : 내용 정리<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/cs/2025/01/01/SSE.html" title="SSE">
            SSE<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html" title="자바로 배우는 핵심 자료구조와 알고리즘">
            자바로 배우는 핵심 자료구조와 알고리즘<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Unpublished Work <span class="copyleft">©</span> 2017-2025 Toyo</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
