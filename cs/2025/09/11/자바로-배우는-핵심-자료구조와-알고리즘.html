<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>자바로 배우는 핵심 자료구조와 알고리즘 | Toyo.log</title>
<meta name="generator" content="Jekyll v4.4.1">
<meta property="og:title" content="자바로 배우는 핵심 자료구조와 알고리즘">
<meta name="author" content="Toyo">
<meta property="og:locale" content="en_US">
<meta name="description" content="1. 인터페이스 프로그래밍 java.util.List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List 인터페이스에 정의된 메소드는 ArrayList와 LinkedList 또는 List 인터페이스를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨 라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨">
<meta property="og:description" content="1. 인터페이스 프로그래밍 java.util.List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List 인터페이스에 정의된 메소드는 ArrayList와 LinkedList 또는 List 인터페이스를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨 라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨">
<link rel="canonical" href="/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html">
<meta property="og:url" content="/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html">
<meta property="og:site_name" content="Toyo.log">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2025-09-11T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="자바로 배우는 핵심 자료구조와 알고리즘">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Toyo"},"dateModified":"2025-09-11T00:00:00+00:00","datePublished":"2025-09-11T00:00:00+00:00","description":"1. 인터페이스 프로그래밍 java.util.List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List 인터페이스에 정의된 메소드는 ArrayList와 LinkedList 또는 List 인터페이스를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨 라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨","headline":"자바로 배우는 핵심 자료구조와 알고리즘","mainEntityOfPage":{"@type":"WebPage","@id":"/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"},"url":"/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="icon" href="">
  <link rel="canonical" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Toyo.log">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js" async></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  /*
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }
  */

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe-lightbox.umd.min.js" async></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe.umd.min.js" async></script>
<link href="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/photoswipe.min.css" rel="stylesheet">
<style>
  .pswp .pswp__container .pswp__img {
    background-color: white;
  }
</style>

<script>
  function initPhotoSwipe() {
    let customOptions = {};

    try {
      const data = ``.replaceAll("=>", ":");
      customOptions = JSON.parse(data);
    } catch (e) {
      console.info("Invalid custom photo previewer options! " + e.message);
    }

    // Define object and gallery options
    const options = Object.assign(
      {
        gallery: "section.main",
        children: "a.photo-swipe",
        photo_scale: 2,
        // dynamic import is not supported in UMD version
        pswpModule: PhotoSwipe,
      },
      customOptions
    );

    const galleryEl = document.querySelector(options.gallery);
    if (!galleryEl) {
      return;
    }

    const imgEls = [];
    const els = galleryEl.querySelectorAll("img:not(.emoji)");
    els.forEach((el) => {
      if (el.src.trim() == "") {
        return;
      }
      if (!imgEls.includes(el)) {
        imgEls.push(el);
      }
    });

    if (imgEls.length === 0) {
      return;
    }

    imgEls.forEach((imgEl) => {
      imgEl.outerHTML = `
      <a class="photo-swipe"
        href="${imgEl.src}"
        data-pswp-width="${
          Math.max(imgEl.naturalWidth, imgEl.width) * options.photo_scale
        }"
        data-pswp-height="${
          Math.max(imgEl.naturalHeight, imgEl.height) * options.photo_scale
        }"
        data-pswp-caption="${imgEl.getAttribute("caption") || imgEl.alt}"
        target="_blank">
        ${imgEl.outerHTML}
      </a>`;
    });

    // Initialize PhotoSwipe 5
    var lightbox = new PhotoSwipeLightbox(options);

    lightbox.init();
  }

  window.addEventListener("load", initPhotoSwipe);
</script>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Toyo.log" src="" onerror="this.style.display='none'">
  Toyo.log
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/categories.html">CATEGORIES</a><a class="page-link" href="/">HOME</a><a class="page-link" href="/tags.html">TAGS</a>









<div class="page-link" style="display: inline;">



<div id="google_translate_element" style="display: none;">
</div>

<div class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</div>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'en',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit" async></script>
</div>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('light' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">자바로 배우는 핵심 자료구조와 알고리즘</h1>
  <h2 class="post-subtitle">자료구조/알고리즘 정리</h2>

  <div class="post-meta">
    <time class="dt-published" datetime="2025-09-11T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Sep 11, 2025
    </time>
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 47 mins</span>
  </div>
<div class="post-tags">
<a class="post-tag" href="/tags.html#java">#java</a><a class="post-tag" href="/tags.html#%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0">#자료구조</a><a class="post-tag" href="/tags.html#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">#알고리즘</a>
</div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="1-인터페이스-프로그래밍">1. 인터페이스 프로그래밍</h2>
<ul>
  <li>java.util.List 인터페이스를 구현하는 클래스는 add, get, remove와 약 20 가지 메서드를 포함한 특정 메서드 집합을 동일하게 제공하므로 상호 교환 가능. List 인터페이스에 정의된 메소드는 ArrayList와 LinkedList 또는 List 인터페이스를 구현하는 어떤 객체와도 잘 동작하며, 구현을 변경하고 싶을 경우 생성자 부분만 변경해주면 됨</li>
  <li>라이브러리를 사용할 때 코드는 오직 List와 같은 인터페이스만 의존하고 ArrayList 클래스와 같은 특정 구현에 의존해서는 안됨</li>
</ul>

<h2 id="2-빅오-표기법">2. 빅오 표기법</h2>
<ul>
  <li>알고리즘의 성능(시간 혹은 공간 복잡도)을 입력 크기 n에 따라 표현하는 수학적 표기법</li>
  <li>전체 코드 구현 이전에 컴퓨터의 성능에 구애받지 않고 알고리즘의 소요 시간을 정량화하기 위해 입력 크기에 따른 증가율을 비교함</li>
  <li>입력 크기가 커질수록 알고리즘 간 성능 차이가 커지므로, 분석은 대규모 입력에 초점을 맞춰야 함. 빅오 표기법은 이러한 상황에서 알고리즘의 최악의 실행 시간을 표현하여 성능을 평가하는 데 사용</li>
  <li>실행 속도 O(1) &lt; O(log N) &lt; O(N) &lt; O(N log N) &lt; O(N^2) &lt; O(2^N)</li>
</ul>

<h2 id="3-arraylist">3. ArrayList</h2>
<ul>
  <li>java.util.ArrayList 클래스는 java.util.List 인터페이스의 구현 클래스 중 하나. List 인터페이스 문서에 정의된 add, gets, rem, set, indexOf, equals 메소드 규칙을 참고하여 ArrayList 클래스와 유사한 MyArrayList 클래스를 작성해보면 아래와 같음
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class MyArrayList&lt;T&gt; implements List&lt;T&gt; {
      int size;
      private T[] array;

      @Override
      public boolean add(T element) {
          if (size &gt;= array.length) {
              // 배열의 전체 크기보다 더 많은 값이 삽입되면 크기가 그 2배인 배열을 다시 생성, 기존값 복사
              // 자바에선 타입 파라미터(T)로 배열을 초기화할 수 없으므로 Object 배열 생성 후 형변환
              E[] bigger = (T[]) new Object[array.length * 2];
              System.arraycopy(array, 0, bigger, 0, array.length);
              array = bigger;
          }
          array[size] = element;
          size++;
          return true;
      }

      @Override
      public void add(int index, T element) {
          if (index &lt; 0 || index &gt; size) {
              throw new IndexOutOfBoundsException();
          }
          add(element);

          // shift the elements
          for (int i=size-1; i&gt;index; i--) {
              array[i] = array[i-1];
          }
          // put the new one in the right place
          array[index] = element;
      }

      @Override
      public T get(int index) {
          if (index &lt; 0 || index &gt;= size) {
              throw new IndexOutOfBoundsException();
          }
          return array[index];
      }

      @Override
      public T set(int index, T element) {
          E old = get(index);
          array[index] = element;
          return old;
      }

      @Override
      public int indexOf(Object target) {
          for (int i = 0; i &lt; size; i++) {
              if (equals(target, array[i])) return i;
          }
          return -1;
      }

      private boolean equals(Object target, Object element) {
          if (target == null) {
              return element == null;
          } else {
              //Object 객체의 equals 메소드를 호출하여 실제 객체에서 재정의한 equals 메소드가 호출됨 
              return target.equals(element);
          }
      }

      @Override
      public boolean remove(Object obj) {
          int index = indexOf(obj);
          if (index == -1) {
              return false;
          }
          remove(index);
          return true;
      }

      @Override
      public T remove(int index) {
          E element = get(index);
          for (int i=index; i &lt; size-1; i++) {
              array[i] = array[i+1];
          }
          size--;
          return element;
      }

      ...

</code></pre></div>    </div>
  </li>
  <li>get, set, indexOf, equals, remove 메소드의 시간 복잡도는 각각 상수, 상수, 선형, 상수, 선형임</li>
  <li>add(T element) 메소드의 시간 복잡도를 계산하기 위해 크기가 2인 배열에 n개 요소를 추가할 때의 평균 연산 횟수를 고려하면
    <ul>
      <li>1~2번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장</li>
      <li>3번째 호출 : 기존의 2배 크기(=4)를 가진 배열을 생성하여 기존 요소 2개를 복사하고 요소 저장</li>
      <li>4번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장</li>
      <li>5번째 호출 : 기존의 2배 크기(=8)를 가진 배열을 생성하여 기존 요소 4개를 복사하고 요소 저장</li>
      <li>6~8번째 호출 : 배열에서 사용하지 않는 공간을 찾아 요소 저장</li>
      <li>위의 패턴 반복</li>
    </ul>
  </li>
  <li>결과적으로 n번 추가하면 요소 총 n개를 저장하고 총 n-2개를 복사함. 따라서 총 연산 횟수는 2n-2이고, 평균 횟수는 n으로 나누어 2-2/n이 됨</li>
  <li>n이 커질수록 두 번째 항인 2/n는 작아지므로 add(T element) 메소드는 상수 시간으로 간주됨</li>
  <li>일련의 호출에서 평균 시간을 계산하는 알고리즘 분류 방법을 <strong>분할 상환 분석</strong>이라고 함. 핵심 개념은 배열의 크기를 조정할 때마다 배열의 길이가 2배로 늘어나 각 요소를 복사하는 횟수를 제한한다는 것. 매번 고정된 양을 더해서 크기를 늘리는 대신 곱하여 연산 횟수를 더 제한함</li>
  <li>이어서 removeAll 메소드를 구현하면 아래와 같음
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  @Override
  public boolean removeAll(Collection&lt;?&gt; collection) {
      boolean flag = true;
      for (Object obj: collection) {
          flag &amp;= remove(obj);
      }
      return flag;
  }
</code></pre></div>    </div>
  </li>
  <li>반복문을 돌리며 선형인 remove 메소드를 호출하고 있지만 collection 크기가 n에 비례하지 않는다면 이차가 아님</li>
</ul>

<h2 id="4-단일-연결-리스트-linkedlist">4. 단일 연결 리스트 (LinkedList)</h2>
<ul>
  <li>연결 리스트에서 각 노드는 리스트의 다음 노드에 대한 참조를 포함. 연결 구조의 다른 예로는 트리와 그래프가 있음</li>
  <li>java.util.List 인터페이스를 상속받아 MyLinkedList를 직접 구현
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class MyLinkedList&lt;E&gt; implements List&lt;E&gt; {

      private class Node {
          public E data;
          public Node next;

          public Node(E data) {
              this.data = data;
              this.next = null;
          }
      }

      private int size;            // 요소 더하거나 제거할 때마다 갱신
      private Node head;           // 리스트의 첫 번째 노드 참조. 빈 리스트이면 null

      public MyLinkedList() {
          head = null;
          size = 0;
      }

      @Override
      public boolean add(E element) {
          if (head == null) {
              head = new Node(element);
          } else {
              Node node = head;
              for ( ; node.next != null; node = node.next) {}
              node.next = new Node(element);
          }
          size++;
          return true;
      }

      @Override
      public void clear() {
          head = null;
          size = 0;
      }
</code></pre></div>    </div>
  </li>
  <li>LinkedList는 ArrayList와 달리 리스트 자체가 파괴되지 않아도 요소를 제거하면 리스트 크기가 줄어들고 사용하지 않는 노드는 즉시 가비지 컬렉션이 될 수 있다는 장점이 있음</li>
  <li>add 메소드는 리스트의 끝까지 이동해야 하므로 선형 증가차수를 가짐</li>
  <li>clear 메소드로 LinkedList의 첫 번째 노드 참조를 제거할 경우에는 순차적으로 연결리스트의 각 노드들에 대한 참조가 사라지게 되어 가비지 컬렉션이 선형이 됨
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>      private boolean equals(Object target, Object element) {
          if (target == null) {
              return element == null;
          } else {
              return target.equals(element);  //Object를 오버라이드 한 target의 실제 equals 메소드 호출
          }
      }

      @Override
      public int indexOf(Object target) {
          Node node = head;
          for (int i=0; i &lt; size; i++){
              if (equals(target, node.data)) {
                  return i;
              }
              node = node.next;
          }
          return -1;
      }

      private Node getNode(int index) {
          if (index &lt; 0 || index &gt;= size) {
              throw new IndexOutOfBoundsException();
          }
          Node node = head;
          for (int i=0; i&lt;index; i++) {
              node = node.next;
          }
          return node;
      }

      @Override
      public E get(int index) {
          Node node = getNode(index);
          return node.data;
      }

      @Override
      public void add(int index, E element) {
          if (index == 0) {
              head = new Node(element, head);
          } else {
              Node node = getNode(index - 1);
              node.next = new Node(element, node.next);
          }
          size++;
      }

      @Override
      public E remove(int index) {
          E element = get(index);
          if (index == 0) {
              head = head.next;
          } else {
              Node node = getNode(index-1);
              node.next = node.next.next;
          }
          size--;
          return element;
      }
</code></pre></div>    </div>
  </li>
  <li>indexOf는 선형, remove와 add(int index, E element)도 index가 0인 특별한 경우를 제외하고 getNode가 선형이므로 선형</li>
  <li>MyArrayList 클래스는 끝에 추가하고 끝에서 제거할 때와 get/set 메서드 연산에 이점이 있으며, MyLinkedList 클래스는 시작에 추가하고 시작에서 제거하는 연산에 이점이 있음. 다른 연산에서는 증가 차수가 같음</li>
  <li>ArrayList 끝에 새로운 요소를 추가하는 실행 시간 측정 테스트
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public static void profileArrayListAddEnd() {
      Timeable timeable = new Timeable() {
          List&lt;String&gt; list;

          // 초기 설정: ArrayList 사용
          public void setup(int n) {
              list = new ArrayList&lt;String&gt;();
          }

          // 테스트 내용: 리스트 맨 앞에 n개의 요소를 추가
          public void timeMe(int n) {
              for (int i = 0; i &lt; n; i++) {
                  list.add("a string");
              }
          }
      };
      int startN = 4000;  // 몇 번 추가할지에 대한 n값
      int endMillis = 1000;   // timingLoop 테스트 실행시간
      runProfiler("ArrayList add first", timeable, startN, endMillis);
  }

  private static void runProfiler(String title, Timeable timeable, int startN, int endMillis) {
      Profiler profiler = new Profiler(title, timeable);
      XYSeries series = profiler.timingLoop(startN, endMillis);
      profiler.plotResults(series);
  }
</code></pre></div>    </div>
    <ul>
      <li>리스트 맨 앞에 n개의 요소를 추가하는 시간 측정 테스트 수행. 테스트에 사용되는 Profiler, Timeable 클래스는 교재의 별도 코드 참고</li>
      <li>테스트 결과 : endMillis 동안 루프를 돌며 2배식 증가되는 startN과, 해당 startN에서 10회 씩 timeMe를 수행한 총 소요 시간 출력
        <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  4000, 3
  8000, 0
  16000, 1
  32000, 2
  64000, 3
  128000, 6
  256000, 18
  512000, 30
  1024000, 8
  2048000, 185
  4096000, 242
  8192000, 544
  16384000, 1325
</code></pre></div>        </div>
      </li>
      <li>테스트 수행 결과 그래프가 a + bn (직선)이 되는 것 확인 가능. a는 Y 절편, b는 기울기</li>
      <li>plotResults 메소드는 테스트 수행 결과를 그래프로 출력</li>
      <li>측정에 잡음이 많으면 그래프 차이를 확인하기 어려우므로 이차 이상은 log-log 스케일을 적용해 직선 그래프 간의 기울기의 차이를 확인할 수 있음. 기울기가 1에 가까우면 선형, 2에 가까우면 이차로 봐야함</li>
      <li>timeMe 메소드를 ArrayList 맨 앞에 n개의 새로운 요소를 추가하도록 수정하면 전체시간은 이차가 되며, log-log 스케일을 적용했을때 기울기가 2에 가까워짐</li>
      <li>MyLinkedList 클래스를 이용하여 시작과 끝에 n개의 새로운 요소를 추가하도록 수정하면 둘다 1에 가까운 기울기가 출력됨</li>
    </ul>
  </li>
</ul>

<h2 id="5-이중-연결-리스트">5. 이중 연결 리스트</h2>
<ul>
  <li>앞서 구현한 단일 연결 리스트인 MyLinkedList와 달리 java.util.LinkedList 클래스는 이중 연결 리스트로 아래와 같은 특징이 있음
    <ul>
      <li>각 노드는 다음 노드와 이전 노드의 참조를 포함</li>
      <li>LinkedList 객체는 첫번째와 마지막 요소에 대한 참조를 포함</li>
    </ul>
  </li>
  <li>
    <p>ArrayList, 단일 연결 리스트, 이중 연결 리스트 성능 비교</p>

    <table>
      <thead>
        <tr>
          <th style="text-align: left">구분</th>
          <th style="text-align: center">ArrayList</th>
          <th style="text-align: center">MyLinkedList</th>
          <th style="text-align: center">LinkedList</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td style="text-align: left">add(끝)</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">add(시작)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">add(일반적으로)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
        <tr>
          <td style="text-align: left">get/set</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
        <tr>
          <td style="text-align: left">indexOf/lastIndexOf</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
        <tr>
          <td style="text-align: left">isEmpty/size</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">remove(끝)</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">remove(시작)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
        </tr>
        <tr>
          <td style="text-align: left">remove(일반적으로)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>ArrayList 클래스는 get/set 메서드에서 유일하게 연결 리스트보다 나은 성능을 보임</li>
  <li>반대로 실행시간이 시작이나 끝 근처에 요소를 추가하거나 제거하는 연산에 의존한다면 LinkedList 클래스가 좋음</li>
  <li>단, 이러한 연산이 프로그램의 실행시간에 뚜렷한 영향을 미치지 않는다면 List 구현에 대한 선택은 큰 의미가 없음</li>
  <li>또한 리스트가 충분히 크지 않으면 위의 성능표에 있는 성능차이는 해당되지 않으며 공간면에서는 ArrayList가 참조가 차지하는 공간이 적어 연결리스트보다 효율이 높음</li>
</ul>

<h2 id="6-트리-순회">6. 트리 순회</h2>

<h3 id="61-웹-크롤러-구현을-위한-dfs-트리-순회">6.1 웹 크롤러 구현을 위한 DFS 트리 순회</h3>
<ul>
  <li>웹 크롤러가 HTML 페이지를 다운로드하고 파싱해 본문과 링크를 추출하도록 하기 위해 jsoup 라이브러리를 사용</li>
  <li>jsoup은 HTML 문서를 노드 기반 연결 자료구조인 DOM 트리 형태로 표현하며, 이 트리 구조는 깊이 우선 탐색(DFS)을 수행하기에 적합함
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class WikiNodeExample {
      public static void main(String[] args) throws IOException {
          String url = "https://en.wikipedia.org/wiki/Java_(programming_language)";
            
          //String 타입의 URL을 인자로 받아 웹 서버에 접속
          Connection conn = Jsoup.connect(url);
          //get 메소드는 HTML 을 다운로드하여 파싱하고 DOM 트리를 나타내는 Document 객체를 반환
          Document doc = conn.get();
            
          Element content = doc.getElementById("mw-content-text");
          Elements paras = content.select("p");
          Element firstPara = paras.get(0);
		
          //재귀적 방법을 사용한 DOM 트리 깊이 우선 탐색
          recursiveDFS(firstPara);
          System.out.println();

          //반복적 방법을 사용한 DOM 트리 깊이 우선 탐색
          iterativeDFS(firstPara);
          System.out.println();
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="62-dfs로-트리를-순회하는-2가지-방법">6.2 DFS로 트리를 순회하는 2가지 방법</h3>

<h4 id="621-재귀적-방법을-사용한-트리-순회">6.2.1 재귀적 방법을 사용한 트리 순회</h4>
<ul>
  <li>자식 노드를 탐색하기에 앞서 각 TextNode의 내용을 출력하는 전위 순회 방식
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  private static void recursiveDFS(Node node) {
      if (node instanceof TextNode) {
          System.out.print(node);
      }
      for (Node child: node.childNodes()) {
          recursiveDFS(child);
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="622-반복적-방법을-사용한-트리-순회--스택-사용">6.2.2 반복적 방법을 사용한 트리 순회 : 스택 사용</h4>
<ul>
  <li>스택 자료구조는 push, pop, peek, isEmpty 등 List의 일부 기능만 제공하지만 단순하여 코드 가독성을 높이고 오류 발생 가능성을 줄임. 또한 API가 적으면 효율적으로 구현하기가 더 쉬워짐</li>
  <li>자바로 스택 구현 시 기존 ArrayList나 LinkedList 클래스를 사용하면 잘못된 위치에 추가하거나 잘못된 순서로 제거하는 실수가 발생할 수 있고, 자바의 Stack 클래스는 오래된 버전이라 최근 JCF와 일치하지 않으므로 ArrayDeque같은 Deque 인터페이스를 구현한 클래스를 사용하는 편이 좋음</li>
  <li>Deque는 양쪽에 끝이 있는 큐로, 자바에서 Deque 인터페이스는 push 와 pop, peek, isEmpty 메서드를 제공하므로 스택으로 구현할 수 있음
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  private static void iterativeDFS(Node root) {
      Deque&lt;Node&gt; stack = new ArrayDeque&lt;Node&gt;();
      stack.push(root);

      while (!stack.isEmpty()) {
          Node node = stack.pop();
          if (node instanceof TextNode) {
              System.out.print(node);
          }

          // 후입선출이므로 역순으로 삽입
          List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;(node.childNodes());
          Collections.reverse(nodes);
			
          for (Node child: nodes) {
              stack.push(child);
          }
      }
  }
</code></pre></div>    </div>
  </li>
  <li>반복적 DFS가 재귀적 DFS보다 Iterator 인터페이스(hasNext(), next())로 래핑하기가 용이해 외부에서 순회 제어하기가 더 쉬움</li>
  <li>웹 크롤러를 이용한 철학으로 가는 길 예제 (교재 확인 시 참고용)
    <ul>
      <li>ArrayDeque 스택을 가지고 DOM 트리를 탐색하는 Iterable 구현 클래스 WikiNodeIterable</li>
      <li>jsoup 라이브러리를 활용하여 위키피디아 페이지를 다운로드하는 WikiFetcher 클래스</li>
      <li>WikiNodeIterable을 사용해 페이지의 첫 번째 유효링크를 파싱하는 WikiParser 클래스</li>
      <li>WikiParser와 WikiFetcher을 사용하여 주어진 위키피디아 페이지에서 시작해 첫 번째 링크를 따라가며 목표 페이지에 도달하거나 제한 횟수·사이클·막다른 길에 걸릴 때까지 탐색하는 WikiPhilosophy 클래스</li>
    </ul>
  </li>
</ul>

<h2 id="7-map">7. Map</h2>

<h3 id="71-map-set과-인덱서">7.1 Map, Set과 인덱서</h3>
<ul>
  <li>인덱서는 검색어를 바탕으로 관련 페이지를 찾을 수 있게 하는 자료구조. 검색어가 각 페이지에 몇 번씩 등장하는지를 기록해 가장 관련성이 높은 페이지 식별</li>
  <li>List<page> 같은 페이지의 컬렉션 형태보다는 키에 해당하는 값을 빠르게 찾을 수 있는 Map이 더 적절함</page>
</li>
  <li>검색어와 검색어가 등장하는 페이지의 컬렉션을 매핑하는 Index 라는 클래스, 해당 페이지의 단어 별 등장 횟수를 매핑하는 Termcounter 클래스 구현</li>
  <li>검색어별로 등장하는 페이지를 모아두면, 여러 검색어를 동시에 찾을 때는 교집합 연산으로 공통 페이지를 구해야 함</li>
  <li>Set은 기본적으로 중복 없는 집합 구조로, TermCounter의 equals()와 hashCode() 메소드를 label로 비교하도록 재정의할 경우 페이지 별로 유일하며 교집합 같은 연산을 효율적으로 구현할 수 있는 메소드를 제공해 페이지 별 데이터를 저장하는데 적합함</li>
  <li>Index 클래스는 단어 문자열을 key, TermCounter 객체들의 Set을 value로 가지는 Map을 보유하여 특정 검색어에 대한 페이지별 등장횟수(TermCounter)를 제공
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class Index {
      private Map&lt;String, Set&lt;TermCounter&gt;&gt; index = new HashMap&lt;String, Set&lt;TermCounter&gt;&gt;();
      ...
  }
</code></pre></div>    </div>
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class TermCounter {

      private Map&lt;String, Integer&gt; map; //해당 페이지에서 해당 단어가 등장하는 횟수 매핑
      private String label; //페이지의 url

      public TermCounter(String label) {
          this.label = label;
          this.map = new HashMap&lt;String, Integer&gt;();
      }
        
      public void processElements(Elements paragraphs) {
          for (Node node: paragraphs) {
              processTree(node);
          }
      }

      public void processTree(Node root) {
          // NOTE: we could use select to find the TextNodes, but since
          // we already have a tree iterator, let's use it.
          for (Node node: new WikiNodeIterable(root)) {
              if (node instanceof TextNode) {
                  processText(((TextNode) node).text());
              }
          }
      }

      public void processText(String text) {
          // replace punctuation with spaces, convert to lower case, and split on whitespace
          String[] array = text.replaceAll("\\pP", " ").
                              toLowerCase().
                              split("\\s+");
            
          for (int i=0; i&lt;array.length; i++) {
              String term = array[i];
              incrementTermCount(term);
          }
      }

      public void incrementTermCount(String term) {
          // System.out.println(term);
          put(term, get(term) + 1);
      }

      public void put(String term, int count) {
          map.put(term, count);
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>TermCounter는 jsoup 라이브러리의 Element 객체 컬렉션인 Elements 객체를 쪼개 단어별 등장 횟수를 카운트하는 processElement, processTree, processText 메소드 제공. processTree는 Element 객체의 DOM 트리를 탐색하기 위해 앞서 정의된 WikiNodeIterable 클래스를 사용함</li>
  <li>자바 Map 인터페이스 구현 클래스로는 HashMap, TreeMap 클래스, Set 인터페이스 구현 클래스로는 HashSet과 TreeSet 클래스가 있음</li>
</ul>

<h3 id="72-map-인터페이스-구현">7.2 Map 인터페이스 구현</h3>
<ul>
  <li>java.util.Map 인터페이스 문서의 메소드 정의를 참고하여 해당 인터페이스를 구현한 MyLinearMap 클래스 작성
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class MyLinearMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

      private List&lt;Entry&gt; entries = new ArrayList&lt;Entry&gt;();

      public class Entry implements Map.Entry&lt;K, V&gt; {
          private K key;
          private V value;

          public Entry(K key, V value) {
              this.key = key;
              this.value = value;
          }
      }

      private Entry findEntry(Object target) {
          for (Entry entry: entries) {
              if (equals(target, entry.getKey())) {
                  return entry;
              }
          }
          return null;
      }

      private boolean equals(Object target, Object obj) {
          if (target == null) {
              return obj == null;
          }
          return target.equals(obj);
      }

      @Override
      public V get(Object key) {
          Entry entry = findEntry(key);
          if (entry == null) return null;
          return entry.getValue();
      }

      @Override
      public V put(K key, V value) {
          Entry entry = findEntry (key)
          if (entry == null){
              entries.add(new Entry(key, value));
          } else {
              V oldValue = entry.getValue();
              entry.setValue(value);
              return oldValue;
          }
      }

      @Override
      public V remove(Object key) {
          Entry entry = findEntry(key);
          if (entry == null) {
              return null;
          } else {
              V value = entry.getValue();
              entries.remove(entry);
              return value;
          }
      }

      @Override
      public void clear() {
          entries.clear();
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>Entry 클래스는 단지 키와 값의 컨테이너로 이 정의는 MyLinearMap 클래스에 중첩되어 있으므로 같은 타입 파라미터인 K와 V를 사용</li>
  <li>equals는 상수시간, findEntry가 선형이므로 put과 get도 선형, remove는 ArrayList 시작이나 중간에서 삭제할경우 요소를 이동해야하지만 2번의 선형 연산이므로 마찬가지로 선형</li>
  <li>해시코드를 사용하면 Map의 증가차수를 더 개선할 수 있음</li>
</ul>

<h3 id="73-hashmap">7.3 HashMap</h3>
<ul>
  <li>Entry 대신 MyLinearMap(Entry List)의 List 컬랙션 사용</li>
  <li>키를 확인하여 어느 내장 Map에 투입할지 결정하기 위해 해시 함수 chooseMap 사용. 이 함수는 0bject 객체를 인자로
받아 해시 코드라는 정수를 반환하는데, 중요한 점은 같은 0bject 객체에 대해서는 항상 같은 해시 코드를 반환해야 함</li>
  <li>자바에서 모든 0bject 객체는 hashCode 라는 메소드를 제공하여 해시 함수를 계산하며, 메서드의 구현은 객체의 종류에 따라 달라짐</li>
  <li>하나의 Map이 여러 MyLinearMap으로 쪼개지는 만큼 탐색해야 하는 각 맵의 엔트리 개수는 더 줄어드므로 FindEntry 메서드와 그것을 호출하는 메서드의 속도가 더 빨라짐
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class MyBetterMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

      protected List&lt;MyLinearMap&lt;K, V&gt;&gt; maps;

      public MyBetterMap() {
          makeMaps(2);
      }

      protected void makeMaps(int k) {
          maps = new ArrayList&lt;MyLinearMap&lt;K, V&gt;&gt;(k);
          for (int i=0; i&lt;k; i++) {
              maps.add(new MyLinearMap&lt;K, V&gt;());
          }
      }

      protected MyLinearMap&lt;K, V&gt; chooseMap(Object key) {
          //ath.abs 메서드를 호출하여 절대값을 만들고 %를 사용하여 결과가 0 에서 map.size()-1 사이에 있음을 보장
          int index = key==null ? 0 : Math.abs(key.hashCode()) % maps.size();
          return maps.get(index);
      }

      @Override
      public V get(Object key) {
          MyLinearMap&lt;K, V&gt; map = chooseMap(key);
          return map.get(key);
      }

      @Override
      public V put(K key, V value) {
          MyLinearMap&lt;K, V&gt; map = chooseMap(key);
          return map.put(key, value);
      }

      @Override
      public int size() {
          // add up the sizes of the sub-maps
          int total = 0;
          for (MyLinearMap&lt;K, V&gt; map: maps) {
              total += map.size();
          }
          return total;
      }

      @Override
      public void clear() {
          // clear the sub-maps
          for (int i=0; i&lt;maps.size(); i++) {
              maps.get(i).clear();
          }
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>탐색해야 할 Map 당 Entry가 n/k개로 줄어들지만 chooseMap을 호출하는 get, put 메소드의 성능은 여전히 n에 비례함</li>
  <li>하지만 n과 함께 k를 늘려간다면 n/k의 크기를 제한할 수 있음. 3. ArrayList의 분할상환방식에서 확인한 것처럼 매번 n이 k를 초과할 때 k를 두 배로 늘린다면 put을 상수시간으로 줄일 수 있음. 또한 하위 맵당 엔트리의 개수가 일정하면 단일 하위 맵은 상수 시간으로 검색할 수 있음</li>
  <li>MyBetterMap에서 각 맵의 크기는 ArrayList에 의존하여 자동으로 증가하므로 FACTOR 값만큼 맵 당 최대 엔트리 개수를 제한하고 요소가 새로 추가되면 내장 Map을 새로 생성</li>
  <li>앞서 정의한 MyBetterMap을 상속받아 HashMap 정의
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class MyHashMap&lt;K, V&gt; extends MyBetterMap&lt;K, V&gt; implements Map&lt;K, V&gt; {

      protected static final double FACTOR = 1.0; //하위 맵당 최대 엔트리 개수

      @Override
      public V put(K key, V value) {
          V oldValue = super.put(key, value);

          //size() : 엔트리의 전체 개수인 n
          //maps.size() : 내장된 map의 개수인 k
          if (size() &gt; maps.size() * FACTOR) {
              rehash();
          }
          return oldValue;
      }
  }
</code></pre></div>    </div>
  </li>
  <li>put 메소드만 새로 재정의하여 MyBetterMap의 put 메소드를 호출하고 재해시가 필요한지 확인</li>
  <li>n 〉 k * FACTOR면 하위 맵당 엔트리의 개수가 임계치를 초과함을 의미하므로 rehash 메서드를 호출. rehash 메서드가 호출될 때마다 내장된 맵의 개수 k는 두 배가 됨</li>
  <li>맵 당 엔트리 개수가 제한됨으로서 get, containsKey, remove 메소드는 자동으로 상수시간이 됨</li>
  <li>그러나 size 메소드가 여전히 선형이므로 대신 size 인스턴스 변수를 추가하여 put, remove 메소드에서 관리
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  ...
  private int size = 0;

  @Override
  public V remove(Object key) {
      MyLinearMap&lt;K, V&gt; map = chooseMap(key);
      size -= map.size();
      V oldValue = map.remove(key);
      size += map.size();
      return oldValue;
  }

  @Override
  public V put(K key, V value) {
      MyLinearMap&lt;K, V› map = chooseMap(key);
      size -= map.size();
      V oldValue = map.put(key, value);
      size += map.size();
      if (size() 〉 maps.size() * FACTOR) {
          size = 0;
          rehash();
      }
      return oldValue;
  }

  @Override
  public int size() {
      return size;
  }

  @Override
  public void clear() {
      super.clear();
      size = 0;
  }
  ...
</code></pre></div>    </div>
  </li>
  <li>size 메소드가 상수시간이 되어 put 메소드도 자동으로 상수시간이 됨</li>
  <li>MyBetterMap에서 clear 메소드는 오히려 선형이 되었지만 자주 사용되지 않는 함수라 감안할 만함</li>
  <li>많은 객체가 동일한 해시 코드를 갖는다면 결국 같은 하위 맵으로 몰리게 되고, k개의 하위 맵으로 인한 성능 향상은 k보다 줄어들게 됨. 따라서 해시 함수는 해시코드를 균등하게 분배해야 함</li>
  <li>해싱을 사용하는 자료구조에서 가변 객체를 키로 사용하는 것은 위험함. 키가 맵에 있는 동안 키 값이 변경되면 해당 값을 찾지 못하게 됨</li>
  <li>equals()가 true인 객체들은 반드시 hashCode() 결과값이 동일해야 해시 기반 컬렉션에서 올바르게 동작함</li>
</ul>

<h3 id="74-treemap">7.4 TreeMap</h3>
<ul>
  <li>HashMap은 널리 사용되지만 상수시간이라도 상수가 상당히 커지거나, 하위 맵에 고르게 키를 분배하는 좋은 해시 함수를 설계하는게 어렵거나, 저장되는 데이터에 순서가 없다는 문제점이 있음</li>
  <li>TreeMap은 해싱을 사용하지 않으며 이진 탐색 트리에 키를 저장하므로 키를 선형 시간으로 순서대로 조회할 수 있음. 또한 핵심 메소드의 실행시간이 log n에 비례하여 쓸만함</li>
  <li>이진 탐색 트리는 아래와 같은 속성이 있음
    <ul>
      <li>노드 왼쪽에 자식이 있다면 왼쪽 하위 트리의 모든 키는 노드에 있는 키보다 작음</li>
      <li>노드 오른쪽에 자식이 있다면 오른쪽 하위 트리의 모든 키는 노드에 있는 키보다 큼</li>
      <li>따라서 검색할 때 트리 전체를 탐색할 필요 없이 트리의 각 수준에서 한개의 자식노드만 찾으면 됨. 이는 트리의 높이인 log n에 비례함
        <ul>
          <li>이진 트리의 높이 별 총 노드 개수는 n = 2^h - 1이므로, log를 씌우면 log n ≈ h</li>
        </ul>
      </li>
      <li>위의 조건들을 만족할 뿐 기본적으로는 균형있는 이진트리를 보장하진 않음</li>
    </ul>
  </li>
  <li>이진 탐색 트리로 Map 인터페이스를 구현하면 아래와 같음
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class MyTreeMap&lt;K, V&gt; implements Map&lt;K, V&gt; {
      private int size = 0;
      private Node root = null;

      protected class Node {
          public K key;
          public V value;
          public Node left = null;
          public Node right = null;

          public Node(K key, V value) {
              this.key = key;
              this.value = value;
          }
      }

      @Override
      public void clear() {
          size = 0;
          root = null;
      }

      @Override
      public boolean containsKey(Object target) {
          return findNode(target) != null;
      }

      private Node findNode(Object target) {
          if (target == null) {
              throw new IllegalArgumentException();
          }

          // key와 비교하기 위해 Object -&gt; Key 타입으로 형변환
          // Map 인터페이스 규약에 따르면 containsKey의 파라미터 타입은 Object
          @SuppressWarnings("unchecked")
          Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) target;

          Node node = root;
          while (node != null)
          {
              int cmp = k.compareTo(node.key);
              if (cmp &lt; 0)
                  node = node.left;
              else if (cmp &gt; 0)
                  node = node.right;
              else
                  return node;
          }
          return null;
      }

      private boolean equals(Object target, Object obj) {
          if (target == null) {
              return obj == null;
          }
          return target.equals(obj);
      }

      @Override
      public boolean containsValue(Object target) {
          return containsValueHelper(root, target);
      }

      private boolean containsValueHelper(Node node, Object target) {
          if (node == null) {
              return false;
          }
          if (equals(target, node.value)) {
              return true;
          }
          if (containsValueHelper(node.left, target)) {
              return true;
          }
          if (containsValueHelper(node.right, target)) {
              return true;
          }
          return false;
      }

      @Override
      public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {
          throw new UnsupportedOperationException();
      }

      @Override
      public V get(Object key) {
          Node node = findNode(key);
          if (node == null) {
              return null;
          }
          return node.value;
      }

      @Override
      public Set&lt;K&gt; keySet() {
          Set&lt;K&gt; set = new LinkedHashSet&lt;K&gt;();
          addInOrder(root, set);
          return set;
      }

      private void addInOrder(Node node, Set&lt;K&gt; set) {
          if(node == null) return;
          addInOrder(node.left, set);
          set.add(node.key);
          addInOrder(node.right, set);
      }

      @Override
      public V put(K key, V value) {
          if (key == null) {
              throw new NullPointerException();
          }
          if (root == null) {
              root = new Node(key, value);
              size++;
              return null;
          }
          return putHelper(root, key, value);
      }

      private V putHelper(Node node, K key, V value) {
          Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
          int cmp = k.compareTo(node.key);

          //리프 노드를 찾아서 키를 비교하여 크기에 따라 오른쪽/왼쪽 자식 노드로 추가
          if (cmp &lt; 0) {
              if (node.left == null) {
                  node.left = new Node(key, value);
                  size++;
                  return null;
              }
              else {
                  return putHelper(node.left, key, value);
              }
          }
          if (cmp &gt; 0) {
              if (node.right == null) {
                  node.right = new Node(key, value);
                  size++;
                  return null;
              }
              else {
                  return putHelper(node.right, key, value);
              }
          }
          V oldValue = node.value;
          node.value = value;
          return oldValue;
      }

      @Override
      public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
          for (Map.Entry&lt;? extends K, ? extends V&gt; entry: map.entrySet()) {
              put(entry.getKey(), entry.getValue());
          }
      }

      @Override
      public V remove(Object key) {
          if (root == null) throw new UnsupportedOperationException();

          Node deletedNode = new Node(null, null);
          root = removeHelper(root, (Comparable&lt;? super K&gt;) key, deletedNode);
          if (deletedNode.value != null) size--;
            
          return deletedNode.value;
      }

      public Node removeHelper(Node node, Comparable&lt;? super K&gt; key, Node deletedNode) {
          int cmp = key.compareTo(node.key);

          if (cmp &lt; 0) {
              node.left = removeHelper(node.left, key, deletedNode);
          } else if (cmp &gt; 0) {
              node.right = removeHelper(node.right, key, deletedNode);
          } else {
              // 삭제할 노드 찾음
              if(deletedNode != null) deletedNode.value = node.value;

              // (1) 리프 노드
              if (node.left == null &amp;&amp; node.right == null) return null;

              // (2) 자식 하나
              if (node.left == null) return node.right;
              if (node.right == null) return node.left;

              // (3) 자식 둘
              Node successor = findMin(node.right);  // 오른쪽 서브트리에서 가장 작은 값
              node.key = successor.key;
              node.value = successor.value;
              node.right = removeHelper(node.right, (Comparable&lt;? super K&gt;) successor.key, null);
          }
          return node;
      }
      ...
  }
</code></pre></div>    </div>
  </li>
  <li>clear는 root가 null이 될 시 자식 노드들을 수거하므로 선형시간임을 고려해야함</li>
  <li>findNode, put, remove는 key를 사용하기 때문에 트리의 높이에 비례하나 containsValue, keySet은 트리 전체를 검색하므로 n에 비례함</li>
  <li>트리의 모든 노드를 방문하는 방식으로 전위/중위/후위 순회가 있는데 containsValueHelper는 순서 상관없이 value를 확인하므로 전위 순회, addInorder는 오름차순으로 key 값을 정렬해야 하므로 중위 순회를 함</li>
  <li>위 코드에서 put 메소드를 확인해보면 순차적으로 증가하는 값들을 put 할 경우 오른쪽 자식에만 쏠린 불균형 트리가 됨</li>
  <li>불균형 트리를 해결하기 위해서는 Map에 키를 순서대로 넣지 않거나, put을 수정하여 트리가 불균형해질 때 노드를 재배열하는 로직을 추가해야 함(=자가 균형 트리)</li>
  <li>일반적인 자가 균형 트리로는 AVL 트리, 레드 블랙 트리가 있음</li>
  <li>java.util.TreeMap은 내부적으로 레드 블랙 트리로 구현되어 있어 순차적인 데이터가 삽입되어도 균형을 유지함</li>
  <li>remove 메소드는 삭제할 노드가 리프 노드인지, 자식 하나인지, 둘인지에 따라 다르게 동작함. 삭제할 노드의 자식이 둘일 경우 왼쪽 서브트리에서 가장 큰 값 또는 오른쪽 서브트리에서 가장 작은 값을 찾아 대체해야 함. 이는 트리의 균형을 다시 맞추는 작업과 유사한 연산을 거침</li>
</ul>

<h2 id="8-영속성">8. 영속성</h2>

<h3 id="81-redis">8.1 Redis</h3>
<ul>
  <li>앞의 7.1에서 두 가지 자료구조를 이용하여 인덱스를 저장했는데, 이러한 자료구조는 실행 중인 자바 프로그램의 메모리에 저장되어 프로그램이 멈추면 모두 사라짐</li>
  <li>레디스는 자바 자료구조와 유사한 영속적인 자료구조를 제공함. 기본적으로 String 타입의 키와 다양한 데이터 타입 중 하나를 값으로 넣을 수 있는 맵 구조를 가지며, 주요 자료구조는 아래와 같음
    <ul>
      <li>문자열 String</li>
      <li>자바 Set과 유사한 문자열 집합</li>
      <li>자바 List와 유사한 문자열 리스트</li>
      <li>자바 Map 과 유사한 해시
        <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public static void main(String[] args) throws IOException {

  Jedis jedis = make();

  // String
  jedis.set("mykey", "myvalue");
  String value = jedis.get("mykey");
  System.out.println("Got value: " + value);

  // Set
  jedis.sadd("myset", "element1", "element2", "element3");
  System.out.println("element2 is member: " + jedis.sismember("myset", "element2"));  // Jedis.sismember 메서드는 요소가 set에 있는지 검사

  // List
  jedis.rpush("mylist", "element1", "element2", "element3");                  // 리스트의 오른쪽 끝에 요소 추가
  System.out.println("element at index 1: " + jedis.lindex("mylist", 1));     // jedis.lindex는 정수 인덱스를 받아 list의 지정된 요소를 반환

  // Hash
  jedis.hset("myhash", "word1", Integer.toString(2));     // 키와 값은 모두 string이므로 Integer를 저장하려면 hset 메서드를 호출하기 전에 String 타입으로 변환해야 함
  jedis.hincrBy("myhash", "word2", 1);                    // word2 필드의 현재 값(존재하지 않으면 0)을 가져와서 1만큼 증가
  System.out.println("frequency of word1: " + jedis.hget("myhash", "word1"));
  System.out.println("frequency of word2: " + jedis.hget("myhash", "word2"));

  jedis.close();
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>자바 코드에서 Redis와 통신할 수 있게 해주는 클라이언트 라이브러리 Jedis를 만들고 서버에 연결하여 레디스 명령 실행</li>
  <li>Jedis.sismember, jedis.lindex, jedis.hincrBy 모두 상수시간 연산</li>
  <li>jedis.hset에서 첫번째 키는 특정 hash를 식별하고, 두번째 키(=필드)는 hash 안의 값을 식별함</li>
  <li>hash 안의 값의 정수인 경우가 많아 hincrby 같은 특별한 메서드가 제공됨. 이 메서드는 값을 정수로 취급함</li>
</ul>

<h2 id="9-위키피디아-크롤링과-검색-알고리즘">9. 위키피디아 크롤링과 검색 알고리즘</h2>

<h3 id="91-redis-기반의-인덱서-구현">9.1 Redis 기반의 인덱서 구현</h3>
<ul>
  <li>7.1에서 정의한 Index, TermCounter 클래스를 레디스로 이동</li>
  <li>레디스 데이터베이스에서 각 객체는 string 형의 유일한 키로만 식별되므로 두 종류 이상의 객체(Index, TermCounter)를 Redis에 넣는다면 이 둘을 구분할 수 있는 접두사를 추가해야 함
    <ul>
      <li>Index
        <ul>
          <li>Set에 키를 “URLSet : 단어”, 값을 url 주소로 저장</li>
          <li>해당 단어를 포함하는 url들의 Set</li>
        </ul>
      </li>
      <li>TermCounter
        <ul>
          <li>Hash에 첫번째 키를 “TermCounter : url 주소”, 두번째 키를 단어, 값을 단어 등장 횟수로 저장</li>
          <li>특정 url 주소 별 각 단어 등장 횟수 Map</li>
        </ul>
      </li>
      <li>기존 Index 객체에서는 단어 별 TermCounter들의 집합을 인스턴스로 가졌으나 TermCounter는 각 페이지 별 단어들과 단어 등장횟수를 저장하므로 Index 객체에 의존할 필요가 없음
        <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class JedisIndex {

  private Jedis jedis;

  public JedisIndex(Jedis jedis) {
      this.jedis = jedis;
  }

  private String urlSetKey(String term) {
      return "URLSet:" + term;
  }

  private String termCounterKey(String url) {
      return "TermCounter:" + url;
  }

  public void add(String term, TermCounter tc) {
      jedis.sadd(urlSetKey(term), tc.getLabel());
  }

  public boolean isIndexed(String url) {
      String redisKey = termCounterKey(url);
      return jedis.exists(redisKey);
  }

  public Map&lt;String, Integer&gt; getCounts(String term) {
      Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();
      Set&lt;String&gt; urls = getURLs(term);
      for (String url : urls) {
          Integer count = getCount(url, term);
          map.put(url, count);
      }
      return map;
  }

  public Set&lt;String&gt; getURLs(String term) {
      Set&lt;String&gt; set = jedis.smembers(urlSetKey(term));
      return set;
  }

  public Integer getCount(String url, String term) {
      String redisKey = termCounterKey(url);
      String count = jedis.hget(redisKey, term);
      return new Integer(count);
  }

  public void indexPage(String url, Elements paragraphs) {
      System.out.println("Indexing " + url);
      // Termcounter 객체를 만들어 단락에 있는 검색어 개수를 셉니다
      TermCounter tc = new TermCounter(url);
      tc.processElements(paragraphs);
      // TermCounter의 내용을 레디스에 푸시합니다
      pushTermCounterToRedis(tc);
  }

  // url 별 term 등장횟수를 담은 TermCounter를 레디스의 Set 형태로 전환하여 레디스에 푸시
  public List&lt;Object&gt; pushTermCounterToRedis(TermCounter tc) {
      // jedis.multi()는 Jedis 객체의 모든 메서드를 제공하는 Transaction 객체를 반환
      Transaction t = jedis.multi();
      String url = tc.getLabel();
      String hashname = termCounterKey(url); // TermCounter : url
      // 페이지가 이미 인덱싱되어 있다면 기존 해시를 제거합니다
      t.del(hashname);
      // 각 검색어에 대해 TermCounter 에 엔트리와 인덱스의 새 멤버를 추가합니다.
      for (String term: tc.keySet()) {
          Integer count = tc.get(term);
          t.hset(hashname, term, count.toString()); //redis의 hash 자료구조에 추가
          t.sadd(urlSetKey(term), url); //redis의 set 자료구조에 추가 "URLSet: term"
      }
      List&lt;Object&gt; res = t.exec();    // 매번 서버와 통신하면 시간이 더 소요되므로 Transaction 동작을 모아뒀다 한꺼번에 적용
      return res;
  }
        
  // 인덱스 테스트를 위해 호출
  private static void loadIndex(JedisIndex index) throws IOException {
      WikiFetcher wf = new WikiFetcher();

      String url = "https://en.wikipedia.org/wiki/Java_(programming_language)";
      Elements paragraphs = wf.readWikipedia(url);
      index.indexPage(url, paragraphs);

      url = "https://en.wikipedia.org/wiki/Programming_language";
      paragraphs = wf.readWikipedia(url);
      index.indexPage(url, paragraphs);
  }
  ...
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>조회 성능 분석 : n개의 페이지 인덱싱 후 m개의 고유한 검색어를 검색 할 때 소요되는 시간 (getCounts)
    <ol>
      <li>HashMap을 생성</li>
      <li>getURL 메소드 호출하여 해당 단어를 포함한 URL 집합을 가져옴
        <ul>
          <li>getURL 메소드의 jedis.smembers는 Redis의 Set 자료구조에서 모든 요소를 가져오는 메서드로 단어에 해당하는 url들을 모두 순회함</li>
        </ul>
      </li>
      <li>집합에 있는 각 URL에 대해 getCount 메소드 호출하여 HashMap에 엔트리 추가
        <ul>
          <li>반복문 안에서 해당 단어가 등장하는 url 개수만큼 getCount를 호출하는데, 상수시간 연산이라 전체 복잡도는 최악의 상황에 n이 됨. 하지만 실제로 검색어를 포함한 페이지의 개수는 n보다 작은 경우가 많음</li>
        </ul>
      </li>
    </ol>
  </li>
  <li>인덱싱 성능 분석 : 한 페이지를 인덱싱하는데 소요되는 시간 (indexPage)
    <ol>
      <li>해당 url 페이지의 DOM 트리를 순회하고 모든 TextNode 객체를 찾고 문자열을 검색어로 쪼갬</li>
      <li>각 검색어에 대해 HashMap 에 있는 카운터를 증가 (7.1의 TermCounter 클래스 processElements 함수 참고)</li>
      <li>pushTermCounterToRedis을 호출하여 검색어 별로 레디스에 해당 페이지에 대한 Index, TermCounter 저장</li>
      <li>1, 2번 동작은 페이지에 있는 단어 개수에 비례하고 3번 동작은 고유한 단어 개수에 비례하므로, 전체 복잡도는 페이지에 있는 단어 개수에 비례</li>
      <li>이론상 한 페이지가 인덱스의 모든 검색어를 포함할 경우 성능은 O(M)이지만 대부분의 검색 엔진은 관련 페이지를 식별하는데 도움되지 않는 일반적인 단어는 인덱싱하지 않음</li>
    </ol>
  </li>
</ul>

<h3 id="92-redis-기반-인덱스를-활용한-웹-크롤러-구현">9.2 Redis 기반 인덱스를 활용한 웹 크롤러 구현</h3>
<ul>
  <li>6.2.2에서 언급한 WikiPhilosophy 클래스에서는 Wikipedia 페이지를 순회하며 링크를 따라가는 크롤링 작업을 수행했는데, 각 페이지의 첫 번째 유효 링크만 따라갔던 WikiPhilosophy와 다르게 Wikipedia 전체를 인덱싱하기 위한 웹 크롤러 WikiCrawler 구현</li>
  <li>보통 아래와 같은 동작을 할 때 웹 크롤러라고 함
    <ul>
      <li>시작 페이지를 로드하고 내용을 인덱싱합니다.</li>
      <li>페이지에 있는 모든 링크를 찾고 연결된 URL 들을 컬렉션에 추가합니다.</li>
      <li>컬렉션을 반복하며 페이지를 로딩하고 이 페이지를 인덱싱하고 새로운 URL 을 추가합니다.</li>
      <li>이미 인덱싱된 URL 을 찾으면 건너뜁니다.</li>
    </ul>
  </li>
  <li>웹은 일종의 그래프와 같음. 각 페이지가 노드, 각 링크는 한 노드에서 다른 노드로의 단반향 선이 됨. 그래프를 탐색하기 위해 큐(queue)를 사용해 내부 링크를 순서대로 넓게 탐색함</li>
  <li>URL을 저장한 컬렉션에 따라 크롤러가 수행할 순회 방식이 결정되는데, 큐(FIFO)라면 너비 우선 탐색을, 스택(LIFO)이라면 크롤러는 깊이 우선 탐색을 함. 컬렉션에 있는 엔트리에 우선순위를 부여하여 오랫동안 인덱싱 되지 않은 페이지에 더 높은 우선순위를 주기도 함</li>
  <li>소스 노드에서 시작해 도달할 수 있는 노드를 한번 씩 방문하면서 각 Wikipedia 페이지의 단어 인덱스를 생성하는데, 한 페이지라도 새로 인덱싱되면 종료하고 있음
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class WikiCrawler {

      @SuppressWarnings("unused")
      private final String source;

      private JedisIndex index;

      // queue of URLs to be indexed
      private Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();

      // fetcher used to get pages from Wikipedia
      final static WikiFetcher wf = new WikiFetcher();

      public WikiCrawler(String source, JedisIndex index) {
          this.source = source;
          this.index = index;
          queue.offer(source);
      }

      public int queueSize() {
          return queue.size();
      }

      public String crawl(boolean testing) throws IOException {
          if (queue.isEmpty()) {
              return null;
          }
          //큐에서 첫 번째 요소를 꺼내 반환하고 제거. 큐가 비어 있다면 null을 반환함
          String url = queue.poll();
          System.out.println("Crawling " + url);

          if (testing==false &amp;&amp; index.isIndexed(url)) {
              System.out.println("Already indexed.");
              return null;
          }
            
          Elements paragraphs;
          if (testing) {
              // 코드 저장소에 포함된 페이지의 캐시된 사본을 읽음
              paragraphs = wf.readWikipedia(url);
          } else {
              // 웹에 실제로 있는 최신 내용을 읽음
              paragraphs = wf.fetchWikipedia(url);
          }
          index.indexPage(url, paragraphs);
          // 큐에 페이지에 있는 링크들을 추가
          queueInternalLinks(paragraphs);		
          return url;
      }

      void queueInternalLinks(Elements paragraphs) {
          for (Element paragraph: paragraphs) {
              queueInternalLinks(paragraph);
          }
      }
        
      private void queueInternalLinks(Element paragraph) {
          Elements elts = paragraph.select("a[href]");
          for (Element elt: elts) {
              String relURL = elt.attr("href");
                
              if (relURL.startsWith("/wiki/")) {
                  String absURL = "https://en.wikipedia.org" + relURL;
                  //System.out.println(absURL);
                  queue.offer(absURL);
              }
          }
      }
        
      public static void main(String[] args) throws IOException {
          // make a WikiCrawler
          Jedis jedis = JedisMaker.make();
          JedisIndex index = new JedisIndex(jedis);
          String source = "https://en.wikipedia.org/wiki/Java_(programming_language)";
          WikiCrawler wc = new WikiCrawler(source, index);
            
          // source 주소를 주고 해당 페이지의 링크들을 큐에 추가
          Elements paragraphs = wf.fetchWikipedia(source);
          wc.queueInternalLinks(paragraphs);

          // loop until we index a new page
          String res;
          do {
              // test 용으로 돌릴 때만 true
              res = wc.crawl(false);
          } while (res == null);
            
          // "the"라는 단어를 인덱스에서 검색, 페이지 별 등장 횟수 출력
          Map&lt;String, Integer&gt; map = index.getCounts("the");
          for (Entry&lt;String, Integer&gt; entry: map.entrySet()) {
              System.out.println(entry);
          }
      }
  }
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="93-불리언-검색으로-검색-결과-조합하기">9.3 불리언 검색으로 검색 결과 조합하기</h3>
<ul>
  <li>검색 엔진 기능을 구현하려면 각 검색어를 포함하는 페이지를 반환하는 조회 기능(9.1, 9.2) 다음으로 불리언 로직을 사용하여 다수의 검색어로부터의 결과를 조합하는 불리언 검색이 필요함
    <ul>
      <li>검색어에 따라 AND, OR, -(차집합) 등</li>
      <li>예시
        <ul>
          <li>java AND programming</li>
          <li>java OR programming</li>
          <li>java -indonesia</li>
        </ul>
      </li>
      <li>예시와 같이 검색어와 연산을 함께 포함한 표현을 쿼리라 함
        <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class WikiSearch {

  // map from URLs that contain the term(s) to relevance score
  private Map&lt;String, Integer&gt; map;

  public WikiSearch(Map&lt;String, Integer&gt; map) {
      this.map = map;
  }

  public Integer getRelevance(String url) {
      Integer relevance = map.get(url);
      return relevance==null ? 0: relevance;
  }

  private  void print() {
      List&lt;Entry&lt;String, Integer&gt;&gt; entries = sort();
      for (Entry&lt;String, Integer&gt; entry: entries) {
          System.out.println(entry);
      }
  }

  public WikiSearch or(WikiSearch that) {
      Map&lt;String, Integer&gt; union = new HashMap&lt;String, Integer&gt;(map);
      for (String term: that.map.keySet()) {
          int relevance = totalRelevance(this.getRelevance(term), that.getRelevance(term));
          union.put(term, relevance);
      }
      return new WikiSearch(union);
  }

  public WikiSearch and(WikiSearch that) {
      Map&lt;String, Integer&gt; intersection = new HashMap&lt;String, Integer&gt;();
      for (String term: map.keySet()) {
          if (that.map.containsKey(term)) {
              int relevance = totalRelevance(this.map.get(term), that.map.get(term));
              intersection.put(term, relevance);
          }
      }
      return new WikiSearch(intersection);
  }

  public WikiSearch minus(WikiSearch that) {
      Map&lt;String, Integer&gt; difference = new HashMap&lt;String, Integer&gt;(map);
      for (String term: that.map.keySet()) {
          difference.remove(term);
      }
      return new WikiSearch(difference);
  }

  protected int totalRelevance(Integer rel1, Integer rel2) {
      // simple starting place: relevance is the sum of the term frequencies.
      return rel1 + rel2;
  }

  public List&lt;Entry&lt;String, Integer&gt;&gt; sort() {

      // entrySet()은 이 key-value 쌍들을 모아서 Set&lt;Map.Entry&lt;K,V&gt;&gt; 형태로 반환
      // Set은 순서가 보장되지 않으므로 정렬을 위해 List 형태로 복사
      List&lt;Entry&lt;String, Integer&gt;&gt; entries = 
              new LinkedList&lt;Entry&lt;String, Integer&gt;&gt;(map.entrySet());
            
      // make a Comparator object for sorting
      Comparator&lt;Entry&lt;String, Integer&gt;&gt; comparator = new Comparator&lt;Entry&lt;String, Integer&gt;&gt;() {
          @Override
          public int compare(Entry&lt;String, Integer&gt; e1, Entry&lt;String, Integer&gt; e2) {
              return e1.getValue().compareTo(e2.getValue());
          }
      };
            
      // sort and return the entries
      Collections.sort(entries, comparator);
      return entries;
  }

  public static WikiSearch search(String term, JedisIndex index) {
      Map&lt;String, Integer&gt; map = index.getCounts(term);
      return new WikiSearch(map);
  }

  public static void main(String[] args) throws IOException {

      // make a JedisIndex
      Jedis jedis = JedisMaker.make();
      JedisIndex index = new JedisIndex(jedis);

      // search for the first term
      String term1 = "java";
      System.out.println("Query: " + term1);
      WikiSearch search1 = search(term1, index);
      search1.print();

      // search for the second term
      String term2 = "programming";
      System.out.println("Query: " + term2);
      WikiSearch search2 = search(term2, index);
      search2.print();

      // compute the intersection of the searches
      System.out.println("Query: " + term1 + " AND " + term2);
      WikiSearch intersection = search1.and(search2);
      intersection.print();
  }
  }
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>WikiSearch의 map은 URL과 해당 페이지의 관련성 점수까지 포함. 관련성 점수는 쿼리에서 추론한 사용자의 요구를 페이지가 얼마나 잘 반영하였는지를 나타낸 수치로, 여기선 해당 페이지에 검색어가 몇 번이나 등장했는지에 대한 TF(term frequency)에 기반을 둠</li>
  <li>다수의 검색어일 때 페이지의 관련성은 TF의 합이 됨</li>
  <li>sort 메서드의 내용을 채워서 관련성이 높은 순서로 결과를 반환. 어떤 종류의 List 객체를 정렬할 때는 java.util.Collections 클래스의 sort 메서드를 사용함</li>
  <li>Collections.sort 메서드를 사용하려면 인자로 받는 리스트의 요소 자체가 Comparable를 구현하거나, Comparator 객체를 리스트와 함께 인자로 전달해야 함</li>
</ul>

<h4 id="931-comparable과-comparator">9.3.1 Comparable과 Comparator</h4>
<ul>
  <li>Comparable
    <ul>
      <li>Comparable 인터페이스의 compareTo() 메소드 명세에는 this가 that 보다 작으면 음수를 반환하고, this가 더 크면 양수를 반환하고, 두 개가 같으면 0 을 반환하게 되어 있음
        <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public class Card implements Comparable&lt;Card&gt; {

      private final int rank:
      private final int suit;

      public int compareTo(Card that) {
          if (this.suit &lt; that.suit) {
              return -1;
          }
          if (this.suit &gt; that.suit) {
              return 1;
          }
          if (this.rank &lt; that.rank) {
              return -1;
          }
          if (this.rank &gt; that.rank) {
              return 1;
          }
          return 0;
      }
      ...
  }
</code></pre></div>        </div>
      </li>
      <li>아래의 sort 메서드는 객체 자체에서 순서를 결정하므로 자연 순서로 요소를 정렬
        <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  Collections.sort(cards);
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>Comparator
    <ul>
      <li>Comparator 객체를 주입하여 다른 순서로 정렬할 수도 있음. 예를 들면 카드 게임에서는 기본적으로 에이스가 가장 낮은 등급이지만, 어떤 카드 게임에서는 가장 높은 등급이 되기도 함. 아래와 같이 에이스를 최상에 놓는 Comparator 객체를 정의할 수 있음
        <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  Comparator&lt;Card&gt; comparator = new Comparator&lt;Card&gt;() {
      @Override
      public int compare(Card card1, Card card2) {
          if (card1.getSuit() &lt; card2.getSuit()) {
              return -1;
          }
          if (card1.getSuit() &gt; card2.getSuit()) {
              return 1;
          }
          int rank1 = getRankAceHigh(card1);
          int rank2 = getRankAceHigh(card2);

          if (rank1 &lt; rank2) {
              return -1;
          }
          if (rank1 &gt; rank2) {
              return 1;
          }
          return 0;
      }

      private int getRankAceHigh(Card card) {
          int rank = card.getRank();
          if (rank == 1) {
              return 14;
          } else {
              return rank;
          }
      }
  };    
</code></pre></div>        </div>
      </li>
      <li>아래와 같이 호출 가능
        <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  Collections.sort(cards, comparator);
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="10-정렬">10. 정렬</h2>

<h3 id="101-삽입-정렬">10.1 삽입 정렬</h3>
<ul>
  <li>예제
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public void insertionSort(List&lt;T&gt; list, Comparator&lt;T&gt; comparator) {
	
      for (int i=1; i &lt; list.size(); i++) {
          T elt_i = list.get(i);
          int j = i;
          while (j &gt; 0) {
              T elt_j = list.get(j-1);
              if (comparator.compare(elt_i, elt_j) &gt;= 0) {
                  break;
              }
              list.set(j, elt_j);
              j--;
          }
          list.set(j, elt_i);
      }
  }    
</code></pre></div>    </div>
  </li>
  <li>이중 루프를 돌려 리스트의 앞부분부터 차례대로 정렬된 부분을 확장해 감</li>
  <li>elt_i에 정렬해야 할 값을 복사해 넣고 그 앞의 이미 정렬된 리스트에서 끼워 넣을 올바른 위치를 찾을 때까지 앞의 요소들을 한 칸씩 오른쪽으로 이동시킴</li>
  <li>외부 반복문은 1부터 list.size()까지 반복하고 내부 반복문은 i에서 0까지 반복하므로 총 실행 횟수는 이차가 됨</li>
  <li>단, 요소가 이미 어느정도 정렬되어 있으면 삽입 정렬은 선형이 됨. 또한 실행시간이 an^2 이지만 구현이 단순해 최대 차수의 계수인 a가 작음</li>
</ul>

<h3 id="102-병합-정렬">10.2 병합 정렬</h3>
<ul>
  <li>예제
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public void mergeSortInPlace(List&lt;T&gt; list, Comparator&lt;T&gt; comparator) {
      List&lt;T&gt; sorted = mergeSort(list, comparator);
      list.clear();
      list.addAll(sorted);
  }

  public List&lt;T&gt; mergeSort(List&lt;T&gt; list, Comparator&lt;T&gt; comparator) {
      int size = list.size();
      if (size &lt;= 1) {
          return list;
      }
      // make two lists with half the elements each.
      List&lt;T&gt; first = mergeSort(new LinkedList&lt;T&gt;(list.subList(0, size/2)), comparator);
      List&lt;T&gt; second = mergeSort(new LinkedList&lt;T&gt;(list.subList(size/2, size)), comparator);
		
      return merge(first, second, comparator);
  }

  private List&lt;T&gt; merge(List&lt;T&gt; first, List&lt;T&gt; second, Comparator&lt;T&gt; comparator) {

      List&lt;T&gt; result = new LinkedList&lt;T&gt;();
      int total = first.size() + second.size();
      for (int i=0; i&lt;total; i++) {
          List&lt;T&gt; winner = pickWinner(first, second, comparator);
          result.add(winner.remove(0));
      }
      return result;
  }

  private List&lt;T&gt; pickWinner(List&lt;T&gt; first, List&lt;T&gt; second, Comparator&lt;T&gt; comparator) {
      if (first.size() == 0) {
          return second;
      }
      if (second.size() == 0) {
          return first;
      }
      int res = comparator.compare(first.get(0), second.get(0));
      if (res &lt; 0) {
          return first;
      }
      if (res &gt; 0) {
          return second;
      }
      return first;
  }
</code></pre></div>    </div>
  </li>
  <li>맨 앞에서 요소를 제거(remove(0))하는 연산이 O(1)인 LinkedList 사용</li>
  <li>크기가 1이 될 때까지 list를 쪼갠 다음, merge 할때 양쪽 리스트는 각각 오름차순 정렬이 되어있으므로 양쪽 리스트의 가장 앞에서부터 비교하여 더 작은 값부터 반환할 리스트에 추가</li>
  <li>크기가 1이 될 때까지 n을 반으로 나누는 횟수는 log n, 1에서 n으로 돌아가기 위해서도 log n번 병합이 필요하고 병합하는 과정에서 n번 이하로 루프를 돌리므로 전체 시간은 O(n log n)이 됨</li>
  <li>O(n log n)은 비교 정렬 알고리즘의 이론적 하한선으로 알려져 있음</li>
</ul>

<h3 id="103-기수-정렬">10.3 기수 정렬</h3>
<ul>
  <li>비교하지 않는 정렬. 32bit 정수 또는 20 캐릭터 문자열과 같이 요소의 크기가 제한된 경우에 동작함</li>
  <li>정수나 문자열 등의 자리수(digit) 단위로 나누어 정렬
    <ul>
      <li>먼저 일의 자리, 그 다음 십의 자리, 마지막으로 백의 자리 순으로 정렬</li>
    </ul>
  </li>
  <li>각 자리수를 정렬할 때 카운팅 정렬(알파벳 또는 제한된 숫자 순)을 사용하므로 단어 정렬에서 알파벳 26자를 k, 리스트에 있는 단어의 개수를 n, 단어의 최대 자릿수를 d라고 하면 시간복잡도는 O(d×(n+k))가 됨 =&gt; 선형
    <ul>
      <li>순서
        <ol>
          <li>카운트 배열 count[] 초기화
            <ul>
              <li>각 자릿수의 가능한 값(예: 알파벳 26개)에 대해 등장 횟수를 저장할 배열 생성</li>
              <li>배열 크기 = 26, 모든 값 0으로 초기화</li>
            </ul>
          </li>
          <li>원소 세기 (count 업데이트)
            <ul>
              <li>리스트의 각 원소를 확인하며 해당 값에 1씩 더함</li>
              <li>예: “cat” → 첫 글자 ‘c’에 해당하는 count 증가</li>
            </ul>
          </li>
          <li>누적합으로 count[] 업데이트
            <ul>
              <li>count[i] = 현재 값 i가 들어갈 끝 위치</li>
              <li>이 정보를 이용하면 원소를 정렬된 위치에 바로 배치 가능</li>
            </ul>
          </li>
          <li>새 배열에 배치
            <ul>
              <li>리스트를 순회하며, count를 참고해 각 원소를 새 배열에 넣음</li>
              <li>count[i]는 값 i가 들어갈 마지막 인덱스를 의미하므로, 배치 후 count[i]–로 다음 동일 값이 올 위치를 조정</li>
            </ul>
          </li>
        </ol>
      </li>
      <li>2, 3번은 n, 1, 4번은 k만큼 소요되므로 2n+2k이 됨. 상수를 제거하면 n+k</li>
    </ul>
  </li>
</ul>

<h3 id="104-힙-정렬">10.4 힙 정렬</h3>
<ul>
  <li>힙을 이용해 최대값(또는 최소값)을 반복적으로 제거하며 정렬하는 알고리즘</li>
  <li>힙은 이진 탐색 트리와 유사한 자료구조이지만 다른 규칙을 가짐
    <ul>
      <li>이진 탐색트리의 각 노드는 왼쪽 하위 트리보다 크고 오른쪽 하위 트리보다 작은 값을 갖지만, 최소 힙에서 각 노드의 양쪽 하위트리는 모두 부모 노드의 값보다 큼</li>
    </ul>
  </li>
  <li>힙은 요소를 추가하거나 제거하면 트리의 균형을 맞추는 작업을 추가로 하므로 균형 이진 탐색트리와 비슷함</li>
  <li>힙에서 최대값(또는 최소값)는 항상 루트에 있고 상수 시간으로 찾을 수 있음. 힙에서 요소를 추가하거나 제거하는 시간은 트리의 높이인 h 에 비례하며, 균형을 유지하기 때문에 h는 log n에 비례함</li>
  <li>자바의 PriorityQueue 클래스는 힙으로 구현되어 있으며 Queue 인터페이스에 정의된 offer와 poll 메서드를 제공함
    <ul>
      <li>offer : 큐에 요소를 추가하며 모든 노드가 힙 속성을 갖도록 힙을 갱신. 실행시간은 log n</li>
      <li>poll : 루트로부터 큐에서 가장 작은 요소(최소 힙의 경우)를 제거하고 힙을 갱신. 실행시간은 log n</li>
    </ul>
  </li>
  <li>PriorityQueue는 이진 힙 자료구조로 되어있으며, 내부적으로는 배열로 저장됨. 기본적으로 최소 힙으로 동작하나 Comparator를 지정하여 최대 힙이나 사용자 정의 순서로 변경할 수 있음</li>
  <li>PriorityQueue 객체가 주어지면 offer 메소드로 컬렉션의 모든 요소를 추가한 다음, poll 메소드로 큐에서 요소들을 제거하며 List에 요소들을 추가하여 정렬을 쉽게 할 수 있음. poll 메서드는 루트에 있는 요소를 반환하므로 최소 힙의 경우 요소는 오름차순으로 List에 추가됨
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public void heapSort(List&lt;T&gt; list, Comparator&lt;T&gt; comparator) {
      // comparator는 단순 Integer 값을 비교함
      PriorityQueue&lt;T&gt; heap = new PriorityQueue&lt;T&gt;(list.size(), comparator);
      heap.addAll(list);
      list.clear();
      while (!heap.isEmpty()) {
          list.add(heap.poll());
      }
  }
</code></pre></div>    </div>
  </li>
  <li>큐에 n개의 요소를 추가하거나 제거 시 n log n 시간이 걸림. 따라서 힙 정렬의 실행시간은 O(n log n) 이 됨</li>
</ul>

<h4 id="1041-제한된-힙-정렬">10.4.1 제한된 힙 정렬</h4>
<ul>
  <li>최대 k개의 요소만 담을 수 있는 힙. 상위 k개의 요소를 추적하기 위해 최소 힙을 사용하여 힙이 가득찰 경우 새로 추가할 요소가 힙에서 가장 작은 요소보다 클 때만 해당 요소를 대체하도록 함
    <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  public List&lt;T&gt; topK(int k, List&lt;T&gt; list, Comparator&lt;T&gt; comparator) {
      PriorityQueue&lt;T&gt; heap = new PriorityQueue&lt;T&gt;(list.size(), comparator);
      for (T element: list) {
          // 힙이 가득차지 않았으면 새로 추가
          if (heap.size() &lt; k) {
              heap.offer(element);
              continue;
          }
          // heap.peek()은 힙의 루트를 반환
          int cmp = comparator.compare(element, heap.peek());
          // element가 루트보다 우선순위가 높을 경우 루트를 제거하고 element 삽입
          if (cmp &gt; 0) {
              heap.poll();
              heap.offer(element);
          }
      }
      List&lt;T&gt; res = new ArrayList&lt;T&gt;();
      while (!heap.isEmpty()) {
          res.add(heap.poll());
      }
      return res;
  }
</code></pre></div>    </div>
  </li>
  <li>성능 분석
    <ul>
      <li>힙에서 가장 작은 요소를 찾는 것은 O(1), comparator.compare도 단순 Integer 비교로 O(1)</li>
      <li>가장 작은 요소를 제거하는 것은 O(log k)이며 최악의 상황에서 요소가 오름차순으로 정렬되었을 경우 새로 추가하는 것도 O(log k)
        <ul>
          <li>입력 리스트가 아래와 같은 경우 새로 추가될 값이 항상 기존 힙의 루트보다 크지만, 이런 상황에서도 새 요소를 추가하거나 교체하는 데는 O(log k)가 걸림
            <ul>
              <li>[1, 2, 3, 4, 5, 6, 7, 8, 9 … n]</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>따라서 위의 예제에서 n개 요소를 정렬하는 총 시간은 O(n log k)이고 n에 선형임</li>
    </ul>
  </li>
</ul>

<h2 id="11-공간-복잡도">11. 공간 복잡도</h2>
<ul>
  <li>대부분 응용 프로그램에서 가능한 공간보다는 실행시간에 좀 더 많은 관심을 두지만 대규모 데이터셋일 때는 공간 복잡도 역시 고려해야 함
    <ul>
      <li>데이터셋을 단일 프로그램의 메모리에 모두 담을 수 없다면 실행시간은 급격히 늘어나거나 아예 실행할 수가 없게 되는데, 적은 공간이 필요한 알고리즘을 선택하여 메모리에서 계산할 수 있게 만들면 실행 속도는 훨씬 빨라짐. 또한 적은 공간을 사용하는 프로그램은 CPU 캐시를 더 잘 활용하고 더 빠르게 실행할 수 있음</li>
    </ul>
  </li>
  <li>병합 정렬의 단점 중 하나는 데이터의 복사본을 만든다는 것인데, 앞의 구현에서 할당하는 총 공간은 O(n log n)이나 좀 더 개선하면 공간 요구사항을 O(n)까지 낮출 수 있음
    <ul>
      <li>mergeSort() 메소드의 아래 부분에서 subList로 list의 노드를 first, second에 복사하는 대신 노드를 재활용하면 공간 복잡도를 O(n)으로 개선 가능
        <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>  List&lt;T&gt; first = mergeSort(new LinkedList&lt;T&gt;(list.subList(0, size/2)), comparator);
  List&lt;T&gt; second = mergeSort(new LinkedList&lt;T&gt;(list.subList(size/2, size)), comparator);
</code></pre></div>        </div>
      </li>
      <li>새 리스트 생성 없이 완전히 노드 연결만 재배치하게 변경할 경우 O(log n)까지도 개선할 수 있다고 함</li>
    </ul>
  </li>
  <li>삽입 정렬은 병합 정렬과 달리 그 자리에서 바로 요소를 정렬하기 때문에 공간적으로 개수의 크기(n)에 의존하지 않는다는 장점이 있음</li>
  <li>힙 정렬 구현은 요소를 저장하고자 새로운 PriorityQueue 객체를 생성하므로 공간은 O(n)이나, 리스트를 그 자리에서 바로 정렬하면 O(1)로 줄일 수 있음. 제한된 힙 정렬에서는 k에 비례하는 공간만 필요해짐
    <ul>
      <li>PriorityQueue 같은 별도 자료구조를 사용하지 않고, ArrayList 자체를 배열처럼 다뤄서 힙 기능을 구현</li>
    </ul>
  </li>
</ul>



    </div>

</article>
<div class="post-nav">
<a class="previous" href="/cs/2025/07/22/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-(%EC%9E%90%EB%B0%94%EC%9D%98-%EC%8B%A0-vol.1).html" title="자바 기초 정리1 (자바의 신 vol.1)">자바 기초 정리1 (자바의 신 vol.1)...</a><a class="next" href="/cs/2025/10/20/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-(%EC%9E%90%EB%B0%94%EC%9D%98-%EC%8B%A0-vol.2).html" title="자바 기초 정리2 (자바의 신 vol.2)">자바 기초 정리2 (자바의 신 vol.2)...</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li class="">
          <a class="post-link" href="/cs/2025/10/20/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-(%EC%9E%90%EB%B0%94%EC%9D%98-%EC%8B%A0-vol.2).html" title="자바 기초 정리2 (자바의 신 vol.2)">
            자바 기초 정리2 (자바의 신 vol.2)<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/cs/2025/07/22/%EC%9E%90%EB%B0%94-%EA%B8%B0%EC%B4%88-%EC%A0%95%EB%A6%AC-(%EC%9E%90%EB%B0%94%EC%9D%98-%EC%8B%A0-vol.1).html" title="자바 기초 정리1 (자바의 신 vol.1)">
            자바 기초 정리1 (자바의 신 vol.1)<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/cs/2025/09/11/%EC%9E%90%EB%B0%94%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%95%B5%EC%8B%AC-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.html" title="자바로 배우는 핵심 자료구조와 알고리즘">
            자바로 배우는 핵심 자료구조와 알고리즘<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
<li class="">
          <a class="post-link" href="/cs/2025/01/01/SSE.html" title="SSE">
            SSE<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li>
</ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
<div>Unpublished Work <span class="copyleft">©</span> 2017-2025 Toyo</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
